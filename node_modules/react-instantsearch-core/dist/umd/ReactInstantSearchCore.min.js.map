{"version":3,"file":"ReactInstantSearchCore.min.js","sources":["../../../../node_modules/react-fast-compare/index.js","../../src/core/utils.ts","../../src/core/context.ts","../../src/core/createConnector.tsx","../../src/core/highlight.js","../../src/core/version.js","../../src/core/indexUtils.js","../../src/connectors/connectConfigure.js","../../src/widgets/Configure.js","../../../../node_modules/process-es6/browser.js","../../../../node_modules/rollup-plugin-node-globals/src/global.js","../../../../node_modules/react-is/cjs/react-is.production.min.js","../../../../node_modules/react-is/index.js","../../node_modules/prop-types/factoryWithThrowingShims.js","../../node_modules/prop-types/lib/ReactPropTypesSecret.js","../../node_modules/prop-types/index.js","../../../../node_modules/@algolia/events/events.js","../../../algoliasearch-helper/src/functions/inherits.js","../../../algoliasearch-helper/src/DerivedHelper/index.js","../../../algoliasearch-helper/src/functions/escapeFacetValue.js","../../../algoliasearch-helper/src/functions/merge.js","../../../algoliasearch-helper/src/functions/objectHasKeys.js","../../../algoliasearch-helper/src/functions/omit.js","../../../algoliasearch-helper/src/requestBuilder.js","../../../algoliasearch-helper/src/functions/defaultsPure.js","../../../algoliasearch-helper/src/functions/find.js","../../../algoliasearch-helper/src/functions/intersection.js","../../../algoliasearch-helper/src/functions/valToNumber.js","../../../algoliasearch-helper/src/SearchParameters/RefinementList.js","../../../algoliasearch-helper/src/SearchParameters/index.js","../../../algoliasearch-helper/src/utils/isValidUserToken.js","../../../algoliasearch-helper/src/functions/compact.js","../../../algoliasearch-helper/src/functions/findIndex.js","../../../algoliasearch-helper/src/functions/formatSort.js","../../../algoliasearch-helper/src/functions/orderBy.js","../../../algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js","../../../algoliasearch-helper/src/SearchResults/index.js","../../../algoliasearch-helper/src/version.js","../../../algoliasearch-helper/src/algoliasearch.helper.js","../../../algoliasearch-helper/index.js","../../src/connectors/connectConfigureRelatedItems.ts","../../src/widgets/ConfigureRelatedItems.tsx","../../src/connectors/connectDynamicWidgets.ts","../../src/widgets/DynamicWidgets.tsx","../../src/connectors/connectQueryRules.ts","../../src/widgets/QueryRuleContext.ts","../../src/widgets/Index.tsx","../../src/core/createInstantSearchManager.js","../../src/core/createWidgetsManager.ts","../../src/core/createStore.ts","../../src/core/metadata.ts","../../src/widgets/InstantSearch.tsx","../../src/connectors/connectAutoComplete.js","../../src/connectors/connectBreadcrumb.js","../../src/connectors/connectGeoSearch.js","../../src/connectors/connectHierarchicalMenu.js","../../src/connectors/connectCurrentRefinements.js","../../src/connectors/connectHighlight.js","../../src/connectors/connectHits.js","../../src/connectors/connectHitsPerPage.js","../../src/connectors/connectInfiniteHits.js","../../src/connectors/connectMenu.js","../../src/connectors/connectNumericMenu.js","../../src/connectors/connectPagination.js","../../src/connectors/connectPoweredBy.js","../../src/connectors/connectRange.js","../../src/connectors/connectRefinementList.js","../../src/connectors/connectScrollTo.js","../../src/connectors/connectSearchBox.js","../../src/connectors/connectRelevantSort.ts","../../src/connectors/connectSortBy.js","../../src/connectors/connectStateResults.js","../../src/connectors/connectStats.ts","../../src/connectors/connectToggleRefinement.js","../../src/connectors/connectHitInsights.ts","../../src/connectors/connectVoiceSearch.js","../../src/index.ts","../../src/core/translatable.js"],"sourcesContent":["/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */\n\nvar hasElementType = typeof Element !== 'undefined';\nvar hasMap = typeof Map === 'function';\nvar hasSet = typeof Set === 'function';\nvar hasArrayBuffer = typeof ArrayBuffer === 'function';\n\n// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js\n\nfunction equal(a, b) {\n  // START: fast-deep-equal es6/index.js 3.1.1\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    // START: Modifications:\n    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code\n    //    to co-exist with es5.\n    // 2. Replace `for of` with es5 compliant iteration using `for`.\n    //    Basically, take:\n    //\n    //    ```js\n    //    for (i of a.entries())\n    //      if (!b.has(i[0])) return false;\n    //    ```\n    //\n    //    ... and convert to:\n    //\n    //    ```js\n    //    it = a.entries();\n    //    while (!(i = it.next()).done)\n    //      if (!b.has(i.value[0])) return false;\n    //    ```\n    //\n    //    **Note**: `i` access switches to `i.value`.\n    var it;\n    if (hasMap && (a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!b.has(i.value[0])) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      return true;\n    }\n\n    if (hasSet && (a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!b.has(i.value[0])) return false;\n      return true;\n    }\n    // END: Modifications\n\n    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    // END: fast-deep-equal\n\n    // START: react-fast-compare\n    // custom handling for DOM elements\n    if (hasElementType && a instanceof Element) return false;\n\n    // custom handling for React\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        // .$$typeof and ._store on just reasonable markers of a react element\n        continue;\n      }\n\n      // all other properties should be traversed as usual\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n    // END: react-fast-compare\n\n    // START: fast-deep-equal\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n// end fast-deep-equal\n\nmodule.exports = function isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if (((error.message || '').match(/stack|recursion/i))) {\n      // warn on circular references, don't crash\n      // browsers give this different errors name and messages:\n      // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n      // firefox: \"InternalError\", too much recursion\"\n      // edge: \"Error\", \"Out of stack space\"\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n    // some other error. we should definitely know about these\n    throw error;\n  }\n};\n","// eslint-disable-next-line @typescript-eslint/unbound-method\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// From https://github.com/reactjs/react-redux/blob/master/src/utils/shallowEqual.js\nexport const shallowEqual = (objA: any, objB: any) => {\n  if (objA === objB) {\n    return true;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const getDisplayName = (Component: any) =>\n  Component.displayName || Component.name || 'UnknownComponent';\n\nconst resolved = Promise.resolve();\nexport const defer = (f: any) => {\n  resolved.then(f);\n};\n\nconst isPlainObject = (value: unknown): value is object =>\n  typeof value === 'object' && value !== null && !Array.isArray(value);\n\nexport const removeEmptyKey = (obj: Record<string, any>) => {\n  Object.keys(obj).forEach((key) => {\n    const value = obj[key];\n\n    if (!isPlainObject(value)) {\n      return;\n    }\n\n    if (!objectHasKeys(value)) {\n      delete obj[key];\n    } else {\n      removeEmptyKey(value);\n    }\n  });\n\n  return obj;\n};\n\nexport const removeEmptyArraysFromObject = (obj: Record<string, any>) => {\n  Object.keys(obj).forEach((key) => {\n    const value = obj[key];\n\n    if (Array.isArray(value) && value.length === 0) {\n      delete obj[key];\n    }\n  });\n\n  return obj;\n};\n\nexport function addAbsolutePositions(\n  hits: any[],\n  hitsPerPage: number,\n  page: number\n) {\n  return hits.map((hit, index) => ({\n    ...hit,\n    __position: hitsPerPage * page + index + 1,\n  }));\n}\n\nexport function addQueryID(hits: any[], queryID: string) {\n  if (!queryID) {\n    return hits;\n  }\n  return hits.map((hit) => ({\n    ...hit,\n    __queryID: queryID,\n  }));\n}\n\nexport function find<TItem = any>(\n  array: TItem[],\n  comparator: (item: TItem) => boolean\n): TItem | undefined {\n  if (!Array.isArray(array)) {\n    return undefined;\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    if (comparator(array[i])) {\n      return array[i];\n    }\n  }\n  return undefined;\n}\n\nexport function objectHasKeys(object: object | undefined) {\n  return object && Object.keys(object).length > 0;\n}\n\n// https://github.com/babel/babel/blob/3aaafae053fa75febb3aa45d45b6f00646e30ba4/packages/babel-helpers/src/helpers.js#L604-L620\nexport function omit(\n  source: Record<string, any>,\n  excluded: string[]\n): Record<string, any> {\n  if (source === null || source === undefined) {\n    return {};\n  }\n  const target: Record<string, any> = {};\n  const sourceKeys = Object.keys(source);\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    target[key] = source[key];\n  }\n  return target;\n}\n\n/**\n * Retrieve the value at a path of the object:\n *\n * @example\n * getPropertyByPath(\n *   { test: { this: { function: [{ now: { everyone: true } }] } } },\n *   'test.this.function[0].now.everyone'\n * ); // true\n *\n * getPropertyByPath(\n *   { test: { this: { function: [{ now: { everyone: true } }] } } },\n *   ['test', 'this', 'function', 0, 'now', 'everyone']\n * ); // true\n *\n * @param object Source object to query\n * @param path either an array of properties, or a string form of the properties, separated by .\n */\nexport const getPropertyByPath = (\n  object: Record<string, any>,\n  path: string[] | string\n): any =>\n  (Array.isArray(path)\n    ? path\n    : path.replace(/\\[(\\d+)]/g, '.$1').split('.')\n  ).reduce((current, key) => (current ? current[key] : undefined), object);\n\nexport function getObjectType(object: unknown): string {\n  return Object.prototype.toString.call(object).slice(8, -1);\n}\n\nexport function unescapeFacetValue(value: string): string {\n  return value.replace(/^\\\\-/, '-');\n}\n","import { createContext } from 'react';\n\nimport type { Store } from '../core/createStore';\nimport type InstantSearch from '../widgets/InstantSearch';\n\nexport type InstantSearchContext = {\n  onInternalStateUpdate: InstantSearch['onWidgetsInternalStateUpdate'];\n  createHrefForState: InstantSearch['createHrefForState'];\n  onSearchForFacetValues: InstantSearch['onSearchForFacetValues'];\n  onSearchStateChange: InstantSearch['onSearchStateChange'];\n  onSearchParameters: InstantSearch['onSearchParameters'];\n  store: Store;\n  widgetsManager: any;\n  mainTargetedIndex: string;\n};\n\nexport const instantSearchContext = createContext<InstantSearchContext>({\n  onInternalStateUpdate: () => undefined,\n  createHrefForState: () => '#',\n  onSearchForFacetValues: () => undefined,\n  onSearchStateChange: () => undefined,\n  onSearchParameters: () => undefined,\n  store: {} as Store,\n  widgetsManager: {},\n  mainTargetedIndex: '',\n});\n\nexport const {\n  Consumer: InstantSearchConsumer,\n  Provider: InstantSearchProvider,\n} = instantSearchContext;\n\nexport type IndexContext =\n  | {\n      targetedIndex: string;\n    }\n  | undefined;\n\nexport const { Consumer: IndexConsumer, Provider: IndexProvider } =\n  createContext<IndexContext>(undefined);\n","import React, { Component } from 'react';\nimport isEqual from 'react-fast-compare';\n\nimport { InstantSearchConsumer, IndexConsumer } from './context';\nimport { shallowEqual, getDisplayName, removeEmptyKey } from './utils';\n\nimport type { InstantSearchContext, IndexContext } from './context';\nimport type { ElementType } from 'react';\n\nexport type ConnectorDescription = {\n  displayName: string;\n  $$type: string;\n  /**\n   * a function to filter the local state\n   */\n  refine?: (...args: any[]) => any;\n  /**\n   * function transforming the local state to a SearchParameters\n   */\n  getSearchParameters?: (...args: any[]) => any;\n  /**\n   * metadata of the widget (for current refinements)\n   */\n  getMetadata?: (...args: any[]) => any;\n  /**\n   * hook after the state has changed\n   */\n  transitionState?: (...args: any[]) => any;\n  /**\n   * transform the state into props passed to the wrapped component.\n   * Receives (props, widgetStates, searchState, metadata) and returns the local state.\n   */\n  getProvidedProps: (...args: any[]) => any;\n  /**\n   * Receives props and return the id that will be used to identify the widget\n   */\n  getId?: (...args: any[]) => string;\n  /**\n   * hook when the widget will unmount. Receives (props, searchState) and return a cleaned state.\n   */\n  cleanUp?: (...args: any[]) => any;\n  searchForFacetValues?: (...args: any[]) => any;\n  shouldComponentUpdate?: (...args: any[]) => boolean;\n  /**\n   * PropTypes forwarded to the wrapped component.\n   */\n  propTypes?: Record<string, any>; // I can't find a definition for a propTypes object\n  defaultProps?: Record<string, any>;\n};\n\nexport type AdditionalWidgetProperties = {\n  $$widgetType?: string;\n};\n\ntype ConnectorProps = {\n  contextValue: InstantSearchContext;\n  indexContextValue?: IndexContext;\n};\n\nexport type ConnectedProps<TWidgetProps> = TWidgetProps & ConnectorProps;\n\ntype ConnectorState = {\n  providedProps: {};\n};\n\n/**\n * Connectors are the HOC used to transform React components\n * into InstantSearch widgets.\n * In order to simplify the construction of such connectors\n * `createConnector` takes a description and transform it into\n * a connector.\n * @param {ConnectorDescription} connectorDesc the description of the connector\n * @return {Connector} a function that wraps a component into\n * an instantsearch connected one.\n */\nexport function createConnectorWithoutContext(\n  connectorDesc: ConnectorDescription\n) {\n  if (!connectorDesc.displayName) {\n    throw new Error(\n      '`createConnector` requires you to provide a `displayName` property.'\n    );\n  }\n\n  const isWidget =\n    typeof connectorDesc.getSearchParameters === 'function' ||\n    typeof connectorDesc.getMetadata === 'function' ||\n    typeof connectorDesc.transitionState === 'function';\n\n  return (\n    Composed: ElementType,\n    additionalWidgetProperties: AdditionalWidgetProperties = {}\n  ) => {\n    class Connector extends Component<ConnectorProps, ConnectorState> {\n      static displayName = `${connectorDesc.displayName}(${getDisplayName(\n        Composed\n      )})`;\n      static $$type = connectorDesc.$$type;\n      static $$widgetType = additionalWidgetProperties.$$widgetType;\n      static propTypes = connectorDesc.propTypes;\n      static defaultProps = connectorDesc.defaultProps;\n      static _connectorDesc = connectorDesc;\n\n      unsubscribe?: () => void;\n      unregisterWidget?: () => void;\n\n      cleanupTimerRef: ReturnType<typeof setTimeout> | null = null;\n      isUnmounting = false;\n\n      state: ConnectorState = {\n        providedProps: this.getProvidedProps(this.props),\n      };\n\n      constructor(props: ConnectorProps) {\n        super(props);\n\n        if (connectorDesc.getSearchParameters) {\n          this.props.contextValue.onSearchParameters(\n            connectorDesc.getSearchParameters.bind(this),\n            {\n              ais: this.props.contextValue,\n              multiIndexContext: this.props.indexContextValue,\n            },\n            this.props,\n            connectorDesc.getMetadata && connectorDesc.getMetadata.bind(this),\n            connectorDesc.displayName\n          );\n        }\n      }\n\n      componentDidMount() {\n        if (this.cleanupTimerRef) {\n          clearTimeout(this.cleanupTimerRef);\n          this.cleanupTimerRef = null;\n        }\n\n        this.unsubscribe = this.props.contextValue.store.subscribe(() => {\n          if (!this.isUnmounting) {\n            this.setState({\n              providedProps: this.getProvidedProps(this.props),\n            });\n          }\n        });\n\n        if (isWidget) {\n          this.unregisterWidget =\n            this.props.contextValue.widgetsManager.registerWidget(this);\n        }\n      }\n\n      shouldComponentUpdate(nextProps: any, nextState: any) {\n        if (typeof connectorDesc.shouldComponentUpdate === 'function') {\n          return connectorDesc.shouldComponentUpdate.call(\n            this,\n            this.props,\n            nextProps,\n            this.state,\n            nextState\n          );\n        }\n\n        const propsEqual = shallowEqual(this.props, nextProps);\n\n        if (\n          this.state.providedProps === null ||\n          nextState.providedProps === null\n        ) {\n          if (this.state.providedProps === nextState.providedProps) {\n            return !propsEqual;\n          }\n          return true;\n        }\n\n        return (\n          !propsEqual ||\n          !shallowEqual(this.state.providedProps, nextState.providedProps)\n        );\n      }\n\n      componentDidUpdate(prevProps: any) {\n        if (!isEqual(prevProps, this.props)) {\n          this.setState({\n            providedProps: this.getProvidedProps(this.props),\n          });\n\n          if (isWidget) {\n            this.props.contextValue.widgetsManager.update();\n\n            if (typeof connectorDesc.transitionState === 'function') {\n              this.props.contextValue.onSearchStateChange(\n                connectorDesc.transitionState.call(\n                  this,\n                  this.props,\n                  this.props.contextValue.store.getState().widgets,\n                  this.props.contextValue.store.getState().widgets\n                )\n              );\n            }\n          }\n        }\n      }\n\n      componentWillUnmount() {\n        this.cleanupTimerRef = setTimeout(() => {\n          this.isUnmounting = true;\n\n          if (this.unsubscribe) {\n            this.unsubscribe();\n          }\n\n          if (this.unregisterWidget) {\n            this.unregisterWidget();\n\n            if (typeof connectorDesc.cleanUp === 'function') {\n              const nextState = connectorDesc.cleanUp.call(\n                this,\n                this.props,\n                this.props.contextValue.store.getState().widgets\n              );\n\n              this.props.contextValue.store.setState({\n                ...this.props.contextValue.store.getState(),\n                widgets: nextState,\n              });\n\n              this.props.contextValue.onSearchStateChange(\n                removeEmptyKey(nextState)\n              );\n            }\n          }\n        });\n      }\n\n      getProvidedProps(props: any) {\n        const {\n          widgets,\n          results,\n          resultsFacetValues,\n          searching,\n          searchingForFacetValues,\n          isSearchStalled,\n          metadata,\n          error,\n        } = this.props.contextValue.store.getState();\n\n        const searchResults = {\n          results,\n          searching,\n          searchingForFacetValues,\n          isSearchStalled,\n          error,\n        };\n\n        return connectorDesc.getProvidedProps.call(\n          this,\n          props,\n          widgets,\n          searchResults,\n          metadata,\n          // @MAJOR: move this attribute on the `searchResults` it doesn't\n          // makes sense to have it into a separate argument. The search\n          // flags are on the object why not the results?\n          resultsFacetValues\n        );\n      }\n\n      getSearchParameters(searchParameters: any) {\n        if (typeof connectorDesc.getSearchParameters === 'function') {\n          return connectorDesc.getSearchParameters.call(\n            this,\n            searchParameters,\n            this.props,\n            this.props.contextValue.store.getState().widgets\n          );\n        }\n\n        return null;\n      }\n\n      getMetadata(nextWidgetsState: any) {\n        if (typeof connectorDesc.getMetadata === 'function') {\n          return connectorDesc.getMetadata.call(\n            this,\n            this.props,\n            nextWidgetsState\n          );\n        }\n\n        return {};\n      }\n\n      transitionState(prevWidgetsState: any, nextWidgetsState: any) {\n        if (typeof connectorDesc.transitionState === 'function') {\n          return connectorDesc.transitionState.call(\n            this,\n            this.props,\n            prevWidgetsState,\n            nextWidgetsState\n          );\n        }\n\n        return nextWidgetsState;\n      }\n\n      refine = (...args: any[]) => {\n        this.props.contextValue.onInternalStateUpdate(\n          // refine will always be defined here because the prop is only given conditionally\n          connectorDesc.refine!.call(\n            this,\n            this.props,\n            this.props.contextValue.store.getState().widgets,\n            ...args\n          )\n        );\n      };\n\n      createURL = (...args: any[]) =>\n        this.props.contextValue.createHrefForState(\n          // refine will always be defined here because the prop is only given conditionally\n          connectorDesc.refine!.call(\n            this,\n            this.props,\n            this.props.contextValue.store.getState().widgets,\n            ...args\n          )\n        );\n\n      searchForFacetValues = (...args: any[]) => {\n        this.props.contextValue.onSearchForFacetValues(\n          // searchForFacetValues will always be defined here because the prop is only given conditionally\n          connectorDesc.searchForFacetValues!.call(\n            this,\n            this.props,\n            this.props.contextValue.store.getState().widgets,\n            ...args\n          )\n        );\n      };\n\n      render() {\n        const { contextValue, ...props } = this.props;\n        const { providedProps } = this.state;\n\n        if (providedProps === null) {\n          return null;\n        }\n\n        const refineProps =\n          typeof connectorDesc.refine === 'function'\n            ? { refine: this.refine, createURL: this.createURL }\n            : {};\n\n        const searchForFacetValuesProps =\n          typeof connectorDesc.searchForFacetValues === 'function'\n            ? { searchForItems: this.searchForFacetValues }\n            : {};\n\n        return (\n          <Composed\n            {...props}\n            {...providedProps}\n            {...refineProps}\n            {...searchForFacetValuesProps}\n          />\n        );\n      }\n    }\n\n    return Connector;\n  };\n}\n\nconst createConnectorWithContext =\n  (connectorDesc: ConnectorDescription) =>\n  (\n    Composed: ElementType,\n    additionalWidgetProperties?: AdditionalWidgetProperties\n  ) => {\n    const Connector = createConnectorWithoutContext(connectorDesc)(\n      Composed,\n      additionalWidgetProperties\n    );\n\n    const ConnectorWrapper: React.FC<any> = (props) => (\n      <InstantSearchConsumer>\n        {(contextValue) => (\n          <IndexConsumer>\n            {(indexContextValue) => (\n              <Connector\n                contextValue={contextValue}\n                indexContextValue={indexContextValue}\n                {...props}\n              />\n            )}\n          </IndexConsumer>\n        )}\n      </InstantSearchConsumer>\n    );\n\n    return ConnectorWrapper;\n  };\n\nexport default createConnectorWithContext;\n","import { getPropertyByPath } from './utils';\n\nexport const HIGHLIGHT_TAGS = {\n  highlightPreTag: `<ais-highlight-0000000000>`,\n  highlightPostTag: `</ais-highlight-0000000000>`,\n};\n\n/**\n * Parses an highlighted attribute into an array of objects with the string value, and\n * a boolean that indicated if this part is highlighted.\n *\n * @param {string} preTag - string used to identify the start of an highlighted value\n * @param {string} postTag - string used to identify the end of an highlighted value\n * @param {string} highlightedValue - highlighted attribute as returned by Algolia highlight feature\n * @return {object[]} - An array of {value: string, isHighlighted: boolean}.\n */\nfunction parseHighlightedAttribute({ preTag, postTag, highlightedValue = '' }) {\n  const splitByPreTag = highlightedValue.split(preTag);\n  const firstValue = splitByPreTag.shift();\n  const elements =\n    firstValue === '' ? [] : [{ value: firstValue, isHighlighted: false }];\n\n  if (postTag === preTag) {\n    let isHighlighted = true;\n    splitByPreTag.forEach((split) => {\n      elements.push({ value: split, isHighlighted });\n      isHighlighted = !isHighlighted;\n    });\n  } else {\n    splitByPreTag.forEach((split) => {\n      const splitByPostTag = split.split(postTag);\n\n      elements.push({\n        value: splitByPostTag[0],\n        isHighlighted: true,\n      });\n\n      if (splitByPostTag[1] !== '') {\n        elements.push({\n          value: splitByPostTag[1],\n          isHighlighted: false,\n        });\n      }\n    });\n  }\n\n  return elements;\n}\n\n/**\n * Find an highlighted attribute given an `attribute` and an `highlightProperty`, parses it,\n * and provided an array of objects with the string value and a boolean if this\n * value is highlighted.\n *\n * In order to use this feature, highlight must be activated in the configuration of\n * the index. The `preTag` and `postTag` attributes are respectively highlightPreTag and\n * highlightPostTag in Algolia configuration.\n *\n * @param {string} preTag - string used to identify the start of an highlighted value\n * @param {string} postTag - string used to identify the end of an highlighted value\n * @param {string} highlightProperty - the property that contains the highlight structure in the results\n * @param {string} attribute - the highlighted attribute to look for\n * @param {object} hit - the actual hit returned by Algolia.\n * @return {object[]} - An array of {value: string, isHighlighted: boolean}.\n */\nexport function parseAlgoliaHit({\n  preTag = '<em>',\n  postTag = '</em>',\n  highlightProperty,\n  attribute,\n  hit,\n}) {\n  if (!hit) throw new Error('`hit`, the matching record, must be provided');\n\n  const highlightObject =\n    getPropertyByPath(hit[highlightProperty], attribute) || {};\n\n  if (Array.isArray(highlightObject)) {\n    return highlightObject.map((item) =>\n      parseHighlightedAttribute({\n        preTag,\n        postTag,\n        highlightedValue: item.value,\n      })\n    );\n  }\n\n  return parseHighlightedAttribute({\n    preTag,\n    postTag,\n    highlightedValue: highlightObject.value,\n  });\n}\n","export default '6.40.4';\n","import { omit } from './utils';\n\nexport function getIndexId(context) {\n  return hasMultipleIndices(context)\n    ? context.multiIndexContext.targetedIndex\n    : context.ais.mainTargetedIndex;\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @returns {import('algoliasearch-helper').SearchResults} results\n */\nexport function getResults(searchResults, context) {\n  if (searchResults.results) {\n    if (searchResults.results.hits) {\n      return searchResults.results;\n    }\n\n    const indexId = getIndexId(context);\n    if (searchResults.results[indexId]) {\n      return searchResults.results[indexId];\n    }\n  }\n\n  return null;\n}\n\nexport function hasMultipleIndices(context) {\n  return context && context.multiIndexContext;\n}\n\nexport function refineValue(\n  searchState,\n  nextRefinement,\n  context,\n  resetPage,\n  namespace\n) {\n  if (hasMultipleIndices(context)) {\n    const indexId = getIndexId(context);\n    return namespace\n      ? refineMultiIndexWithNamespace(\n          searchState,\n          nextRefinement,\n          indexId,\n          resetPage,\n          namespace\n        )\n      : refineMultiIndex(searchState, nextRefinement, indexId, resetPage);\n  } else {\n    // When we have a multi index page with shared widgets we should also\n    // reset their page to 1 if the resetPage is provided. Otherwise the\n    // indices will always be reset\n    // see: https://github.com/algolia/react-instantsearch/issues/310\n    // see: https://github.com/algolia/react-instantsearch/issues/637\n    if (searchState.indices && resetPage) {\n      Object.keys(searchState.indices).forEach((targetedIndex) => {\n        searchState = refineValue(\n          searchState,\n          { page: 1 },\n          { multiIndexContext: { targetedIndex } },\n          true,\n          namespace\n        );\n      });\n    }\n    return namespace\n      ? refineSingleIndexWithNamespace(\n          searchState,\n          nextRefinement,\n          resetPage,\n          namespace\n        )\n      : refineSingleIndex(searchState, nextRefinement, resetPage);\n  }\n}\n\nfunction refineMultiIndex(searchState, nextRefinement, indexId, resetPage) {\n  const page = resetPage ? { page: 1 } : undefined;\n  const state =\n    searchState.indices && searchState.indices[indexId]\n      ? {\n          ...searchState.indices,\n          [indexId]: {\n            ...searchState.indices[indexId],\n            ...nextRefinement,\n            ...page,\n          },\n        }\n      : {\n          ...searchState.indices,\n          [indexId]: {\n            ...nextRefinement,\n            ...page,\n          },\n        };\n\n  return {\n    ...searchState,\n    indices: state,\n  };\n}\n\nfunction refineSingleIndex(searchState, nextRefinement, resetPage) {\n  const page = resetPage ? { page: 1 } : undefined;\n  return { ...searchState, ...nextRefinement, ...page };\n}\n\nfunction refineMultiIndexWithNamespace(\n  searchState,\n  nextRefinement,\n  indexId,\n  resetPage,\n  namespace\n) {\n  const page = resetPage ? { page: 1 } : undefined;\n  const state =\n    searchState.indices && searchState.indices[indexId]\n      ? {\n          ...searchState.indices,\n          [indexId]: {\n            ...searchState.indices[indexId],\n            [namespace]: {\n              ...searchState.indices[indexId][namespace],\n              ...nextRefinement,\n            },\n            page: 1,\n          },\n        }\n      : {\n          ...searchState.indices,\n          [indexId]: {\n            [namespace]: nextRefinement,\n            ...page,\n          },\n        };\n\n  return {\n    ...searchState,\n    indices: state,\n  };\n}\n\nfunction refineSingleIndexWithNamespace(\n  searchState,\n  nextRefinement,\n  resetPage,\n  namespace\n) {\n  const page = resetPage ? { page: 1 } : undefined;\n  return {\n    ...searchState,\n    [namespace]: { ...searchState[namespace], ...nextRefinement },\n    ...page,\n  };\n}\n\nfunction getNamespaceAndAttributeName(id) {\n  const parts = id.match(/^([^.]*)\\.(.*)/);\n  const namespace = parts && parts[1];\n  const attributeName = parts && parts[2];\n\n  return { namespace, attributeName };\n}\n\nfunction hasRefinements({\n  multiIndex,\n  indexId,\n  namespace,\n  attributeName,\n  id,\n  searchState,\n}) {\n  if (multiIndex && namespace) {\n    return (\n      searchState.indices &&\n      searchState.indices[indexId] &&\n      searchState.indices[indexId][namespace] &&\n      Object.hasOwnProperty.call(\n        searchState.indices[indexId][namespace],\n        attributeName\n      )\n    );\n  }\n\n  if (multiIndex) {\n    return (\n      searchState.indices &&\n      searchState.indices[indexId] &&\n      Object.hasOwnProperty.call(searchState.indices[indexId], id)\n    );\n  }\n\n  if (namespace) {\n    return (\n      searchState[namespace] &&\n      Object.hasOwnProperty.call(searchState[namespace], attributeName)\n    );\n  }\n\n  return Object.hasOwnProperty.call(searchState, id);\n}\n\nfunction getRefinements({\n  multiIndex,\n  indexId,\n  namespace,\n  attributeName,\n  id,\n  searchState,\n}) {\n  if (multiIndex && namespace) {\n    return searchState.indices[indexId][namespace][attributeName];\n  }\n  if (multiIndex) {\n    return searchState.indices[indexId][id];\n  }\n  if (namespace) {\n    return searchState[namespace][attributeName];\n  }\n\n  return searchState[id];\n}\n\nexport function getCurrentRefinementValue(\n  props,\n  searchState,\n  context,\n  id,\n  defaultValue\n) {\n  const indexId = getIndexId(context);\n  const { namespace, attributeName } = getNamespaceAndAttributeName(id);\n  const multiIndex = hasMultipleIndices(context);\n  const args = {\n    multiIndex,\n    indexId,\n    namespace,\n    attributeName,\n    id,\n    searchState,\n  };\n  const hasRefinementsValue = hasRefinements(args);\n\n  if (hasRefinementsValue) {\n    return getRefinements(args);\n  }\n\n  if (props.defaultRefinement) {\n    return props.defaultRefinement;\n  }\n\n  return defaultValue;\n}\n\nexport function cleanUpValue(searchState, context, id) {\n  const indexId = getIndexId(context);\n  const { namespace, attributeName } = getNamespaceAndAttributeName(id);\n\n  if (hasMultipleIndices(context) && Boolean(searchState.indices)) {\n    return cleanUpValueWithMultiIndex({\n      attribute: attributeName,\n      searchState,\n      indexId,\n      id,\n      namespace,\n    });\n  }\n\n  return cleanUpValueWithSingleIndex({\n    attribute: attributeName,\n    searchState,\n    id,\n    namespace,\n  });\n}\n\nfunction cleanUpValueWithSingleIndex({\n  searchState,\n  id,\n  namespace,\n  attribute,\n}) {\n  if (namespace) {\n    return {\n      ...searchState,\n      [namespace]: omit(searchState[namespace], [attribute]),\n    };\n  }\n\n  return omit(searchState, [id]);\n}\n\nfunction cleanUpValueWithMultiIndex({\n  searchState,\n  indexId,\n  id,\n  namespace,\n  attribute,\n}) {\n  const indexSearchState = searchState.indices[indexId];\n\n  if (namespace && indexSearchState) {\n    return {\n      ...searchState,\n      indices: {\n        ...searchState.indices,\n        [indexId]: {\n          ...indexSearchState,\n          [namespace]: omit(indexSearchState[namespace], [attribute]),\n        },\n      },\n    };\n  }\n\n  if (indexSearchState) {\n    return {\n      ...searchState,\n      indices: {\n        ...searchState.indices,\n        [indexId]: omit(indexSearchState, [id]),\n      },\n    };\n  }\n\n  return searchState;\n}\n","import createConnector from '../core/createConnector';\nimport {\n  refineValue,\n  getIndexId,\n  hasMultipleIndices,\n} from '../core/indexUtils';\nimport { omit } from '../core/utils';\n\nfunction getId() {\n  return 'configure';\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaConfigure',\n  $$type: 'ais.configure',\n  getProvidedProps() {\n    return {};\n  },\n  getSearchParameters(searchParameters, props) {\n    const { children, contextValue, indexContextValue, ...items } = props;\n    return searchParameters.setQueryParameters(items);\n  },\n  transitionState(props, prevSearchState, nextSearchState) {\n    const id = getId();\n    const { children, contextValue, indexContextValue, ...items } = props;\n    const propKeys = Object.keys(props);\n    const nonPresentKeys = this._props\n      ? Object.keys(this._props).filter((prop) => propKeys.indexOf(prop) === -1)\n      : [];\n    this._props = props;\n    const nextValue = {\n      [id]: { ...omit(nextSearchState[id], nonPresentKeys), ...items },\n    };\n    return refineValue(nextSearchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n  cleanUp(props, searchState) {\n    const id = getId();\n    const indexId = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const subState =\n      hasMultipleIndices({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }) && searchState.indices\n        ? searchState.indices[indexId]\n        : searchState;\n\n    const configureKeys =\n      subState && subState[id] ? Object.keys(subState[id]) : [];\n\n    const configureState = configureKeys.reduce((acc, item) => {\n      if (!props[item]) {\n        acc[item] = subState[id][item];\n      }\n      return acc;\n    }, {});\n\n    const nextValue = { [id]: configureState };\n\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n});\n","import connectConfigure from '../connectors/connectConfigure';\n\n/**\n * Configure is a widget that lets you provide raw search parameters\n * to the Algolia API.\n *\n * Any of the props added to this widget will be forwarded to Algolia. For more information\n * on the different parameters that can be set, have a look at the\n * [reference](https://www.algolia.com/doc/api-client/javascript/search#search-parameters).\n *\n * This widget can be used either with react-dom and react-native. It will not render anything\n * on screen, only configure some parameters.\n *\n * Read more in the [Search parameters](guide/Search_parameters.html) guide.\n * @name Configure\n * @kind widget\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, Configure, Hits } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n *\n * const App = () => (\n *   <InstantSearch\n *     searchClient={searchClient}\n *     indexName=\"instant_search\"\n *   >\n *     <Configure hitsPerPage={5} />\n *     <Hits />\n *   </InstantSearch>\n * );\n */\n\nexport default connectConfigure(\n  function Configure() {\n    return null;\n  },\n  { $$widgetType: 'ais.configure' }\n);\n","// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nexport function nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nexport var title = 'browser';\nexport var platform = 'browser';\nexport var browser = true;\nexport var env = {};\nexport var argv = [];\nexport var version = ''; // empty string to avoid regexp issues\nexport var versions = {};\nexport var release = {};\nexport var config = {};\n\nfunction noop() {}\n\nexport var on = noop;\nexport var addListener = noop;\nexport var once = noop;\nexport var off = noop;\nexport var removeListener = noop;\nexport var removeAllListeners = noop;\nexport var emit = noop;\n\nexport function binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nexport function cwd () { return '/' }\nexport function chdir (dir) {\n    throw new Error('process.chdir is not supported');\n};\nexport function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nexport function hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3\n  var seconds = Math.floor(clocktime)\n  var nanoseconds = Math.floor((clocktime%1)*1e9)\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0]\n    nanoseconds = nanoseconds - previousTimestamp[1]\n    if (nanoseconds<0) {\n      seconds--\n      nanoseconds += 1e9\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nexport function uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nexport default {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n","export default (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n","/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';var b=\"function\"===typeof Symbol&&Symbol.for,c=b?Symbol.for(\"react.element\"):60103,d=b?Symbol.for(\"react.portal\"):60106,e=b?Symbol.for(\"react.fragment\"):60107,f=b?Symbol.for(\"react.strict_mode\"):60108,g=b?Symbol.for(\"react.profiler\"):60114,h=b?Symbol.for(\"react.provider\"):60109,k=b?Symbol.for(\"react.context\"):60110,l=b?Symbol.for(\"react.async_mode\"):60111,m=b?Symbol.for(\"react.concurrent_mode\"):60111,n=b?Symbol.for(\"react.forward_ref\"):60112,p=b?Symbol.for(\"react.suspense\"):60113,q=b?\nSymbol.for(\"react.suspense_list\"):60120,r=b?Symbol.for(\"react.memo\"):60115,t=b?Symbol.for(\"react.lazy\"):60116,v=b?Symbol.for(\"react.block\"):60121,w=b?Symbol.for(\"react.fundamental\"):60117,x=b?Symbol.for(\"react.responder\"):60118,y=b?Symbol.for(\"react.scope\"):60119;\nfunction z(a){if(\"object\"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||\"object\"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\n// EventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","'use strict';\n\nfunction inherits(ctor, superCtor) {\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    },\n  });\n}\n\nmodule.exports = inherits;\n","'use strict';\n\nvar EventEmitter = require('@algolia/events');\n\nvar inherits = require('../functions/inherits');\n\n/**\n * A DerivedHelper is a way to create sub requests to\n * Algolia from a main helper.\n * @class\n * @classdesc The DerivedHelper provides an event based interface for search callbacks:\n *  - search: when a search is triggered using the `search()` method.\n *  - result: when the response is retrieved from Algolia and is processed.\n *    This event contains a {@link SearchResults} object and the\n *    {@link SearchParameters} corresponding to this answer.\n * @param {AlgoliaSearchHelper} mainHelper the main helper\n * @param {function} fn the function to create the derived state\n */\nfunction DerivedHelper(mainHelper, fn) {\n  this.main = mainHelper;\n  this.fn = fn;\n  this.lastResults = null;\n}\n\ninherits(DerivedHelper, EventEmitter);\n\n/**\n * Detach this helper from the main helper\n * @return {undefined}\n * @throws Error if the derived helper is already detached\n */\nDerivedHelper.prototype.detach = function () {\n  this.removeAllListeners();\n  this.main.detachDerivedHelper(this);\n};\n\nDerivedHelper.prototype.getModifiedState = function (parameters) {\n  return this.fn(parameters);\n};\n\nmodule.exports = DerivedHelper;\n","'use strict';\n\n/**\n * Replaces a leading - with \\-\n * @private\n * @param {any} value the facet value to replace\n * @returns {any} the escaped facet value or the value if it was not a string\n */\nfunction escapeFacetValue(value) {\n  if (typeof value !== 'string') return value;\n\n  return String(value).replace(/^-/, '\\\\-');\n}\n\n/**\n * Replaces a leading \\- with -\n * @private\n * @param {any} value the escaped facet value\n * @returns {any} the unescaped facet value or the value if it was not a string\n */\nfunction unescapeFacetValue(value) {\n  if (typeof value !== 'string') return value;\n\n  return value.replace(/^\\\\-/, '-');\n}\n\nmodule.exports = {\n  escapeFacetValue: escapeFacetValue,\n  unescapeFacetValue: unescapeFacetValue,\n};\n","'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (var key in source) {\n    if (\n      !Object.prototype.hasOwnProperty.call(source, key) ||\n      key === '__proto__' ||\n      key === 'constructor'\n    ) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (\n      isObjectOrArrayOrFunction(targetVal) &&\n      isObjectOrArrayOrFunction(sourceVal)\n    ) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} target The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n","'use strict';\n\nfunction objectHasKeys(obj) {\n  return obj && Object.keys(obj).length > 0;\n}\n\nmodule.exports = objectHasKeys;\n","'use strict';\n\n// https://github.com/babel/babel/blob/3aaafae053fa75febb3aa45d45b6f00646e30ba4/packages/babel-helpers/src/helpers.js#L604-L620\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source === null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key;\n  var i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    // eslint-disable-next-line no-continue\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\n","'use strict';\n\nvar merge = require('./functions/merge');\n\nfunction sortObject(obj) {\n  return Object.keys(obj)\n    .sort()\n    .reduce(function (acc, curr) {\n      acc[curr] = obj[curr];\n      return acc;\n    }, {});\n}\n\nvar requestBuilder = {\n  /**\n   * Get all the queries to send to the client, those queries can used directly\n   * with the Algolia client.\n   * @private\n   * @param  {string} index The name of the index\n   * @param  {SearchParameters} state The state from which to get the queries\n   * @return {object[]} The queries\n   */\n  _getQueries: function getQueries(index, state) {\n    var queries = [];\n\n    // One query for the hits\n    queries.push({\n      indexName: index,\n      params: requestBuilder._getHitsSearchParams(state),\n    });\n\n    // One for each disjunctive facets\n    state.getRefinedDisjunctiveFacets().forEach(function (refinedFacet) {\n      queries.push({\n        indexName: index,\n        params: requestBuilder._getDisjunctiveFacetSearchParams(\n          state,\n          refinedFacet\n        ),\n      });\n    });\n\n    // More to get the parent levels of the hierarchical facets when refined\n    state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n      var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n      var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n      var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n      // If we are deeper than level 0 (starting from `beer > IPA`)\n      // we want to get all parent values\n      if (\n        currentRefinement.length > 0 &&\n        currentRefinement[0].split(separator).length > 1\n      ) {\n        // We generate a map of the filters we will use for our facet values queries\n        var filtersMap = currentRefinement[0]\n          .split(separator)\n          .slice(0, -1)\n          .reduce(function createFiltersMap(map, segment, level) {\n            return map.concat({\n              attribute: hierarchicalFacet.attributes[level],\n              value:\n                level === 0\n                  ? segment\n                  : [map[map.length - 1].value, segment].join(separator),\n            });\n          }, []);\n\n        filtersMap.forEach(function (filter, level) {\n          var params = requestBuilder._getDisjunctiveFacetSearchParams(\n            state,\n            filter.attribute,\n            level === 0\n          );\n\n          // Keep facet filters unrelated to current hierarchical attributes\n          function hasHierarchicalFacetFilter(value) {\n            return hierarchicalFacet.attributes.some(function (attribute) {\n              return attribute === value.split(':')[0];\n            });\n          }\n\n          var filteredFacetFilters = (params.facetFilters || []).reduce(\n            function (acc, facetFilter) {\n              if (Array.isArray(facetFilter)) {\n                var filtered = facetFilter.filter(function (filterValue) {\n                  return !hasHierarchicalFacetFilter(filterValue);\n                });\n\n                if (filtered.length > 0) {\n                  acc.push(filtered);\n                }\n              }\n\n              if (\n                typeof facetFilter === 'string' &&\n                !hasHierarchicalFacetFilter(facetFilter)\n              ) {\n                acc.push(facetFilter);\n              }\n\n              return acc;\n            },\n            []\n          );\n\n          var parent = filtersMap[level - 1];\n          if (level > 0) {\n            params.facetFilters = filteredFacetFilters.concat(\n              parent.attribute + ':' + parent.value\n            );\n          } else {\n            params.facetFilters =\n              filteredFacetFilters.length > 0\n                ? filteredFacetFilters\n                : undefined;\n          }\n\n          queries.push({ indexName: index, params: params });\n        });\n      }\n    });\n\n    return queries;\n  },\n\n  /**\n   * Build search parameters used to fetch hits\n   * @private\n   * @param  {SearchParameters} state The state from which to get the queries\n   * @return {object.<string, any>} The search parameters for hits\n   */\n  _getHitsSearchParams: function (state) {\n    var facets = state.facets\n      .concat(state.disjunctiveFacets)\n      .concat(requestBuilder._getHitsHierarchicalFacetsAttributes(state))\n      .sort();\n\n    var facetFilters = requestBuilder._getFacetFilters(state);\n    var numericFilters = requestBuilder._getNumericFilters(state);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      facets: facets.indexOf('*') > -1 ? ['*'] : facets,\n      tagFilters: tagFilters,\n    };\n\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n\n  /**\n   * Build search parameters used to fetch a disjunctive facet\n   * @private\n   * @param  {SearchParameters} state The state from which to get the queries\n   * @param  {string} facet the associated facet name\n   * @param  {boolean} hierarchicalRootLevel ?? FIXME\n   * @return {object} The search parameters for a disjunctive facet\n   */\n  _getDisjunctiveFacetSearchParams: function (\n    state,\n    facet,\n    hierarchicalRootLevel\n  ) {\n    var facetFilters = requestBuilder._getFacetFilters(\n      state,\n      facet,\n      hierarchicalRootLevel\n    );\n    var numericFilters = requestBuilder._getNumericFilters(state, facet);\n    var tagFilters = requestBuilder._getTagFilters(state);\n    var additionalParams = {\n      hitsPerPage: 0,\n      page: 0,\n      analytics: false,\n      clickAnalytics: false,\n    };\n\n    if (tagFilters.length > 0) {\n      additionalParams.tagFilters = tagFilters;\n    }\n\n    var hierarchicalFacet = state.getHierarchicalFacetByName(facet);\n\n    if (hierarchicalFacet) {\n      additionalParams.facets =\n        requestBuilder._getDisjunctiveHierarchicalFacetAttribute(\n          state,\n          hierarchicalFacet,\n          hierarchicalRootLevel\n        );\n    } else {\n      additionalParams.facets = facet;\n    }\n\n    if (numericFilters.length > 0) {\n      additionalParams.numericFilters = numericFilters;\n    }\n\n    if (facetFilters.length > 0) {\n      additionalParams.facetFilters = facetFilters;\n    }\n\n    return sortObject(merge({}, state.getQueryParams(), additionalParams));\n  },\n\n  /**\n   * Return the numeric filters in an algolia request fashion\n   * @private\n   * @param {SearchParameters} state the state from which to get the filters\n   * @param {string} [facetName] the name of the attribute for which the filters should be excluded\n   * @return {string[]} the numeric filters in the algolia format\n   */\n  _getNumericFilters: function (state, facetName) {\n    if (state.numericFilters) {\n      return state.numericFilters;\n    }\n\n    var numericFilters = [];\n\n    Object.keys(state.numericRefinements).forEach(function (attribute) {\n      var operators = state.numericRefinements[attribute] || {};\n      Object.keys(operators).forEach(function (operator) {\n        var values = operators[operator] || [];\n        if (facetName !== attribute) {\n          values.forEach(function (value) {\n            if (Array.isArray(value)) {\n              var vs = value.map(function (v) {\n                return attribute + operator + v;\n              });\n              numericFilters.push(vs);\n            } else {\n              numericFilters.push(attribute + operator + value);\n            }\n          });\n        }\n      });\n    });\n\n    return numericFilters;\n  },\n\n  /**\n   * Return the tags filters depending on which format is used, either tagFilters or tagRefinements\n   * @private\n   * @param {SearchParameters} state the state from which to get the filters\n   * @return {string} Tag filters in a single string\n   */\n  _getTagFilters: function (state) {\n    if (state.tagFilters) {\n      return state.tagFilters;\n    }\n\n    return state.tagRefinements.join(',');\n  },\n\n  /**\n   * Build facetFilters parameter based on current refinements. The array returned\n   * contains strings representing the facet filters in the algolia format.\n   * @private\n   * @param  {SearchParameters} state The state from which to get the queries\n   * @param  {string} [facet] if set, the current disjunctive facet\n   * @param  {boolean} [hierarchicalRootLevel] ?? FIXME\n   * @return {array.<string>} The facet filters in the algolia format\n   */\n  _getFacetFilters: function (state, facet, hierarchicalRootLevel) {\n    var facetFilters = [];\n\n    var facetsRefinements = state.facetsRefinements || {};\n    Object.keys(facetsRefinements)\n      .sort()\n      .forEach(function (facetName) {\n        var facetValues = facetsRefinements[facetName] || [];\n        facetValues.sort().forEach(function (facetValue) {\n          facetFilters.push(facetName + ':' + facetValue);\n        });\n      });\n\n    var facetsExcludes = state.facetsExcludes || {};\n    Object.keys(facetsExcludes)\n      .sort()\n      .forEach(function (facetName) {\n        var facetValues = facetsExcludes[facetName] || [];\n        facetValues.sort().forEach(function (facetValue) {\n          facetFilters.push(facetName + ':-' + facetValue);\n        });\n      });\n\n    var disjunctiveFacetsRefinements = state.disjunctiveFacetsRefinements || {};\n    Object.keys(disjunctiveFacetsRefinements)\n      .sort()\n      .forEach(function (facetName) {\n        var facetValues = disjunctiveFacetsRefinements[facetName] || [];\n        if (facetName === facet || !facetValues || facetValues.length === 0) {\n          return;\n        }\n        var orFilters = [];\n\n        facetValues.sort().forEach(function (facetValue) {\n          orFilters.push(facetName + ':' + facetValue);\n        });\n\n        facetFilters.push(orFilters);\n      });\n\n    var hierarchicalFacetsRefinements =\n      state.hierarchicalFacetsRefinements || {};\n    Object.keys(hierarchicalFacetsRefinements)\n      .sort()\n      .forEach(function (facetName) {\n        var facetValues = hierarchicalFacetsRefinements[facetName] || [];\n        var facetValue = facetValues[0];\n\n        if (facetValue === undefined) {\n          return;\n        }\n\n        var hierarchicalFacet = state.getHierarchicalFacetByName(facetName);\n        var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n        var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n        var attributeToRefine;\n        var attributesIndex;\n\n        // we ask for parent facet values only when the `facet` is the current hierarchical facet\n        if (facet === facetName) {\n          // if we are at the root level already, no need to ask for facet values, we get them from\n          // the hits query\n          if (\n            facetValue.indexOf(separator) === -1 ||\n            (!rootPath && hierarchicalRootLevel === true) ||\n            (rootPath &&\n              rootPath.split(separator).length ===\n                facetValue.split(separator).length)\n          ) {\n            return;\n          }\n\n          if (!rootPath) {\n            attributesIndex = facetValue.split(separator).length - 2;\n            facetValue = facetValue.slice(0, facetValue.lastIndexOf(separator));\n          } else {\n            attributesIndex = rootPath.split(separator).length - 1;\n            facetValue = rootPath;\n          }\n\n          attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n        } else {\n          attributesIndex = facetValue.split(separator).length - 1;\n\n          attributeToRefine = hierarchicalFacet.attributes[attributesIndex];\n        }\n\n        if (attributeToRefine) {\n          facetFilters.push([attributeToRefine + ':' + facetValue]);\n        }\n      });\n\n    return facetFilters;\n  },\n\n  _getHitsHierarchicalFacetsAttributes: function (state) {\n    var out = [];\n\n    return state.hierarchicalFacets.reduce(\n      // ask for as much levels as there's hierarchical refinements\n      function getHitsAttributesForHierarchicalFacet(\n        allAttributes,\n        hierarchicalFacet\n      ) {\n        var hierarchicalRefinement = state.getHierarchicalRefinement(\n          hierarchicalFacet.name\n        )[0];\n\n        // if no refinement, ask for root level\n        if (!hierarchicalRefinement) {\n          allAttributes.push(hierarchicalFacet.attributes[0]);\n          return allAttributes;\n        }\n\n        var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n        var level = hierarchicalRefinement.split(separator).length;\n        var newAttributes = hierarchicalFacet.attributes.slice(0, level + 1);\n\n        return allAttributes.concat(newAttributes);\n      },\n      out\n    );\n  },\n\n  _getDisjunctiveHierarchicalFacetAttribute: function (\n    state,\n    hierarchicalFacet,\n    rootLevel\n  ) {\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    if (rootLevel === true) {\n      var rootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n      var attributeIndex = 0;\n\n      if (rootPath) {\n        attributeIndex = rootPath.split(separator).length;\n      }\n      return [hierarchicalFacet.attributes[attributeIndex]];\n    }\n\n    var hierarchicalRefinement =\n      state.getHierarchicalRefinement(hierarchicalFacet.name)[0] || '';\n    // if refinement is 'beers > IPA > Flying dog',\n    // then we want `facets: ['beers > IPA']` as disjunctive facet (parent level values)\n\n    var parentLevel = hierarchicalRefinement.split(separator).length - 1;\n    return hierarchicalFacet.attributes.slice(0, parentLevel + 1);\n  },\n\n  getSearchForFacetQuery: function (facetName, query, maxFacetHits, state) {\n    var stateForSearchForFacetValues = state.isDisjunctiveFacet(facetName)\n      ? state.clearRefinements(facetName)\n      : state;\n    var searchForFacetSearchParameters = {\n      facetQuery: query,\n      facetName: facetName,\n    };\n    if (typeof maxFacetHits === 'number') {\n      searchForFacetSearchParameters.maxFacetHits = maxFacetHits;\n    }\n    return sortObject(\n      merge(\n        {},\n        requestBuilder._getHitsSearchParams(stateForSearchForFacetValues),\n        searchForFacetSearchParameters\n      )\n    );\n  },\n};\n\nmodule.exports = requestBuilder;\n","'use strict';\n\n// NOTE: this behaves like lodash/defaults, but doesn't mutate the target\n// it also preserve keys order\nmodule.exports = function defaultsPure() {\n  var sources = Array.prototype.slice.call(arguments);\n\n  return sources.reduceRight(function (acc, source) {\n    Object.keys(Object(source)).forEach(function (key) {\n      if (source[key] === undefined) {\n        return;\n      }\n      if (acc[key] !== undefined) {\n        // remove if already added, so that we can add it in correct order\n        delete acc[key];\n      }\n      acc[key] = source[key];\n    });\n    return acc;\n  }, {});\n};\n","'use strict';\n\n// @MAJOR can be replaced by native Array#find when we change support\nmodule.exports = function find(array, comparator) {\n  if (!Array.isArray(array)) {\n    return undefined;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (comparator(array[i])) {\n      return array[i];\n    }\n  }\n\n  return undefined;\n};\n","'use strict';\n\nfunction intersection(arr1, arr2) {\n  return arr1.filter(function (value, index) {\n    return (\n      arr2.indexOf(value) > -1 &&\n      arr1.indexOf(value) === index /* skips duplicates */\n    );\n  });\n}\n\nmodule.exports = intersection;\n","'use strict';\n\nfunction valToNumber(v) {\n  if (typeof v === 'number') {\n    return v;\n  } else if (typeof v === 'string') {\n    return parseFloat(v);\n  } else if (Array.isArray(v)) {\n    return v.map(valToNumber);\n  }\n\n  throw new Error(\n    'The value should be a number, a parsable string or an array of those.'\n  );\n}\n\nmodule.exports = valToNumber;\n","'use strict';\n\n/**\n * Functions to manipulate refinement lists\n *\n * The RefinementList is not formally defined through a prototype but is based\n * on a specific structure.\n *\n * @module SearchParameters.refinementList\n *\n * @typedef {string[]} SearchParameters.refinementList.Refinements\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\n */\n\nvar defaultsPure = require('../functions/defaultsPure');\nvar objectHasKeys = require('../functions/objectHasKeys');\nvar omit = require('../functions/omit');\n\nvar lib = {\n  /**\n   * Adds a refinement to a RefinementList\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\n   * @return {RefinementList} a new and updated refinement list\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n\n    var valueAsString = '' + value;\n\n    var facetRefinement = !refinementList[attribute]\n      ? [valueAsString]\n      : refinementList[attribute].concat(valueAsString);\n\n    var mod = {};\n\n    mod[attribute] = facetRefinement;\n\n    return defaultsPure({}, mod, refinementList);\n  },\n  /**\n   * Removes refinement(s) for an attribute:\n   *  - if the value is specified removes the refinement for the value on the attribute\n   *  - if no value is specified removes all the refinements for this attribute\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} [value] the value of the refinement\n   * @return {RefinementList} a new and updated refinement lst\n   */\n  removeRefinement: function removeRefinement(\n    refinementList,\n    attribute,\n    value\n  ) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function (v, f) {\n        return attribute === f;\n      });\n    }\n\n    var valueAsString = '' + value;\n\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\n   * Toggles the refinement value for an attribute.\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} attribute the attribute to refine\n   * @param {string} value the value of the refinement\n   * @return {RefinementList} a new and updated list\n   */\n  toggleRefinement: function toggleRefinement(\n    refinementList,\n    attribute,\n    value\n  ) {\n    if (value === undefined)\n      throw new Error('toggleRefinement should be used with a value');\n\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\n   * kinds of behavior can happen:\n   *  - if no attribute is provided: clears the whole list\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\n   * @param {RefinementList} refinementList the initial list\n   * @param {string} [attribute] the attribute or function to discard\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\n   * @return {RefinementList} a new and updated refinement list\n   */\n  clearRefinement: function clearRefinement(\n    refinementList,\n    attribute,\n    refinementType\n  ) {\n    if (attribute === undefined) {\n      // return the same object if the list is already empty\n      // this is mainly for tests, as it doesn't have much impact on performance\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n\n      var newRefinementList = Object.keys(refinementList).reduce(function (\n        memo,\n        key\n      ) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function (value) {\n          return !attribute(value, key, refinementType);\n        });\n\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n\n        memo[key] = facetList;\n\n        return memo;\n      },\n      {});\n\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n\n    // We return nothing if the attribute is not undefined, a string or a function,\n    // as it is not a valid value for a refinement\n    return undefined;\n  },\n  /**\n   * Test if the refinement value is used for the attribute. If no refinement value\n   * is provided, test if the refinementList contains any refinement for the\n   * given attribute.\n   * @param {RefinementList} refinementList the list of refinement\n   * @param {string} attribute name of the attribute\n   * @param {string} [refinementValue] value of the filter/refinement\n   * @return {boolean} true if the attribute is refined, false otherwise\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements =\n      Boolean(refinementList[attribute]) &&\n      refinementList[attribute].length > 0;\n\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n\n    var refinementValueAsString = '' + refinementValue;\n\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  },\n};\n\nmodule.exports = lib;\n","'use strict';\n\nvar defaultsPure = require('../functions/defaultsPure');\nvar find = require('../functions/find');\nvar intersection = require('../functions/intersection');\nvar merge = require('../functions/merge');\nvar objectHasKeys = require('../functions/objectHasKeys');\nvar omit = require('../functions/omit');\nvar valToNumber = require('../functions/valToNumber');\nvar isValidUserToken = require('../utils/isValidUserToken');\n\nvar RefinementList = require('./RefinementList');\n\n/**\n * isEqual, but only for numeric refinement values, possible values:\n * - 5\n * - [5]\n * - [[5]]\n * - [[5,5],[4]]\n * @param {any} a numeric refinement value\n * @param {any} b numeric refinement value\n * @return {boolean} true if the values are equal\n */\nfunction isEqualNumericRefinement(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every(function (el, i) {\n        return isEqualNumericRefinement(b[i], el);\n      })\n    );\n  }\n  return a === b;\n}\n\n/**\n * like _.find but using deep equality to be able to use it\n * to find arrays.\n * @private\n * @param {any[]} array array to search into (elements are base or array of base)\n * @param {any} searchedValue the value we're looking for (base or array of base)\n * @return {any} the searched value or undefined\n */\nfunction findArray(array, searchedValue) {\n  return find(array, function (currentValue) {\n    return isEqualNumericRefinement(currentValue, searchedValue);\n  });\n}\n\n/**\n * The facet list is the structure used to store the list of values used to\n * filter a single attribute.\n * @typedef {string[]} SearchParameters.FacetList\n */\n\n/**\n * Structure to store numeric filters with the operator as the key. The supported operators\n * are `=`, `>`, `<`, `>=`, `<=` and `!=`.\n * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList\n */\n\n/**\n * SearchParameters is the data structure that contains all the information\n * usable for making a search to Algolia API. It doesn't do the search itself,\n * nor does it contains logic about the parameters.\n * It is an immutable object, therefore it has been created in a way that each\n * changes does not change the object itself but returns a copy with the\n * modification.\n * This object should probably not be instantiated outside of the helper. It will\n * be provided when needed. This object is documented for reference as you'll\n * get it from events generated by the {@link AlgoliaSearchHelper}.\n * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}\n * @constructor\n * @classdesc contains all the parameters of a search\n * @param {object|SearchParameters} newParameters existing parameters or partial object\n * for the properties of a new SearchParameters\n * @see SearchParameters.make\n * @example <caption>SearchParameters of the first query in\n *   <a href=\"http://demos.algolia.com/instant-search-demo/\">the instant search demo</a></caption>\n{\n   \"query\": \"\",\n   \"disjunctiveFacets\": [\n      \"customerReviewCount\",\n      \"category\",\n      \"salePrice_range\",\n      \"manufacturer\"\n  ],\n   \"maxValuesPerFacet\": 30,\n   \"page\": 0,\n   \"hitsPerPage\": 10,\n   \"facets\": [\n      \"type\",\n      \"shipping\"\n  ]\n}\n */\nfunction SearchParameters(newParameters) {\n  var params = newParameters\n    ? SearchParameters._parseNumbers(newParameters)\n    : {};\n\n  if (params.userToken !== undefined && !isValidUserToken(params.userToken)) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      '[algoliasearch-helper] The `userToken` parameter is invalid. This can lead to wrong analytics.\\n  - Format: [a-zA-Z0-9_-]{1,64}'\n    );\n  }\n  /**\n   * This attribute contains the list of all the conjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n  this.facets = params.facets || [];\n  /**\n   * This attribute contains the list of all the disjunctive facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * @member {string[]}\n   */\n  this.disjunctiveFacets = params.disjunctiveFacets || [];\n  /**\n   * This attribute contains the list of all the hierarchical facets\n   * used. This list will be added to requested facets in the\n   * [facets attribute](https://www.algolia.com/doc/rest-api/search#param-facets) sent to algolia.\n   * Hierarchical facets are a sub type of disjunctive facets that\n   * let you filter faceted attributes hierarchically.\n   * @member {string[]|object[]}\n   */\n  this.hierarchicalFacets = params.hierarchicalFacets || [];\n\n  // Refinements\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.facetsRefinements = params.facetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * excluded from the conjunctive facets. Each facet must be properly\n   * defined in the `facets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters excluded for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.facetsExcludes = params.facetsExcludes || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the disjunctive facets. Each facet must be properly\n   * defined in the `disjunctiveFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.disjunctiveFacetsRefinements = params.disjunctiveFacetsRefinements || {};\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the numeric attributes.\n   *\n   * The key is the name of the attribute, and the value is the\n   * filters to apply to this attribute.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `numericFilters` attribute.\n   * @member {Object.<string, SearchParameters.OperatorList>}\n   */\n  this.numericRefinements = params.numericRefinements || {};\n  /**\n   * This attribute contains all the tags used to refine the query.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `tagFilters` attribute.\n   * @member {string[]}\n   */\n  this.tagRefinements = params.tagRefinements || [];\n  /**\n   * This attribute contains all the filters that need to be\n   * applied on the hierarchical facets. Each facet must be properly\n   * defined in the `hierarchicalFacets` attribute.\n   *\n   * The key is the name of the facet, and the `FacetList` contains all\n   * filters selected for the associated facet name. The FacetList values\n   * are structured as a string that contain the values for each level\n   * separated by the configured separator.\n   *\n   * When querying algolia, the values stored in this attribute will\n   * be translated into the `facetFilters` attribute.\n   * @member {Object.<string, SearchParameters.FacetList>}\n   */\n  this.hierarchicalFacetsRefinements =\n    params.hierarchicalFacetsRefinements || {};\n\n  // eslint-disable-next-line consistent-this\n  var self = this;\n  Object.keys(params).forEach(function (paramName) {\n    var isKeyKnown = SearchParameters.PARAMETERS.indexOf(paramName) !== -1;\n    var isValueDefined = params[paramName] !== undefined;\n\n    if (!isKeyKnown && isValueDefined) {\n      self[paramName] = params[paramName];\n    }\n  });\n}\n\n/**\n * List all the properties in SearchParameters and therefore all the known Algolia properties\n * This doesn't contain any beta/hidden features.\n * @private\n */\nSearchParameters.PARAMETERS = Object.keys(new SearchParameters());\n\n/**\n * @private\n * @param {object} partialState full or part of a state\n * @return {object} a new object with the number keys as number\n */\nSearchParameters._parseNumbers = function (partialState) {\n  // Do not parse numbers again in SearchParameters, they ought to be parsed already\n  if (partialState instanceof SearchParameters) return partialState;\n\n  var numbers = {};\n\n  var numberKeys = [\n    'aroundPrecision',\n    'aroundRadius',\n    'getRankingInfo',\n    'minWordSizefor2Typos',\n    'minWordSizefor1Typo',\n    'page',\n    'maxValuesPerFacet',\n    'distinct',\n    'minimumAroundRadius',\n    'hitsPerPage',\n    'minProximity',\n  ];\n\n  numberKeys.forEach(function (k) {\n    var value = partialState[k];\n    if (typeof value === 'string') {\n      var parsedValue = parseFloat(value);\n      // global isNaN is ok to use here, value is only number or NaN\n      numbers[k] = isNaN(parsedValue) ? value : parsedValue;\n    }\n  });\n\n  // there's two formats of insideBoundingBox, we need to parse\n  // the one which is an array of float geo rectangles\n  if (Array.isArray(partialState.insideBoundingBox)) {\n    numbers.insideBoundingBox = partialState.insideBoundingBox.map(function (\n      geoRect\n    ) {\n      if (Array.isArray(geoRect)) {\n        return geoRect.map(function (value) {\n          return parseFloat(value);\n        });\n      }\n      return geoRect;\n    });\n  }\n\n  if (partialState.numericRefinements) {\n    var numericRefinements = {};\n    Object.keys(partialState.numericRefinements).forEach(function (attribute) {\n      var operators = partialState.numericRefinements[attribute] || {};\n      numericRefinements[attribute] = {};\n      Object.keys(operators).forEach(function (operator) {\n        var values = operators[operator];\n        var parsedValues = values.map(function (v) {\n          if (Array.isArray(v)) {\n            return v.map(function (vPrime) {\n              if (typeof vPrime === 'string') {\n                return parseFloat(vPrime);\n              }\n              return vPrime;\n            });\n          } else if (typeof v === 'string') {\n            return parseFloat(v);\n          }\n          return v;\n        });\n        numericRefinements[attribute][operator] = parsedValues;\n      });\n    });\n    numbers.numericRefinements = numericRefinements;\n  }\n\n  return merge({}, partialState, numbers);\n};\n\n/**\n * Factory for SearchParameters\n * @param {object|SearchParameters} newParameters existing parameters or partial\n * object for the properties of a new SearchParameters\n * @return {SearchParameters} frozen instance of SearchParameters\n */\nSearchParameters.make = function makeSearchParameters(newParameters) {\n  var instance = new SearchParameters(newParameters);\n\n  var hierarchicalFacets = newParameters.hierarchicalFacets || [];\n  hierarchicalFacets.forEach(function (facet) {\n    if (facet.rootPath) {\n      var currentRefinement = instance.getHierarchicalRefinement(facet.name);\n\n      if (\n        currentRefinement.length > 0 &&\n        currentRefinement[0].indexOf(facet.rootPath) !== 0\n      ) {\n        instance = instance.clearRefinements(facet.name);\n      }\n\n      // get it again in case it has been cleared\n      currentRefinement = instance.getHierarchicalRefinement(facet.name);\n      if (currentRefinement.length === 0) {\n        instance = instance.toggleHierarchicalFacetRefinement(\n          facet.name,\n          facet.rootPath\n        );\n      }\n    }\n  });\n\n  return instance;\n};\n\n/**\n * Validates the new parameters based on the previous state\n * @param {SearchParameters} currentState the current state\n * @param {object|SearchParameters} parameters the new parameters to set\n * @return {Error|null} Error if the modification is invalid, null otherwise\n */\nSearchParameters.validate = function (currentState, parameters) {\n  var params = parameters || {};\n\n  if (\n    currentState.tagFilters &&\n    params.tagRefinements &&\n    params.tagRefinements.length > 0\n  ) {\n    return new Error(\n      '[Tags] Cannot switch from the managed tag API to the advanced API. It is probably ' +\n        'an error, if it is really what you want, you should first clear the tags with clearTags method.'\n    );\n  }\n\n  if (currentState.tagRefinements.length > 0 && params.tagFilters) {\n    return new Error(\n      '[Tags] Cannot switch from the advanced tag API to the managed API. It is probably ' +\n        'an error, if it is not, you should first clear the tags with clearTags method.'\n    );\n  }\n\n  if (\n    currentState.numericFilters &&\n    params.numericRefinements &&\n    objectHasKeys(params.numericRefinements)\n  ) {\n    return new Error(\n      \"[Numeric filters] Can't switch from the advanced to the managed API. It\" +\n        ' is probably an error, if this is really what you want, you have to first' +\n        ' clear the numeric filters.'\n    );\n  }\n\n  if (objectHasKeys(currentState.numericRefinements) && params.numericFilters) {\n    return new Error(\n      \"[Numeric filters] Can't switch from the managed API to the advanced. It\" +\n        ' is probably an error, if this is really what you want, you have to first' +\n        ' clear the numeric filters.'\n    );\n  }\n\n  return null;\n};\n\nSearchParameters.prototype = {\n  constructor: SearchParameters,\n\n  /**\n   * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)\n   * @method\n   * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {SearchParameters} new instance with filters cleared\n   */\n  clearRefinements: function clearRefinements(attribute) {\n    var patch = {\n      numericRefinements: this._clearNumericRefinements(attribute),\n      facetsRefinements: RefinementList.clearRefinement(\n        this.facetsRefinements,\n        attribute,\n        'conjunctiveFacet'\n      ),\n      facetsExcludes: RefinementList.clearRefinement(\n        this.facetsExcludes,\n        attribute,\n        'exclude'\n      ),\n      disjunctiveFacetsRefinements: RefinementList.clearRefinement(\n        this.disjunctiveFacetsRefinements,\n        attribute,\n        'disjunctiveFacet'\n      ),\n      hierarchicalFacetsRefinements: RefinementList.clearRefinement(\n        this.hierarchicalFacetsRefinements,\n        attribute,\n        'hierarchicalFacet'\n      ),\n    };\n    if (\n      patch.numericRefinements === this.numericRefinements &&\n      patch.facetsRefinements === this.facetsRefinements &&\n      patch.facetsExcludes === this.facetsExcludes &&\n      patch.disjunctiveFacetsRefinements ===\n        this.disjunctiveFacetsRefinements &&\n      patch.hierarchicalFacetsRefinements === this.hierarchicalFacetsRefinements\n    ) {\n      return this;\n    }\n    return this.setQueryParameters(patch);\n  },\n  /**\n   * Remove all the refined tags from the SearchParameters\n   * @method\n   * @return {SearchParameters} new instance with tags cleared\n   */\n  clearTags: function clearTags() {\n    if (this.tagFilters === undefined && this.tagRefinements.length === 0)\n      return this;\n\n    return this.setQueryParameters({\n      tagFilters: undefined,\n      tagRefinements: [],\n    });\n  },\n  /**\n   * Set the index.\n   * @method\n   * @param {string} index the index name\n   * @return {SearchParameters} new instance\n   */\n  setIndex: function setIndex(index) {\n    if (index === this.index) return this;\n\n    return this.setQueryParameters({\n      index: index,\n    });\n  },\n  /**\n   * Query setter\n   * @method\n   * @param {string} newQuery value for the new query\n   * @return {SearchParameters} new instance\n   */\n  setQuery: function setQuery(newQuery) {\n    if (newQuery === this.query) return this;\n\n    return this.setQueryParameters({\n      query: newQuery,\n    });\n  },\n  /**\n   * Page setter\n   * @method\n   * @param {number} newPage new page number\n   * @return {SearchParameters} new instance\n   */\n  setPage: function setPage(newPage) {\n    if (newPage === this.page) return this;\n\n    return this.setQueryParameters({\n      page: newPage,\n    });\n  },\n  /**\n   * Facets setter\n   * The facets are the simple facets, used for conjunctive (and) faceting.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting\n   * @return {SearchParameters} new instance\n   */\n  setFacets: function setFacets(facets) {\n    return this.setQueryParameters({\n      facets: facets,\n    });\n  },\n  /**\n   * Disjunctive facets setter\n   * Change the list of disjunctive (or) facets the helper chan handle.\n   * @method\n   * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting\n   * @return {SearchParameters} new instance\n   */\n  setDisjunctiveFacets: function setDisjunctiveFacets(facets) {\n    return this.setQueryParameters({\n      disjunctiveFacets: facets,\n    });\n  },\n  /**\n   * HitsPerPage setter\n   * Hits per page represents the number of hits retrieved for this query\n   * @method\n   * @param {number} n number of hits retrieved per page of results\n   * @return {SearchParameters} new instance\n   */\n  setHitsPerPage: function setHitsPerPage(n) {\n    if (this.hitsPerPage === n) return this;\n\n    return this.setQueryParameters({\n      hitsPerPage: n,\n    });\n  },\n  /**\n   * typoTolerance setter\n   * Set the value of typoTolerance\n   * @method\n   * @param {string} typoTolerance new value of typoTolerance (\"true\", \"false\", \"min\" or \"strict\")\n   * @return {SearchParameters} new instance\n   */\n  setTypoTolerance: function setTypoTolerance(typoTolerance) {\n    if (this.typoTolerance === typoTolerance) return this;\n\n    return this.setQueryParameters({\n      typoTolerance: typoTolerance,\n    });\n  },\n  /**\n   * Add a numeric filter for a given attribute\n   * When value is an array, they are combined with OR\n   * When value is a single value, it will combined with AND\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number | number[]} value value of the filter\n   * @return {SearchParameters} new instance\n   * @example\n   * // for price = 50 or 40\n   * state.addNumericRefinement('price', '=', [50, 40]);\n   * @example\n   * // for size = 38 and 40\n   * state.addNumericRefinement('size', '=', 38);\n   * state.addNumericRefinement('size', '=', 40);\n   */\n  addNumericRefinement: function (attribute, operator, value) {\n    var val = valToNumber(value);\n\n    if (this.isNumericRefined(attribute, operator, val)) return this;\n\n    var mod = merge({}, this.numericRefinements);\n\n    mod[attribute] = merge({}, mod[attribute]);\n\n    if (mod[attribute][operator]) {\n      // Array copy\n      mod[attribute][operator] = mod[attribute][operator].slice();\n      // Add the element. Concat can't be used here because value can be an array.\n      mod[attribute][operator].push(val);\n    } else {\n      mod[attribute][operator] = [val];\n    }\n\n    return this.setQueryParameters({\n      numericRefinements: mod,\n    });\n  },\n  /**\n   * Get the list of conjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getConjunctiveRefinements: function (facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      return [];\n    }\n    return this.facetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of disjunctive refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getDisjunctiveRefinements: function (facetName) {\n    if (!this.isDisjunctiveFacet(facetName)) {\n      return [];\n    }\n    return this.disjunctiveFacetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of hierarchical refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getHierarchicalRefinement: function (facetName) {\n    // we send an array but we currently do not support multiple\n    // hierarchicalRefinements for a hierarchicalFacet\n    return this.hierarchicalFacetsRefinements[facetName] || [];\n  },\n  /**\n   * Get the list of exclude refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {string[]} list of refinements\n   */\n  getExcludeRefinements: function (facetName) {\n    if (!this.isConjunctiveFacet(facetName)) {\n      return [];\n    }\n    return this.facetsExcludes[facetName] || [];\n  },\n\n  /**\n   * Remove all the numeric filter for a given (attribute, operator)\n   * @method\n   * @param {string} attribute attribute to set the filter on\n   * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)\n   * @param {number} [number] the value to be removed\n   * @return {SearchParameters} new instance\n   */\n  removeNumericRefinement: function (attribute, operator, number) {\n    var paramValue = number;\n    if (paramValue !== undefined) {\n      if (!this.isNumericRefined(attribute, operator, paramValue)) {\n        return this;\n      }\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function (\n          value,\n          key\n        ) {\n          return (\n            key === attribute &&\n            value.op === operator &&\n            isEqualNumericRefinement(value.val, valToNumber(paramValue))\n          );\n        }),\n      });\n    } else if (operator !== undefined) {\n      if (!this.isNumericRefined(attribute, operator)) return this;\n      return this.setQueryParameters({\n        numericRefinements: this._clearNumericRefinements(function (\n          value,\n          key\n        ) {\n          return key === attribute && value.op === operator;\n        }),\n      });\n    }\n\n    if (!this.isNumericRefined(attribute)) return this;\n    return this.setQueryParameters({\n      numericRefinements: this._clearNumericRefinements(function (value, key) {\n        return key === attribute;\n      }),\n    });\n  },\n  /**\n   * Get the list of numeric refinements for a single facet\n   * @param {string} facetName name of the attribute used for faceting\n   * @return {SearchParameters.OperatorList} list of refinements\n   */\n  getNumericRefinements: function (facetName) {\n    return this.numericRefinements[facetName] || {};\n  },\n  /**\n   * Return the current refinement for the (attribute, operator)\n   * @param {string} attribute attribute in the record\n   * @param {string} operator operator applied on the refined values\n   * @return {Array.<number|number[]>} refined values\n   */\n  getNumericRefinement: function (attribute, operator) {\n    return (\n      this.numericRefinements[attribute] &&\n      this.numericRefinements[attribute][operator]\n    );\n  },\n  /**\n   * Clear numeric filters.\n   * @method\n   * @private\n   * @param {string|SearchParameters.clearCallback} [attribute] optional string or function\n   * - If not given, means to clear all the filters.\n   * - If `string`, means to clear all refinements for the `attribute` named filter.\n   * - If `function`, means to clear all the refinements that return truthy values.\n   * @return {Object.<string, OperatorList>} new numeric refinements\n   */\n  _clearNumericRefinements: function _clearNumericRefinements(attribute) {\n    if (attribute === undefined) {\n      if (!objectHasKeys(this.numericRefinements)) {\n        return this.numericRefinements;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(this.numericRefinements, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n      var numericRefinements = this.numericRefinements;\n      var newNumericRefinements = Object.keys(numericRefinements).reduce(\n        function (memo, key) {\n          var operators = numericRefinements[key];\n          var operatorList = {};\n\n          operators = operators || {};\n          Object.keys(operators).forEach(function (operator) {\n            var values = operators[operator] || [];\n            var outValues = [];\n            values.forEach(function (value) {\n              var predicateResult = attribute(\n                { val: value, op: operator },\n                key,\n                'numeric'\n              );\n              if (!predicateResult) outValues.push(value);\n            });\n            if (outValues.length !== values.length) {\n              hasChanged = true;\n            }\n            operatorList[operator] = outValues;\n          });\n\n          memo[key] = operatorList;\n\n          return memo;\n        },\n        {}\n      );\n\n      if (hasChanged) return newNumericRefinements;\n      return this.numericRefinements;\n    }\n\n    // We return nothing if the attribute is not undefined, a string or a function,\n    // as it is not a valid value for a refinement\n    return undefined;\n  },\n  /**\n   * Add a facet to the facets attribute of the helper configuration, if it\n   * isn't already present.\n   * @method\n   * @param {string} facet facet name to add\n   * @return {SearchParameters} new instance\n   */\n  addFacet: function addFacet(facet) {\n    if (this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      facets: this.facets.concat([facet]),\n    });\n  },\n  /**\n   * Add a disjunctive facet to the disjunctiveFacets attribute of the helper\n   * configuration, if it isn't already present.\n   * @method\n   * @param {string} facet disjunctive facet name to add\n   * @return {SearchParameters} new instance\n   */\n  addDisjunctiveFacet: function addDisjunctiveFacet(facet) {\n    if (this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacets: this.disjunctiveFacets.concat([facet]),\n    });\n  },\n  /**\n   * Add a hierarchical facet to the hierarchicalFacets attribute of the helper\n   * configuration.\n   * @method\n   * @param {object} hierarchicalFacet hierarchical facet to add\n   * @return {SearchParameters} new instance\n   * @throws will throw an error if a hierarchical facet with the same name was already declared\n   */\n  addHierarchicalFacet: function addHierarchicalFacet(hierarchicalFacet) {\n    if (this.isHierarchicalFacet(hierarchicalFacet.name)) {\n      throw new Error(\n        'Cannot declare two hierarchical facets with the same name: `' +\n          hierarchicalFacet.name +\n          '`'\n      );\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.concat([hierarchicalFacet]),\n    });\n  },\n  /**\n   * Add a refinement on a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters} new instance\n   */\n  addFacetRefinement: function addFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n    if (RefinementList.isRefined(this.facetsRefinements, facet, value))\n      return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.addRefinement(\n        this.facetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Exclude a value from a \"normal\" facet\n   * @method\n   * @param {string} facet attribute to apply the exclusion on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters} new instance\n   */\n  addExcludeRefinement: function addExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n    if (RefinementList.isRefined(this.facetsExcludes, facet, value))\n      return this;\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.addRefinement(\n        this.facetsExcludes,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Adds a refinement on a disjunctive facet.\n   * @method\n   * @param {string} facet attribute to apply the faceting on\n   * @param {string} value value of the attribute (will be converted to string)\n   * @return {SearchParameters} new instance\n   */\n  addDisjunctiveFacetRefinement: function addDisjunctiveFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the disjunctiveFacets attribute of the helper configuration'\n      );\n    }\n\n    if (\n      RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)\n    )\n      return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.addRefinement(\n        this.disjunctiveFacetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * addTagRefinement adds a tag to the list used to filter the results\n   * @param {string} tag tag to be added\n   * @return {SearchParameters} new instance\n   */\n  addTagRefinement: function addTagRefinement(tag) {\n    if (this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: this.tagRefinements.concat(tag),\n    };\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Remove a facet from the facets attribute of the helper configuration, if it\n   * is present.\n   * @method\n   * @param {string} facet facet name to remove\n   * @return {SearchParameters} new instance\n   */\n  removeFacet: function removeFacet(facet) {\n    if (!this.isConjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      facets: this.facets.filter(function (f) {\n        return f !== facet;\n      }),\n    });\n  },\n  /**\n   * Remove a disjunctive facet from the disjunctiveFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet disjunctive facet name to remove\n   * @return {SearchParameters} new instance\n   */\n  removeDisjunctiveFacet: function removeDisjunctiveFacet(facet) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      disjunctiveFacets: this.disjunctiveFacets.filter(function (f) {\n        return f !== facet;\n      }),\n    });\n  },\n  /**\n   * Remove a hierarchical facet from the hierarchicalFacets attribute of the\n   * helper configuration, if it is present.\n   * @method\n   * @param {string} facet hierarchical facet name to remove\n   * @return {SearchParameters} new instance\n   */\n  removeHierarchicalFacet: function removeHierarchicalFacet(facet) {\n    if (!this.isHierarchicalFacet(facet)) {\n      return this;\n    }\n\n    return this.clearRefinements(facet).setQueryParameters({\n      hierarchicalFacets: this.hierarchicalFacets.filter(function (f) {\n        return f.name !== facet;\n      }),\n    });\n  },\n  /**\n   * Remove a refinement set on facet. If a value is provided, it will clear the\n   * refinement for the given value, otherwise it will clear all the refinement\n   * values for the faceted attribute.\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} [value] value used to filter\n   * @return {SearchParameters} new instance\n   */\n  removeFacetRefinement: function removeFacetRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n    if (!RefinementList.isRefined(this.facetsRefinements, facet, value))\n      return this;\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.removeRefinement(\n        this.facetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Remove a negative refinement on a facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters} new instance\n   */\n  removeExcludeRefinement: function removeExcludeRefinement(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n    if (!RefinementList.isRefined(this.facetsExcludes, facet, value))\n      return this;\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.removeRefinement(\n        this.facetsExcludes,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Remove a refinement on a disjunctive facet\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {string} value value used to filter\n   * @return {SearchParameters} new instance\n   */\n  removeDisjunctiveFacetRefinement: function removeDisjunctiveFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the disjunctiveFacets attribute of the helper configuration'\n      );\n    }\n    if (\n      !RefinementList.isRefined(this.disjunctiveFacetsRefinements, facet, value)\n    )\n      return this;\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.removeRefinement(\n        this.disjunctiveFacetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Remove a tag from the list of tag refinements\n   * @method\n   * @param {string} tag the tag to remove\n   * @return {SearchParameters} new instance\n   */\n  removeTagRefinement: function removeTagRefinement(tag) {\n    if (!this.isTagRefined(tag)) return this;\n\n    var modification = {\n      tagRefinements: this.tagRefinements.filter(function (t) {\n        return t !== tag;\n      }),\n    };\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters} new instance\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}\n   */\n  toggleRefinement: function toggleRefinement(facet, value) {\n    return this.toggleFacetRefinement(facet, value);\n  },\n  /**\n   * Generic toggle refinement method to use with facet, disjunctive facets\n   * and hierarchical facets\n   * @param  {string} facet the facet to refine\n   * @param  {string} value the associated value\n   * @return {SearchParameters} new instance\n   * @throws will throw an error if the facet is not declared in the settings of the helper\n   */\n  toggleFacetRefinement: function toggleFacetRefinement(facet, value) {\n    if (this.isHierarchicalFacet(facet)) {\n      return this.toggleHierarchicalFacetRefinement(facet, value);\n    } else if (this.isConjunctiveFacet(facet)) {\n      return this.toggleConjunctiveFacetRefinement(facet, value);\n    } else if (this.isDisjunctiveFacet(facet)) {\n      return this.toggleDisjunctiveFacetRefinement(facet, value);\n    }\n\n    throw new Error(\n      'Cannot refine the undeclared facet ' +\n        facet +\n        '; it should be added to the helper options facets, disjunctiveFacets or hierarchicalFacets'\n    );\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters} new instance\n   */\n  toggleConjunctiveFacetRefinement: function toggleConjunctiveFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n\n    return this.setQueryParameters({\n      facetsRefinements: RefinementList.toggleRefinement(\n        this.facetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters} new instance\n   */\n  toggleExcludeFacetRefinement: function toggleExcludeFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isConjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the facets attribute of the helper configuration'\n      );\n    }\n\n    return this.setQueryParameters({\n      facetsExcludes: RefinementList.toggleRefinement(\n        this.facetsExcludes,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters} new instance\n   */\n  toggleDisjunctiveFacetRefinement: function toggleDisjunctiveFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the disjunctiveFacets attribute of the helper configuration'\n      );\n    }\n\n    return this.setQueryParameters({\n      disjunctiveFacetsRefinements: RefinementList.toggleRefinement(\n        this.disjunctiveFacetsRefinements,\n        facet,\n        value\n      ),\n    });\n  },\n  /**\n   * Switch the refinement applied over a facet/value\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {SearchParameters} new instance\n   */\n  toggleHierarchicalFacetRefinement: function toggleHierarchicalFacetRefinement(\n    facet,\n    value\n  ) {\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the hierarchicalFacets attribute of the helper configuration'\n      );\n    }\n\n    var separator = this._getHierarchicalFacetSeparator(\n      this.getHierarchicalFacetByName(facet)\n    );\n\n    var mod = {};\n\n    var upOneOrMultipleLevel =\n      this.hierarchicalFacetsRefinements[facet] !== undefined &&\n      this.hierarchicalFacetsRefinements[facet].length > 0 &&\n      // remove current refinement:\n      // refinement was 'beer > IPA', call is toggleRefine('beer > IPA'), refinement should be `beer`\n      (this.hierarchicalFacetsRefinements[facet][0] === value ||\n        // remove a parent refinement of the current refinement:\n        //  - refinement was 'beer > IPA > Flying dog'\n        //  - call is toggleRefine('beer > IPA')\n        //  - refinement should be `beer`\n        this.hierarchicalFacetsRefinements[facet][0].indexOf(\n          value + separator\n        ) === 0);\n\n    if (upOneOrMultipleLevel) {\n      if (value.indexOf(separator) === -1) {\n        // go back to root level\n        mod[facet] = [];\n      } else {\n        mod[facet] = [value.slice(0, value.lastIndexOf(separator))];\n      }\n    } else {\n      mod[facet] = [value];\n    }\n\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaultsPure(\n        {},\n        mod,\n        this.hierarchicalFacetsRefinements\n      ),\n    });\n  },\n\n  /**\n   * Adds a refinement on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @param {string} path the hierarchical facet path\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is refined\n   */\n  addHierarchicalFacetRefinement: function (facet, path) {\n    if (this.isHierarchicalFacetRefined(facet)) {\n      throw new Error(facet + ' is already refined.');\n    }\n    if (!this.isHierarchicalFacet(facet)) {\n      throw new Error(\n        facet +\n          ' is not defined in the hierarchicalFacets attribute of the helper configuration.'\n      );\n    }\n    var mod = {};\n    mod[facet] = [path];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaultsPure(\n        {},\n        mod,\n        this.hierarchicalFacetsRefinements\n      ),\n    });\n  },\n\n  /**\n   * Removes the refinement set on a hierarchical facet.\n   * @param {string} facet the facet name\n   * @return {SearchParameter} the new state\n   * @throws Error if the facet is not defined or if the facet is not refined\n   */\n  removeHierarchicalFacetRefinement: function (facet) {\n    if (!this.isHierarchicalFacetRefined(facet)) {\n      return this;\n    }\n    var mod = {};\n    mod[facet] = [];\n    return this.setQueryParameters({\n      hierarchicalFacetsRefinements: defaultsPure(\n        {},\n        mod,\n        this.hierarchicalFacetsRefinements\n      ),\n    });\n  },\n  /**\n   * Switch the tag refinement\n   * @method\n   * @param {string} tag the tag to remove or add\n   * @return {SearchParameters} new instance\n   */\n  toggleTagRefinement: function toggleTagRefinement(tag) {\n    if (this.isTagRefined(tag)) {\n      return this.removeTagRefinement(tag);\n    }\n\n    return this.addTagRefinement(tag);\n  },\n  /**\n   * Test if the facet name is from one of the disjunctive facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean} true if facet is a disjunctive facet\n   */\n  isDisjunctiveFacet: function (facet) {\n    return this.disjunctiveFacets.indexOf(facet) > -1;\n  },\n  /**\n   * Test if the facet name is from one of the hierarchical facets\n   * @method\n   * @param {string} facetName facet name to test\n   * @return {boolean} true if facetName is a hierarchical facet\n   */\n  isHierarchicalFacet: function (facetName) {\n    return this.getHierarchicalFacetByName(facetName) !== undefined;\n  },\n  /**\n   * Test if the facet name is from one of the conjunctive/normal facets\n   * @method\n   * @param {string} facet facet name to test\n   * @return {boolean} true if facet is a conjunctive facet\n   */\n  isConjunctiveFacet: function (facet) {\n    return this.facets.indexOf(facet) > -1;\n  },\n  /**\n   * Returns true if the facet is refined, either for a specific value or in\n   * general.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value, optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isFacetRefined: function isFacetRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      return false;\n    }\n    return RefinementList.isRefined(this.facetsRefinements, facet, value);\n  },\n  /**\n   * Returns true if the facet contains exclusions or if a specific value is\n   * excluded.\n   *\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} [value] optional value. If passed will test that this value\n   * is filtering the given facet.\n   * @return {boolean} returns true if refined\n   */\n  isExcludeRefined: function isExcludeRefined(facet, value) {\n    if (!this.isConjunctiveFacet(facet)) {\n      return false;\n    }\n    return RefinementList.isRefined(this.facetsExcludes, facet, value);\n  },\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean} true if the facet is refined\n   */\n  isDisjunctiveFacetRefined: function isDisjunctiveFacetRefined(facet, value) {\n    if (!this.isDisjunctiveFacet(facet)) {\n      return false;\n    }\n    return RefinementList.isRefined(\n      this.disjunctiveFacetsRefinements,\n      facet,\n      value\n    );\n  },\n  /**\n   * Returns true if the facet contains a refinement, or if a value passed is a\n   * refinement for the facet.\n   * @method\n   * @param {string} facet name of the attribute for used for faceting\n   * @param {string} value optional, will test if the value is used for refinement\n   * if there is one, otherwise will test if the facet contains any refinement\n   * @return {boolean} true if the facet is refined\n   */\n  isHierarchicalFacetRefined: function isHierarchicalFacetRefined(\n    facet,\n    value\n  ) {\n    if (!this.isHierarchicalFacet(facet)) {\n      return false;\n    }\n\n    var refinements = this.getHierarchicalRefinement(facet);\n\n    if (!value) {\n      return refinements.length > 0;\n    }\n\n    return refinements.indexOf(value) !== -1;\n  },\n  /**\n   * Test if the triple (attribute, operator, value) is already refined.\n   * If only the attribute and the operator are provided, it tests if the\n   * contains any refinement value.\n   * @method\n   * @param {string} attribute attribute for which the refinement is applied\n   * @param {string} [operator] operator of the refinement\n   * @param {string} [value] value of the refinement\n   * @return {boolean} true if it is refined\n   */\n  isNumericRefined: function isNumericRefined(attribute, operator, value) {\n    if (value === undefined && operator === undefined) {\n      return Boolean(this.numericRefinements[attribute]);\n    }\n\n    var isOperatorDefined =\n      this.numericRefinements[attribute] &&\n      this.numericRefinements[attribute][operator] !== undefined;\n\n    if (value === undefined || !isOperatorDefined) {\n      return isOperatorDefined;\n    }\n\n    var parsedValue = valToNumber(value);\n    var isAttributeValueDefined =\n      findArray(this.numericRefinements[attribute][operator], parsedValue) !==\n      undefined;\n\n    return isOperatorDefined && isAttributeValueDefined;\n  },\n  /**\n   * Returns true if the tag refined, false otherwise\n   * @method\n   * @param {string} tag the tag to check\n   * @return {boolean} true if tag is refined\n   */\n  isTagRefined: function isTagRefined(tag) {\n    return this.tagRefinements.indexOf(tag) !== -1;\n  },\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]} returns the list of refinements\n   */\n  getRefinedDisjunctiveFacets: function getRefinedDisjunctiveFacets() {\n    // eslint-disable-next-line consistent-this\n    var self = this;\n\n    // attributes used for numeric filter can also be disjunctive\n    var disjunctiveNumericRefinedFacets = intersection(\n      Object.keys(this.numericRefinements).filter(function (facet) {\n        return Object.keys(self.numericRefinements[facet]).length > 0;\n      }),\n      this.disjunctiveFacets\n    );\n\n    return Object.keys(this.disjunctiveFacetsRefinements)\n      .filter(function (facet) {\n        return self.disjunctiveFacetsRefinements[facet].length > 0;\n      })\n      .concat(disjunctiveNumericRefinedFacets)\n      .concat(this.getRefinedHierarchicalFacets())\n      .sort();\n  },\n  /**\n   * Returns the list of all disjunctive facets refined\n   * @method\n   * @param {string} facet name of the attribute used for faceting\n   * @param {value} value value used for filtering\n   * @return {string[]} returns the list of refinements\n   */\n  getRefinedHierarchicalFacets: function getRefinedHierarchicalFacets() {\n    // eslint-disable-next-line consistent-this\n    var self = this;\n    return intersection(\n      // enforce the order between the two arrays,\n      // so that refinement name index === hierarchical facet index\n      this.hierarchicalFacets.map(function (facet) {\n        return facet.name;\n      }),\n      Object.keys(this.hierarchicalFacetsRefinements).filter(function (facet) {\n        return self.hierarchicalFacetsRefinements[facet].length > 0;\n      })\n    ).sort();\n  },\n  /**\n   * Returned the list of all disjunctive facets not refined\n   * @method\n   * @return {string[]} returns the list of facets that are not refined\n   */\n  getUnrefinedDisjunctiveFacets: function () {\n    var refinedFacets = this.getRefinedDisjunctiveFacets();\n\n    return this.disjunctiveFacets.filter(function (f) {\n      return refinedFacets.indexOf(f) === -1;\n    });\n  },\n\n  managedParameters: [\n    'index',\n\n    'facets',\n    'disjunctiveFacets',\n    'facetsRefinements',\n    'hierarchicalFacets',\n    'facetsExcludes',\n\n    'disjunctiveFacetsRefinements',\n    'numericRefinements',\n    'tagRefinements',\n    'hierarchicalFacetsRefinements',\n  ],\n\n  getQueryParams: function getQueryParams() {\n    var managedParameters = this.managedParameters;\n\n    var queryParams = {};\n\n    // eslint-disable-next-line consistent-this\n    var self = this;\n    Object.keys(this).forEach(function (paramName) {\n      var paramValue = self[paramName];\n      if (\n        managedParameters.indexOf(paramName) === -1 &&\n        paramValue !== undefined\n      ) {\n        queryParams[paramName] = paramValue;\n      }\n    });\n\n    return queryParams;\n  },\n  /**\n   * Let the user set a specific value for a given parameter. Will return the\n   * same instance if the parameter is invalid or if the value is the same as the\n   * previous one.\n   * @method\n   * @param {string} parameter the parameter name\n   * @param {any} value the value to be set, must be compliant with the definition\n   * of the attribute on the object\n   * @return {SearchParameters} the updated state\n   */\n  setQueryParameter: function setParameter(parameter, value) {\n    if (this[parameter] === value) return this;\n\n    var modification = {};\n\n    modification[parameter] = value;\n\n    return this.setQueryParameters(modification);\n  },\n  /**\n   * Let the user set any of the parameters with a plain object.\n   * @method\n   * @param {object} params all the keys and the values to be updated\n   * @return {SearchParameters} a new updated instance\n   */\n  setQueryParameters: function setQueryParameters(params) {\n    if (!params) return this;\n\n    var error = SearchParameters.validate(this, params);\n\n    if (error) {\n      throw error;\n    }\n\n    // eslint-disable-next-line consistent-this\n    var self = this;\n    var nextWithNumbers = SearchParameters._parseNumbers(params);\n    var previousPlainObject = Object.keys(this).reduce(function (acc, key) {\n      acc[key] = self[key];\n      return acc;\n    }, {});\n\n    var nextPlainObject = Object.keys(nextWithNumbers).reduce(function (\n      previous,\n      key\n    ) {\n      var isPreviousValueDefined = previous[key] !== undefined;\n      var isNextValueDefined = nextWithNumbers[key] !== undefined;\n\n      if (isPreviousValueDefined && !isNextValueDefined) {\n        return omit(previous, [key]);\n      }\n\n      if (isNextValueDefined) {\n        previous[key] = nextWithNumbers[key];\n      }\n\n      return previous;\n    },\n    previousPlainObject);\n\n    return new this.constructor(nextPlainObject);\n  },\n\n  /**\n   * Returns a new instance with the page reset. Two scenarios possible:\n   * the page is omitted -> return the given instance\n   * the page is set -> return a new instance with a page of 0\n   * @return {SearchParameters} a new updated instance\n   */\n  resetPage: function () {\n    if (this.page === undefined) {\n      return this;\n    }\n\n    return this.setPage(0);\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @param  {object} hierarchicalFacet the hierarchicalFacet object\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSortBy: function (hierarchicalFacet) {\n    return hierarchicalFacet.sortBy || ['isRefined:desc', 'name:asc'];\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet separator or the default one (`>`)\n   * @private\n   * @param  {object} hierarchicalFacet the hierarchicalFacet object\n   * @return {string} returns the hierarchicalFacet.separator or `>` as default\n   */\n  _getHierarchicalFacetSeparator: function (hierarchicalFacet) {\n    return hierarchicalFacet.separator || ' > ';\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet prefix path or null\n   * @private\n   * @param  {object} hierarchicalFacet the hierarchicalFacet object\n   * @return {string} returns the hierarchicalFacet.rootPath or null as default\n   */\n  _getHierarchicalRootPath: function (hierarchicalFacet) {\n    return hierarchicalFacet.rootPath || null;\n  },\n\n  /**\n   * Helper function to check if we show the parent level of the hierarchicalFacet\n   * @private\n   * @param  {object} hierarchicalFacet the hierarchicalFacet object\n   * @return {string} returns the hierarchicalFacet.showParentLevel or true as default\n   */\n  _getHierarchicalShowParentLevel: function (hierarchicalFacet) {\n    if (typeof hierarchicalFacet.showParentLevel === 'boolean') {\n      return hierarchicalFacet.showParentLevel;\n    }\n    return true;\n  },\n\n  /**\n   * Helper function to get the hierarchicalFacet by it's name\n   * @param  {string} hierarchicalFacetName the hierarchicalFacet name\n   * @return {object} a hierarchicalFacet\n   */\n  getHierarchicalFacetByName: function (hierarchicalFacetName) {\n    return find(this.hierarchicalFacets, function (f) {\n      return f.name === hierarchicalFacetName;\n    });\n  },\n\n  /**\n   * Get the current breadcrumb for a hierarchical facet, as an array\n   * @param  {string} facetName Hierarchical facet name\n   * @return {array.<string>} the path as an array of string\n   */\n  getHierarchicalFacetBreadcrumb: function (facetName) {\n    if (!this.isHierarchicalFacet(facetName)) {\n      return [];\n    }\n\n    var refinement = this.getHierarchicalRefinement(facetName)[0];\n    if (!refinement) return [];\n\n    var separator = this._getHierarchicalFacetSeparator(\n      this.getHierarchicalFacetByName(facetName)\n    );\n    var path = refinement.split(separator);\n    return path.map(function (part) {\n      return part.trim();\n    });\n  },\n\n  toString: function () {\n    return JSON.stringify(this, null, 2);\n  },\n};\n\n/**\n * Callback used for clearRefinement method\n * @callback SearchParameters.clearCallback\n * @param {OperatorList|FacetList} value the value of the filter\n * @param {string} key the current attribute name\n * @param {string} type `numeric`, `disjunctiveFacet`, `conjunctiveFacet`, `hierarchicalFacet` or `exclude`\n * depending on the type of facet\n * @return {boolean} `true` if the element should be removed. `false` otherwise.\n */\nmodule.exports = SearchParameters;\n","'use strict';\n\nmodule.exports = function isValidUserToken(userToken) {\n  if (userToken === null) {\n    return false;\n  }\n  return /^[a-zA-Z0-9_-]{1,64}$/.test(userToken);\n};\n","'use strict';\n\nmodule.exports = function compact(array) {\n  if (!Array.isArray(array)) {\n    return [];\n  }\n\n  return array.filter(Boolean);\n};\n","'use strict';\n\n// @MAJOR can be replaced by native Array#findIndex when we change support\nmodule.exports = function find(array, comparator) {\n  if (!Array.isArray(array)) {\n    return -1;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (comparator(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n","'use strict';\n\nvar find = require('./find');\n\n/**\n * Transform sort format from user friendly notation to lodash format\n * @param {string[]} sortBy array of predicate of the form \"attribute:order\"\n * @param {string[]} [defaults] array of predicate of the form \"attribute:order\"\n * @return {array.<string[]>} array containing 2 elements : attributes, orders\n */\nmodule.exports = function formatSort(sortBy, defaults) {\n  var defaultInstructions = (defaults || []).map(function (sort) {\n    return sort.split(':');\n  });\n\n  return sortBy.reduce(\n    function preparePredicate(out, sort) {\n      var sortInstruction = sort.split(':');\n\n      var matchingDefault = find(\n        defaultInstructions,\n        function (defaultInstruction) {\n          return defaultInstruction[0] === sortInstruction[0];\n        }\n      );\n\n      if (sortInstruction.length > 1 || !matchingDefault) {\n        out[0].push(sortInstruction[0]);\n        out[1].push(sortInstruction[1]);\n        return out;\n      }\n\n      out[0].push(matchingDefault[0]);\n      out[1].push(matchingDefault[1]);\n      return out;\n    },\n    [[], []]\n  );\n};\n","'use strict';\n\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined;\n    var valIsNull = value === null;\n\n    var othIsDefined = other !== undefined;\n    var othIsNull = other === null;\n\n    if (\n      (!othIsNull && value > other) ||\n      (valIsNull && othIsDefined) ||\n      !valIsDefined\n    ) {\n      return 1;\n    }\n    if (\n      (!valIsNull && value < other) ||\n      (othIsNull && valIsDefined) ||\n      !othIsDefined\n    ) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * @param {Array<object>} collection object with keys in attributes\n * @param {Array<string>} iteratees attributes\n * @param {Array<string>} orders asc | desc\n * @return {Array<object>} sorted collection\n */\nfunction orderBy(collection, iteratees, orders) {\n  if (!Array.isArray(collection)) {\n    return [];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = [];\n  }\n\n  var result = collection.map(function (value, index) {\n    return {\n      criteria: iteratees.map(function (iteratee) {\n        return value[iteratee];\n      }),\n      index: index,\n      value: value,\n    };\n  });\n\n  result.sort(function comparer(object, other) {\n    var index = -1;\n\n    while (++index < object.criteria.length) {\n      var res = compareAscending(object.criteria[index], other.criteria[index]);\n      if (res) {\n        if (index >= orders.length) {\n          return res;\n        }\n        if (orders[index] === 'desc') {\n          return -res;\n        }\n        return res;\n      }\n    }\n\n    // This ensures a stable sort in V8 and other engines.\n    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  });\n\n  return result.map(function (res) {\n    return res.value;\n  });\n}\n\nmodule.exports = orderBy;\n","'use strict';\n\nmodule.exports = generateTrees;\n\nvar fv = require('../functions/escapeFacetValue');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\nvar orderBy = require('../functions/orderBy');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement =\n      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\n        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||\n      '';\n    var hierarchicalSeparator =\n      state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var hierarchicalRootPath =\n      state._getHierarchicalRootPath(hierarchicalFacet);\n    var hierarchicalShowParentLevel =\n      state._getHierarchicalShowParentLevel(hierarchicalFacet);\n    var sortBy = prepareHierarchicalFacetSortBy(\n      state._getHierarchicalFacetSortBy(hierarchicalFacet)\n    );\n\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\n      return facetResult.exhaustive;\n    });\n\n    var generateTreeFn = generateHierarchicalTree(\n      sortBy,\n      hierarchicalSeparator,\n      hierarchicalRootPath,\n      hierarchicalShowParentLevel,\n      hierarchicalFacetRefinement\n    );\n\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(\n        hierarchicalRootPath.split(hierarchicalSeparator).length\n      );\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null, // root level, no count\n      isRefined: true, // root level, always refined\n      path: null, // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null,\n    });\n  };\n}\n\nfunction generateHierarchicalTree(\n  sortBy,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel,\n  currentRefinement\n) {\n  return function generateTree(\n    hierarchicalTree,\n    hierarchicalFacetResult,\n    currentHierarchicalLevel\n  ) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function (subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data)\n        .map(function (facetValue) {\n          return [facetValue, hierarchicalFacetResult.data[facetValue]];\n        })\n        .filter(function (tuple) {\n          var facetValue = tuple[0];\n          return onlyMatchingTree(\n            facetValue,\n            parent.path || hierarchicalRootPath,\n            currentRefinement,\n            hierarchicalSeparator,\n            hierarchicalRootPath,\n            hierarchicalShowParentLevel\n          );\n        });\n\n      parent.data = orderBy(\n        picked.map(function (tuple) {\n          var facetValue = tuple[0];\n          var facetCount = tuple[1];\n\n          return format(\n            facetCount,\n            facetValue,\n            hierarchicalSeparator,\n            unescapeFacetValue(currentRefinement),\n            hierarchicalFacetResult.exhaustive\n          );\n        }),\n        sortBy[0],\n        sortBy[1]\n      );\n    }\n\n    return hierarchicalTree;\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction onlyMatchingTree(\n  facetValue,\n  parentPath,\n  currentRefinement,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel\n) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (\n    hierarchicalRootPath &&\n    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||\n      hierarchicalRootPath === facetValue)\n  ) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return (\n    (!hierarchicalRootPath &&\n      facetValue.indexOf(hierarchicalSeparator) === -1) ||\n    // if there is a rootPath, being root level mean 1 level under rootPath\n    (hierarchicalRootPath &&\n      facetValue.split(hierarchicalSeparator).length -\n        hierarchicalRootPath.split(hierarchicalSeparator).length ===\n        1) ||\n    // if current refinement is a root level and current facetValue is a root level,\n    // keep the facetValue\n    (facetValue.indexOf(hierarchicalSeparator) === -1 &&\n      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||\n    // currentRefinement is a child of the facet value\n    currentRefinement.indexOf(facetValue) === 0 ||\n    // facetValue is a child of the current parent, add it\n    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\n      (hierarchicalShowParentLevel ||\n        facetValue.indexOf(currentRefinement) === 0))\n  );\n}\n\nfunction format(\n  facetCount,\n  facetValue,\n  hierarchicalSeparator,\n  currentRefinement,\n  exhaustive\n) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined:\n      currentRefinement === facetValue ||\n      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null,\n  };\n}\n","'use strict';\n\nvar compact = require('../functions/compact');\nvar defaultsPure = require('../functions/defaultsPure');\nvar fv = require('../functions/escapeFacetValue');\nvar find = require('../functions/find');\nvar findIndex = require('../functions/findIndex');\nvar formatSort = require('../functions/formatSort');\nvar merge = require('../functions/merge');\nvar orderBy = require('../functions/orderBy');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n/**\n * Turn an array of attributes in an object of attributes with their position in the array as value\n * @param {string[]} attributes the list of attributes in the record\n * @return {object} the list of attributes indexed by attribute name\n */\nfunction getIndices(attributes) {\n  var indices = {};\n\n  attributes.forEach(function (val, idx) {\n    indices[val] = idx;\n  });\n\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\n/**\n * @typedef {Object} HierarchicalFacet\n * @property {string} name\n * @property {string[]} attributes\n */\n\n/**\n * @param {HierarchicalFacet[]} hierarchicalFacets All hierarchical facets\n * @param {string} hierarchicalAttributeName The name of the hierarchical attribute\n * @return {HierarchicalFacet} The hierarchical facet matching the attribute name\n */\nfunction findMatchingHierarchicalFacetFromAttributeName(\n  hierarchicalFacets,\n  hierarchicalAttributeName\n) {\n  return find(\n    hierarchicalFacets,\n    function facetKeyMatchesAttribute(hierarchicalFacet) {\n      var facetNames = hierarchicalFacet.attributes || [];\n      return facetNames.indexOf(hierarchicalAttributeName) > -1;\n    }\n  );\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\nfunction SearchResults(state, results, options) {\n  var mainSubResponse = results[0];\n\n  this._rawResults = results;\n\n  // eslint-disable-next-line consistent-this\n  var self = this;\n\n  // https://www.algolia.com/doc/api-reference/api-methods/search/#response\n  Object.keys(mainSubResponse).forEach(function (key) {\n    self[key] = mainSubResponse[key];\n  });\n\n  // Make every key of the result options reachable from the instance\n  Object.keys(options || {}).forEach(function (key) {\n    self[key] = options[key];\n  });\n\n  /**\n   * query used to generate the results\n   * @name query\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @name parsedQuery\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   * - `value` : the value of the facet highlighted (html)\n   * - `matchLevel`: `full`, `partial` or `none`, depending on how the query terms match\n   * @name hits\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * index where the results come from\n   * @name index\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * number of hits per page requested\n   * @name hitsPerPage\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * total number of hits of this query on the index\n   * @name nbHits\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @name nbPages\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * current page\n   * @name page\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * The position if the position was guessed by IP.\n   * @name aroundLatLng\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"48.8637,2.3615\",\n   */\n  /**\n   * The radius computed by Algolia.\n   * @name automaticRadius\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"126792922\",\n   */\n  /**\n   * String identifying the server used to serve this request.\n   *\n   * getRankingInfo needs to be set to `true` for this to be returned\n   *\n   * @name serverUsed\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   * @example \"c7-use-2.algolia.net\",\n   */\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @name timeoutCounts\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @name timeoutHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * True if the counts of the facets is exhaustive\n   * @name exhaustiveFacetsCount\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * True if the number of hits is exhaustive\n   * @name exhaustiveNbHits\n   * @member {boolean}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @name userData\n   * @member {object[]}\n   * @memberof SearchResults\n   * @instance\n   */\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @name queryID\n   * @member {string}\n   * @memberof SearchResults\n   * @instance\n   */\n\n  /**\n   * sum of the processing time of all the queries\n   * @name processingTimeMS\n   * @member {number}\n   * @memberof SearchResults\n   * @instance\n   */\n  this.processingTimeMS = results.reduce(function (sum, result) {\n    return result.processingTimeMS === undefined\n      ? sum\n      : sum + result.processingTimeMS;\n  }, 0);\n\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n  this.hierarchicalFacets = state.hierarchicalFacets.map(\n    function initFutureTree() {\n      return [];\n    }\n  );\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.facets = [];\n\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n\n  // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n\n  Object.keys(mainFacets).forEach(function (facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(\n      state.hierarchicalFacets,\n      facetKey\n    );\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount,\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount,\n        };\n        assignFacetStats(\n          self.disjunctiveFacets[position],\n          mainSubResponse.facets_stats,\n          facetKey\n        );\n      }\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount,\n        };\n        assignFacetStats(\n          self.facets[position],\n          mainSubResponse.facets_stats,\n          facetKey\n        );\n      }\n    }\n  });\n\n  // Make sure we do not keep holes within the hierarchical facets\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\n\n  // aggregate the refined disjunctive facets\n  disjunctiveFacets.forEach(function (disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\n\n    // There should be only item in facets.\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(\n          self.hierarchicalFacets[position],\n          function (f) {\n            return f.attribute === dfacet;\n          }\n        );\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge(\n          {},\n          self.hierarchicalFacets[position][attributeIndex].data,\n          facetResults\n        );\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n\n        var dataFromMainRequest =\n          (mainSubResponse.facets && mainSubResponse.facets[dfacet]) || {};\n\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount,\n        };\n        assignFacetStats(\n          self.disjunctiveFacets[position],\n          result.facets_stats,\n          dfacet\n        );\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function (\n            refinementValue\n          ) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (\n              !self.disjunctiveFacets[position].data[refinementValue] &&\n              state.disjunctiveFacetsRefinements[dfacet].indexOf(\n                unescapeFacetValue(refinementValue)\n              ) > -1\n            ) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  });\n\n  // if we have some parent level values for hierarchical facets, merge them\n  state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n    // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n    if (\n      currentRefinement.length === 0 ||\n      currentRefinement[0].split(separator).length < 2\n    ) {\n      return;\n    }\n\n    results.slice(nextDisjunctiveResult).forEach(function (result) {\n      var facets = result && result.facets ? result.facets : {};\n\n      Object.keys(facets).forEach(function (dfacet) {\n        var facetResults = facets[dfacet];\n        var position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(\n          self.hierarchicalFacets[position],\n          function (f) {\n            return f.attribute === dfacet;\n          }\n        );\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n        // then the disjunctive values will be `beers` (count: 100),\n        // but we do not want to display\n        //   | beers (100)\n        //     > IPA (5)\n        // We want\n        //   | beers (5)\n        //     > IPA (5)\n        var defaultData = {};\n\n        if (currentRefinement.length > 0) {\n          var root = currentRefinement[0].split(separator)[0];\n          defaultData[root] =\n            self.hierarchicalFacets[position][attributeIndex].data[root];\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(\n          defaultData,\n          facetResults,\n          self.hierarchicalFacets[position][attributeIndex].data\n        );\n      });\n\n      nextDisjunctiveResult++;\n    });\n  });\n\n  // add the excludes\n  Object.keys(state.facetsExcludes).forEach(function (facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n\n    self.facets[position] = {\n      name: facetName,\n      data: mainFacets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount,\n    };\n    excludes.forEach(function (facetValue) {\n      self.facets[position] = self.facets[position] || { name: facetName };\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n\n  /**\n   * @type {Array}\n   */\n  this.hierarchicalFacets = this.hierarchicalFacets.map(\n    generateHierarchicalTree(state)\n  );\n\n  /**\n   * @type {Array}\n   */\n  this.facets = compact(this.facets);\n  /**\n   * @type {Array}\n   */\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n\n  this._state = state;\n}\n\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\nSearchResults.prototype.getFacetByName = function (name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n\n  return (\n    find(this.facets, predicate) ||\n    find(this.disjunctiveFacets, predicate) ||\n    find(this.hierarchicalFacets, predicate)\n  );\n};\n\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n\n    return Object.keys(facet.data).map(function (name) {\n      var value = escapeFacetValue(name);\n      return {\n        name: name,\n        escapedValue: value,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, value),\n        isExcluded: results._state.isExcludeRefined(attribute, name),\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n\n    return Object.keys(disjunctiveFacet.data).map(function (name) {\n      var value = escapeFacetValue(name);\n      return {\n        name: name,\n        escapedValue: value,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, value),\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    var hierarchicalFacetValues = find(results.hierarchicalFacets, predicate);\n    if (!hierarchicalFacetValues) return hierarchicalFacetValues;\n\n    var hierarchicalFacet =\n      results._state.getHierarchicalFacetByName(attribute);\n    var separator =\n      results._state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var currentRefinement = unescapeFacetValue(\n      results._state.getHierarchicalRefinement(attribute)[0] || ''\n    );\n\n    if (currentRefinement.indexOf(hierarchicalFacet.rootPath) === 0) {\n      currentRefinement = currentRefinement.replace(\n        hierarchicalFacet.rootPath + separator,\n        ''\n      );\n    }\n\n    var currentRefinementSplit = currentRefinement.split(separator);\n    currentRefinementSplit.unshift(attribute);\n\n    setIsRefined(hierarchicalFacetValues, currentRefinementSplit, 0);\n\n    return hierarchicalFacetValues;\n  }\n\n  return undefined;\n}\n\n/**\n * Set the isRefined of a hierarchical facet result based on the current state.\n * @param {SearchResults.HierarchicalFacet} item Hierarchical facet to fix\n * @param {string[]} currentRefinement array of parts of the current hierarchical refinement\n * @param {number} depth recursion depth in the currentRefinement\n * @return {undefined} function mutates the item\n */\nfunction setIsRefined(item, currentRefinement, depth) {\n  item.isRefined = item.name === currentRefinement[depth];\n  if (item.data) {\n    item.data.forEach(function (child) {\n      setIsRefined(child, currentRefinement, depth + 1);\n    });\n  }\n}\n\n/**\n * Sort nodes of a hierarchical or disjunctive facet results\n * @private\n * @param {function} sortFn sort function to apply\n * @param {HierarchicalFacet|Array} node node upon which we want to apply the sort\n * @param {string[]} names attribute names\n * @param {number} [level=0] current index in the names array\n * @return {HierarchicalFacet|Array} sorted node\n */\nfunction recSort(sortFn, node, names, level) {\n  level = level || 0;\n\n  if (Array.isArray(node)) {\n    return sortFn(node, names[level]);\n  }\n\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = node.data.map(function (childNode) {\n    return recSort(sortFn, childNode, names, level + 1);\n  });\n  var sortedChildren = sortFn(children, names[level]);\n  var newNode = defaultsPure({ data: sortedChildren }, node);\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n\n/**\n * @typedef FacetOrdering\n * @type {Object}\n * @property {string[]} [order]\n * @property {'count' | 'alpha' | 'hidden'} [sortRemainingBy]\n */\n\n/**\n * Sorts facet arrays via their facet ordering\n * @param {Array} facetValues the values\n * @param {FacetOrdering} facetOrdering the ordering\n * @returns {Array} the sorted facet values\n */\nfunction sortViaFacetOrdering(facetValues, facetOrdering) {\n  var orderedFacets = [];\n  var remainingFacets = [];\n\n  var order = facetOrdering.order || [];\n  /**\n   * an object with the keys being the values in order, the values their index:\n   * ['one', 'two'] -> { one: 0, two: 1 }\n   */\n  var reverseOrder = order.reduce(function (acc, name, i) {\n    acc[name] = i;\n    return acc;\n  }, {});\n\n  facetValues.forEach(function (item) {\n    // hierarchical facets get sorted using their raw name\n    var name = item.path || item.name;\n    if (reverseOrder[name] !== undefined) {\n      orderedFacets[reverseOrder[name]] = item;\n    } else {\n      remainingFacets.push(item);\n    }\n  });\n\n  orderedFacets = orderedFacets.filter(function (facet) {\n    return facet;\n  });\n\n  var sortRemainingBy = facetOrdering.sortRemainingBy;\n  var ordering;\n  if (sortRemainingBy === 'hidden') {\n    return orderedFacets;\n  } else if (sortRemainingBy === 'alpha') {\n    ordering = [\n      ['path', 'name'],\n      ['asc', 'asc'],\n    ];\n  } else {\n    ordering = [['count'], ['desc']];\n  }\n\n  return orderedFacets.concat(\n    orderBy(remainingFacets, ordering[0], ordering[1])\n  );\n}\n\n/**\n * @param {SearchResults} results the search results class\n * @param {string} attribute the attribute to retrieve ordering of\n * @returns {FacetOrdering | undefined} the facet ordering\n */\nfunction getFacetOrdering(results, attribute) {\n  return (\n    results.renderingContent &&\n    results.renderingContent.facetOrdering &&\n    results.renderingContent.facetOrdering.values &&\n    results.renderingContent.facetOrdering.values[attribute]\n  );\n}\n\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {boolean} [opts.facetOrdering]\n * Force the use of facetOrdering from the result if a sortBy is present. If\n * sortBy isn't present, facetOrdering will be used automatically.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('result', function(event){\n *   //get values ordered only by name ascending using the string predicate\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   event.results.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) {\n    return undefined;\n  }\n\n  var options = defaultsPure({}, opts, {\n    sortBy: SearchResults.DEFAULT_SORT,\n    // if no sortBy is given, attempt to sort based on facetOrdering\n    // if it is given, we still allow to sort via facet ordering first\n    facetOrdering: !(opts && opts.sortBy),\n  });\n\n  // eslint-disable-next-line consistent-this\n  var results = this;\n  var attributes;\n  if (Array.isArray(facetValues)) {\n    attributes = [attribute];\n  } else {\n    var config = results._state.getHierarchicalFacetByName(facetValues.name);\n    attributes = config.attributes;\n  }\n\n  return recSort(\n    function (data, facetName) {\n      if (options.facetOrdering) {\n        var facetOrdering = getFacetOrdering(results, facetName);\n        if (facetOrdering) {\n          return sortViaFacetOrdering(data, facetOrdering);\n        }\n      }\n\n      if (Array.isArray(options.sortBy)) {\n        var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n        return orderBy(data, order[0], order[1]);\n      } else if (typeof options.sortBy === 'function') {\n        return vanillaSortFn(options.sortBy, data);\n      }\n      throw new Error(\n        'options.sortBy is optional but if defined it must be ' +\n          'either an array of string (predicates) or a sorting function'\n      );\n    },\n    facetValues,\n    attributes\n  );\n};\n\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\nSearchResults.prototype.getFacetStats = function (attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  return undefined;\n};\n\n/**\n * @typedef {Object} FacetListItem\n * @property {string} name\n */\n\n/**\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\n * @param {string} facetName The attribute to look for\n * @return {object|undefined} The stats of the facet\n */\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function (facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhaustiveness for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * Note that for a numeric refinement, results are grouped per operator, this\n * means that it will return responses for operators which are empty.\n *\n * @return {Array.<Refinement>} all the refinements\n */\nSearchResults.prototype.getRefinements = function () {\n  var state = this._state;\n  // eslint-disable-next-line consistent-this\n  var results = this;\n  var res = [];\n\n  Object.keys(state.facetsRefinements).forEach(function (attributeName) {\n    state.facetsRefinements[attributeName].forEach(function (name) {\n      res.push(\n        getRefinement(state, 'facet', attributeName, name, results.facets)\n      );\n    });\n  });\n\n  Object.keys(state.facetsExcludes).forEach(function (attributeName) {\n    state.facetsExcludes[attributeName].forEach(function (name) {\n      res.push(\n        getRefinement(state, 'exclude', attributeName, name, results.facets)\n      );\n    });\n  });\n\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function (\n    attributeName\n  ) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(\n        getRefinement(\n          state,\n          'disjunctive',\n          attributeName,\n          name,\n          results.disjunctiveFacets\n        )\n      );\n    });\n  });\n\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function (\n    attributeName\n  ) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(\n        getHierarchicalRefinement(\n          state,\n          attributeName,\n          name,\n          results.hierarchicalFacets\n        )\n      );\n    });\n  });\n\n  Object.keys(state.numericRefinements).forEach(function (attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function (operator) {\n      operators[operator].forEach(function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator,\n        });\n      });\n    });\n  });\n\n  state.tagRefinements.forEach(function (name) {\n    res.push({ type: 'tag', attributeName: '_tags', name: name });\n  });\n\n  return res;\n};\n\n/**\n * @typedef {Object} Facet\n * @property {string} name\n * @property {Object} data\n * @property {boolean} exhaustive\n */\n\n/**\n * @param {SearchParameters} state the current state\n * @param {string} type the type of the refinement\n * @param {string} attributeName The attribute of the facet\n * @param {*} name The name of the facet\n * @param {Facet[]} resultsFacets facets from the results\n * @return {Refinement} the refinement\n */\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function (f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive,\n  };\n}\n\n/**\n * @param {SearchParameters} state the current state\n * @param {string} attributeName the attribute of the hierarchical facet\n * @param {string} name the name of the facet\n * @param {Facet[]} resultsFacets facets from the results\n * @return {HierarchicalFacet} the hierarchical facet\n */\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function (facet) {\n    return facet.name === attributeName;\n  });\n\n  var facet = split.reduce(function (intermediateFacet, part) {\n    var newFacet =\n      intermediateFacet &&\n      find(intermediateFacet.data, function (f) {\n        return f.name === part;\n      });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n\n  var count = (facet && facet.count) || 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n  var path = (facet && facet.path) || '';\n\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive,\n  };\n}\n\nmodule.exports = SearchResults;\n","'use strict';\n\nmodule.exports = '3.14.0';\n","'use strict';\n\nvar EventEmitter = require('@algolia/events');\n\nvar DerivedHelper = require('./DerivedHelper');\nvar escapeFacetValue = require('./functions/escapeFacetValue').escapeFacetValue;\nvar inherits = require('./functions/inherits');\nvar merge = require('./functions/merge');\nvar objectHasKeys = require('./functions/objectHasKeys');\nvar omit = require('./functions/omit');\nvar requestBuilder = require('./requestBuilder');\nvar SearchParameters = require('./SearchParameters');\nvar SearchResults = require('./SearchResults');\nvar version = require('./version');\n\n/**\n * Event triggered when a parameter is set or updated\n * @event AlgoliaSearchHelper#event:change\n * @property {object} event\n * @property {SearchParameters} event.state the current parameters with the latest changes applied\n * @property {SearchResults} event.results the previous results received from Algolia. `null` before the first request\n * @example\n * helper.on('change', function(event) {\n *   console.log('The parameters have changed');\n * });\n */\n\n/**\n * Event triggered when a main search is sent to Algolia\n * @event AlgoliaSearchHelper#event:search\n * @property {object} event\n * @property {SearchParameters} event.state the parameters used for this search\n * @property {SearchResults} event.results the results from the previous search. `null` if it is the first search.\n * @example\n * helper.on('search', function(event) {\n *   console.log('Search sent');\n * });\n */\n\n/**\n * Event triggered when a search using `searchForFacetValues` is sent to Algolia\n * @event AlgoliaSearchHelper#event:searchForFacetValues\n * @property {object} event\n * @property {SearchParameters} event.state the parameters used for this search it is the first search.\n * @property {string} event.facet the facet searched into\n * @property {string} event.query the query used to search in the facets\n * @example\n * helper.on('searchForFacetValues', function(event) {\n *   console.log('searchForFacetValues sent');\n * });\n */\n\n/**\n * Event triggered when a search using `searchOnce` is sent to Algolia\n * @event AlgoliaSearchHelper#event:searchOnce\n * @property {object} event\n * @property {SearchParameters} event.state the parameters used for this search it is the first search.\n * @example\n * helper.on('searchOnce', function(event) {\n *   console.log('searchOnce sent');\n * });\n */\n\n/**\n * Event triggered when the results are retrieved from Algolia\n * @event AlgoliaSearchHelper#event:result\n * @property {object} event\n * @property {SearchResults} event.results the results received from Algolia\n * @property {SearchParameters} event.state the parameters used to query Algolia. Those might be different from the one in the helper instance (for example if the network is unreliable).\n * @example\n * helper.on('result', function(event) {\n *   console.log('Search results received');\n * });\n */\n\n/**\n * Event triggered when Algolia sends back an error. For example, if an unknown parameter is\n * used, the error can be caught using this event.\n * @event AlgoliaSearchHelper#event:error\n * @property {object} event\n * @property {Error} event.error the error returned by the Algolia.\n * @example\n * helper.on('error', function(event) {\n *   console.log('Houston we got a problem.');\n * });\n */\n\n/**\n * Event triggered when the queue of queries have been depleted (with any result or outdated queries)\n * @event AlgoliaSearchHelper#event:searchQueueEmpty\n * @example\n * helper.on('searchQueueEmpty', function() {\n *   console.log('No more search pending');\n *   // This is received before the result event if we're not expecting new results\n * });\n *\n * helper.search();\n */\n\n/**\n * Initialize a new AlgoliaSearchHelper\n * @class\n * @classdesc The AlgoliaSearchHelper is a class that ease the management of the\n * search. It provides an event based interface for search callbacks:\n *  - change: when the internal search state is changed.\n *    This event contains a {@link SearchParameters} object and the\n *    {@link SearchResults} of the last result if any.\n *  - search: when a search is triggered using the `search()` method.\n *  - result: when the response is retrieved from Algolia and is processed.\n *    This event contains a {@link SearchResults} object and the\n *    {@link SearchParameters} corresponding to this answer.\n *  - error: when the response is an error. This event contains the error returned by the server.\n * @param  {AlgoliaSearch} client an AlgoliaSearch client\n * @param  {string} index the index name to query\n * @param  {SearchParameters | object} options an object defining the initial\n * config of the search. It doesn't have to be a {SearchParameters},\n * just an object containing the properties you need from it.\n */\nfunction AlgoliaSearchHelper(client, index, options) {\n  if (typeof client.addAlgoliaAgent === 'function') {\n    client.addAlgoliaAgent('JS Helper (' + version + ')');\n  }\n\n  this.setClient(client);\n  var opts = options || {};\n  opts.index = index;\n  this.state = SearchParameters.make(opts);\n  this.lastResults = null;\n  this._queryId = 0;\n  this._lastQueryIdReceived = -1;\n  this.derivedHelpers = [];\n  this._currentNbQueries = 0;\n}\n\ninherits(AlgoliaSearchHelper, EventEmitter);\n\n/**\n * Start the search with the parameters set in the state. When the\n * method is called, it triggers a `search` event. The results will\n * be available through the `result` event. If an error occurs, an\n * `error` will be fired instead.\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires search\n * @fires result\n * @fires error\n * @chainable\n */\nAlgoliaSearchHelper.prototype.search = function () {\n  this._search({ onlyWithDerivedHelpers: false });\n  return this;\n};\n\nAlgoliaSearchHelper.prototype.searchOnlyWithDerivedHelpers = function () {\n  this._search({ onlyWithDerivedHelpers: true });\n  return this;\n};\n\n/**\n * Gets the search query parameters that would be sent to the Algolia Client\n * for the hits\n * @return {object} Query Parameters\n */\nAlgoliaSearchHelper.prototype.getQuery = function () {\n  var state = this.state;\n  return requestBuilder._getHitsSearchParams(state);\n};\n\n/**\n * Start a search using a modified version of the current state. This method does\n * not trigger the helper lifecycle and does not modify the state kept internally\n * by the helper. This second aspect means that the next search call will be the\n * same as a search call before calling searchOnce.\n * @param {object} options can contain all the parameters that can be set to SearchParameters\n * plus the index\n * @param {function} [cb] optional callback executed when the response from the\n * server is back.\n * @return {promise|undefined} if a callback is passed the method returns undefined\n * otherwise it returns a promise containing an object with two keys :\n *  - content with a SearchResults\n *  - state with the state used for the query as a SearchParameters\n * @example\n * // Changing the number of records returned per page to 1\n * // This example uses the callback API\n * var state = helper.searchOnce({hitsPerPage: 1},\n *   function(error, content, state) {\n *     // if an error occurred it will be passed in error, otherwise its value is null\n *     // content contains the results formatted as a SearchResults\n *     // state is the instance of SearchParameters used for this search\n *   });\n * @example\n * // Changing the number of records returned per page to 1\n * // This example uses the promise API\n * var state1 = helper.searchOnce({hitsPerPage: 1})\n *                 .then(promiseHandler);\n *\n * function promiseHandler(res) {\n *   // res contains\n *   // {\n *   //   content : SearchResults\n *   //   state   : SearchParameters (the one used for this specific search)\n *   // }\n * }\n */\nAlgoliaSearchHelper.prototype.searchOnce = function (options, cb) {\n  var tempState = !options\n    ? this.state\n    : this.state.setQueryParameters(options);\n  var queries = requestBuilder._getQueries(tempState.index, tempState);\n  // eslint-disable-next-line consistent-this\n  var self = this;\n\n  this._currentNbQueries++;\n\n  this.emit('searchOnce', {\n    state: tempState,\n  });\n\n  if (cb) {\n    this.client\n      .search(queries)\n      .then(function (content) {\n        self._currentNbQueries--;\n        if (self._currentNbQueries === 0) {\n          self.emit('searchQueueEmpty');\n        }\n\n        cb(null, new SearchResults(tempState, content.results), tempState);\n      })\n      .catch(function (err) {\n        self._currentNbQueries--;\n        if (self._currentNbQueries === 0) {\n          self.emit('searchQueueEmpty');\n        }\n\n        cb(err, null, tempState);\n      });\n\n    return undefined;\n  }\n\n  return this.client.search(queries).then(\n    function (content) {\n      self._currentNbQueries--;\n      if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');\n      return {\n        content: new SearchResults(tempState, content.results),\n        state: tempState,\n        _originalResponse: content,\n      };\n    },\n    function (e) {\n      self._currentNbQueries--;\n      if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');\n      throw e;\n    }\n  );\n};\n\n/**\n * Start the search for answers with the parameters set in the state.\n * This method returns a promise.\n * @param {Object} options - the options for answers API call\n * @param {string[]} options.attributesForPrediction - Attributes to use for predictions. If empty, `searchableAttributes` is used instead.\n * @param {string[]} options.queryLanguages - The languages in the query. Currently only supports ['en'].\n * @param {number} options.nbHits - Maximum number of answers to retrieve from the Answers Engine. Cannot be greater than 1000.\n *\n * @return {promise} the answer results\n * @deprecated answers is deprecated and will be replaced with new initiatives\n */\nAlgoliaSearchHelper.prototype.findAnswers = function (options) {\n  // eslint-disable-next-line no-console\n  console.warn('[algoliasearch-helper] answers is no longer supported');\n  var state = this.state;\n  var derivedHelper = this.derivedHelpers[0];\n  if (!derivedHelper) {\n    return Promise.resolve([]);\n  }\n  var derivedState = derivedHelper.getModifiedState(state);\n  var data = merge(\n    {\n      attributesForPrediction: options.attributesForPrediction,\n      nbHits: options.nbHits,\n    },\n    {\n      params: omit(requestBuilder._getHitsSearchParams(derivedState), [\n        'attributesToSnippet',\n        'hitsPerPage',\n        'restrictSearchableAttributes',\n        'snippetEllipsisText',\n      ]),\n    }\n  );\n\n  var errorMessage =\n    'search for answers was called, but this client does not have a function client.initIndex(index).findAnswers';\n  if (typeof this.client.initIndex !== 'function') {\n    throw new Error(errorMessage);\n  }\n  var index = this.client.initIndex(derivedState.index);\n  if (typeof index.findAnswers !== 'function') {\n    throw new Error(errorMessage);\n  }\n  return index.findAnswers(derivedState.query, options.queryLanguages, data);\n};\n\n/**\n * Structure of each result when using\n * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)\n * @typedef FacetSearchHit\n * @type {object}\n * @property {string} value the facet value\n * @property {string} highlighted the facet value highlighted with the query string\n * @property {number} count number of occurrence of this facet value\n * @property {boolean} isRefined true if the value is already refined\n */\n\n/**\n * Structure of the data resolved by the\n * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)\n * promise.\n * @typedef FacetSearchResult\n * @type {object}\n * @property {FacetSearchHit} facetHits the results for this search for facet values\n * @property {number} processingTimeMS time taken by the query inside the engine\n */\n\n/**\n * Search for facet values based on an query and the name of a faceted attribute. This\n * triggers a search and will return a promise. On top of using the query, it also sends\n * the parameters from the state so that the search is narrowed down to only the possible values.\n *\n * See the description of [FacetSearchResult](reference.html#FacetSearchResult)\n * @param {string} facet the name of the faceted attribute\n * @param {string} query the string query for the search\n * @param {number} [maxFacetHits] the maximum number values returned. Should be > 0 and <= 100\n * @param {object} [userState] the set of custom parameters to use on top of the current state. Setting a property to `undefined` removes\n * it in the generated query.\n * @return {promise.<FacetSearchResult>} the results of the search\n */\nAlgoliaSearchHelper.prototype.searchForFacetValues = function (\n  facet,\n  query,\n  maxFacetHits,\n  userState\n) {\n  var clientHasSFFV = typeof this.client.searchForFacetValues === 'function';\n  var clientHasInitIndex = typeof this.client.initIndex === 'function';\n  if (\n    !clientHasSFFV &&\n    !clientHasInitIndex &&\n    typeof this.client.search !== 'function'\n  ) {\n    throw new Error(\n      'search for facet values (searchable) was called, but this client does not have a function client.searchForFacetValues or client.initIndex(index).searchForFacetValues'\n    );\n  }\n\n  var state = this.state.setQueryParameters(userState || {});\n  var isDisjunctive = state.isDisjunctiveFacet(facet);\n  var algoliaQuery = requestBuilder.getSearchForFacetQuery(\n    facet,\n    query,\n    maxFacetHits,\n    state\n  );\n\n  this._currentNbQueries++;\n  // eslint-disable-next-line consistent-this\n  var self = this;\n  var searchForFacetValuesPromise;\n  // newer algoliasearch ^3.27.1 - ~4.0.0\n  if (clientHasSFFV) {\n    searchForFacetValuesPromise = this.client.searchForFacetValues([\n      { indexName: state.index, params: algoliaQuery },\n    ]);\n    // algoliasearch < 3.27.1\n  } else if (clientHasInitIndex) {\n    searchForFacetValuesPromise = this.client\n      .initIndex(state.index)\n      .searchForFacetValues(algoliaQuery);\n    // algoliasearch ~5.0.0\n  } else {\n    // @MAJOR only use client.search\n    delete algoliaQuery.facetName;\n    searchForFacetValuesPromise = this.client\n      .search([\n        {\n          type: 'facet',\n          facet: facet,\n          indexName: state.index,\n          params: algoliaQuery,\n        },\n      ])\n      .then(function processResponse(response) {\n        return response.results[0];\n      });\n  }\n\n  this.emit('searchForFacetValues', {\n    state: state,\n    facet: facet,\n    query: query,\n  });\n\n  return searchForFacetValuesPromise.then(\n    function addIsRefined(content) {\n      self._currentNbQueries--;\n      if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');\n\n      content = Array.isArray(content) ? content[0] : content;\n\n      content.facetHits.forEach(function (f) {\n        f.escapedValue = escapeFacetValue(f.value);\n        f.isRefined = isDisjunctive\n          ? state.isDisjunctiveFacetRefined(facet, f.escapedValue)\n          : state.isFacetRefined(facet, f.escapedValue);\n      });\n\n      return content;\n    },\n    function (e) {\n      self._currentNbQueries--;\n      if (self._currentNbQueries === 0) self.emit('searchQueueEmpty');\n      throw e;\n    }\n  );\n};\n\n/**\n * Sets the text query used for the search.\n *\n * This method resets the current page to 0.\n * @param  {string} q the user query\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.setQuery = function (q) {\n  this._change({\n    state: this.state.resetPage().setQuery(q),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Remove all the types of refinements except tags. A string can be provided to remove\n * only the refinements of a specific attribute. For more advanced use case, you can\n * provide a function instead. This function should follow the\n * [clearCallback definition](#SearchParameters.clearCallback).\n *\n * This method resets the current page to 0.\n * @param {string} [name] optional name of the facet / attribute on which we want to remove all refinements\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n * @example\n * // Removing all the refinements\n * helper.clearRefinements().search();\n * @example\n * // Removing all the filters on a the category attribute.\n * helper.clearRefinements('category').search();\n * @example\n * // Removing only the exclude filters on the category facet.\n * helper.clearRefinements(function(value, attribute, type) {\n *   return type === 'exclude' && attribute === 'category';\n * }).search();\n */\nAlgoliaSearchHelper.prototype.clearRefinements = function (name) {\n  this._change({\n    state: this.state.resetPage().clearRefinements(name),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Remove all the tag filters.\n *\n * This method resets the current page to 0.\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.clearTags = function () {\n  this._change({\n    state: this.state.resetPage().clearTags(),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Adds a disjunctive filter to a faceted attribute with the `value` provided. If the\n * filter is already set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value (will be converted to string)\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.addDisjunctiveFacetRefinement = function (\n  facet,\n  value\n) {\n  this._change({\n    state: this.state.resetPage().addDisjunctiveFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addDisjunctiveFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.addDisjunctiveRefine = function () {\n  return this.addDisjunctiveFacetRefinement.apply(this, arguments);\n};\n\n/**\n * Adds a refinement on a hierarchical facet. It will throw\n * an exception if the facet is not defined or if the facet\n * is already refined.\n *\n * This method resets the current page to 0.\n * @param {string} facet the facet name\n * @param {string} path the hierarchical facet path\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @throws Error if the facet is not defined or if the facet is refined\n * @chainable\n * @fires change\n */\nAlgoliaSearchHelper.prototype.addHierarchicalFacetRefinement = function (\n  facet,\n  path\n) {\n  this._change({\n    state: this.state.resetPage().addHierarchicalFacetRefinement(facet, path),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Adds a an numeric filter to an attribute with the `operator` and `value` provided. If the\n * filter is already set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param  {string} attribute the attribute on which the numeric filter applies\n * @param  {string} operator the operator of the filter\n * @param  {number} value the value of the filter\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.addNumericRefinement = function (\n  attribute,\n  operator,\n  value\n) {\n  this._change({\n    state: this.state\n      .resetPage()\n      .addNumericRefinement(attribute, operator, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Adds a filter to a faceted attribute with the `value` provided. If the\n * filter is already set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value (will be converted to string)\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.addFacetRefinement = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().addFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.addRefine = function () {\n  return this.addFacetRefinement.apply(this, arguments);\n};\n\n/**\n * Adds a an exclusion filter to a faceted attribute with the `value` provided. If the\n * filter is already set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value (will be converted to string)\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.addFacetExclusion = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().addExcludeRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetExclusion}\n */\nAlgoliaSearchHelper.prototype.addExclude = function () {\n  return this.addFacetExclusion.apply(this, arguments);\n};\n\n/**\n * Adds a tag filter with the `tag` provided. If the\n * filter is already set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param {string} tag the tag to add to the filter\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.addTag = function (tag) {\n  this._change({\n    state: this.state.resetPage().addTagRefinement(tag),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Removes an numeric filter to an attribute with the `operator` and `value` provided. If the\n * filter is not set, it doesn't change the filters.\n *\n * Some parameters are optional, triggering different behavior:\n *  - if the value is not provided, then all the numeric value will be removed for the\n *  specified attribute/operator couple.\n *  - if the operator is not provided either, then all the numeric filter on this attribute\n *  will be removed.\n *\n * This method resets the current page to 0.\n * @param  {string} attribute the attribute on which the numeric filter applies\n * @param  {string} [operator] the operator of the filter\n * @param  {number} [value] the value of the filter\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeNumericRefinement = function (\n  attribute,\n  operator,\n  value\n) {\n  this._change({\n    state: this.state\n      .resetPage()\n      .removeNumericRefinement(attribute, operator, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Removes a disjunctive filter to a faceted attribute with the `value` provided. If the\n * filter is not set, it doesn't change the filters.\n *\n * If the value is omitted, then this method will remove all the filters for the\n * attribute.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} [value] the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeDisjunctiveFacetRefinement = function (\n  facet,\n  value\n) {\n  this._change({\n    state: this.state\n      .resetPage()\n      .removeDisjunctiveFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeDisjunctiveFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.removeDisjunctiveRefine = function () {\n  return this.removeDisjunctiveFacetRefinement.apply(this, arguments);\n};\n\n/**\n * Removes the refinement set on a hierarchical facet.\n * @param {string} facet the facet name\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @throws Error if the facet is not defined or if the facet is not refined\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeHierarchicalFacetRefinement = function (\n  facet\n) {\n  this._change({\n    state: this.state.resetPage().removeHierarchicalFacetRefinement(facet),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Removes a filter to a faceted attribute with the `value` provided. If the\n * filter is not set, it doesn't change the filters.\n *\n * If the value is omitted, then this method will remove all the filters for the\n * attribute.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} [value] the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeFacetRefinement = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().removeFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.removeRefine = function () {\n  return this.removeFacetRefinement.apply(this, arguments);\n};\n\n/**\n * Removes an exclusion filter to a faceted attribute with the `value` provided. If the\n * filter is not set, it doesn't change the filters.\n *\n * If the value is omitted, then this method will remove all the filters for the\n * attribute.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} [value] the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeFacetExclusion = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().removeExcludeRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetExclusion}\n */\nAlgoliaSearchHelper.prototype.removeExclude = function () {\n  return this.removeFacetExclusion.apply(this, arguments);\n};\n\n/**\n * Removes a tag filter with the `tag` provided. If the\n * filter is not set, it doesn't change the filters.\n *\n * This method resets the current page to 0.\n * @param {string} tag tag to remove from the filter\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.removeTag = function (tag) {\n  this._change({\n    state: this.state.resetPage().removeTagRefinement(tag),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Adds or removes an exclusion filter to a faceted attribute with the `value` provided. If\n * the value is set then it removes it, otherwise it adds the filter.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.toggleFacetExclusion = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().toggleExcludeFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetExclusion}\n */\nAlgoliaSearchHelper.prototype.toggleExclude = function () {\n  return this.toggleFacetExclusion.apply(this, arguments);\n};\n\n/**\n * Adds or removes a filter to a faceted attribute with the `value` provided. If\n * the value is set then it removes it, otherwise it adds the filter.\n *\n * This method can be used for conjunctive, disjunctive and hierarchical filters.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @throws Error will throw an error if the facet is not declared in the settings of the helper\n * @fires change\n * @chainable\n * @deprecated since version 2.19.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.toggleRefinement = function (facet, value) {\n  return this.toggleFacetRefinement(facet, value);\n};\n\n/**\n * Adds or removes a filter to a faceted attribute with the `value` provided. If\n * the value is set then it removes it, otherwise it adds the filter.\n *\n * This method can be used for conjunctive, disjunctive and hierarchical filters.\n *\n * This method resets the current page to 0.\n * @param  {string} facet the facet to refine\n * @param  {string} value the associated value\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @throws Error will throw an error if the facet is not declared in the settings of the helper\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.toggleFacetRefinement = function (facet, value) {\n  this._change({\n    state: this.state.resetPage().toggleFacetRefinement(facet, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}\n */\nAlgoliaSearchHelper.prototype.toggleRefine = function () {\n  return this.toggleFacetRefinement.apply(this, arguments);\n};\n\n/**\n * Adds or removes a tag filter with the `value` provided. If\n * the value is set then it removes it, otherwise it adds the filter.\n *\n * This method resets the current page to 0.\n * @param {string} tag tag to remove or add\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.toggleTag = function (tag) {\n  this._change({\n    state: this.state.resetPage().toggleTagRefinement(tag),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Increments the page number by one.\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n * @example\n * helper.setPage(0).nextPage().getPage();\n * // returns 1\n */\nAlgoliaSearchHelper.prototype.nextPage = function () {\n  var page = this.state.page || 0;\n  return this.setPage(page + 1);\n};\n\n/**\n * Decrements the page number by one.\n * @fires change\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @chainable\n * @example\n * helper.setPage(1).previousPage().getPage();\n * // returns 0\n */\nAlgoliaSearchHelper.prototype.previousPage = function () {\n  var page = this.state.page || 0;\n  return this.setPage(page - 1);\n};\n\n/**\n * @private\n * @param {number} page The page number\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @chainable\n * @fires change\n */\nfunction setCurrentPage(page) {\n  if (page < 0) throw new Error('Page requested below 0.');\n\n  this._change({\n    state: this.state.setPage(page),\n    isPageReset: false,\n  });\n\n  return this;\n}\n\n/**\n * Change the current page\n * @deprecated\n * @param  {number} page The page number\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.setCurrentPage = setCurrentPage;\n\n/**\n * Updates the current page.\n * @function\n * @param  {number} page The page number\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.setPage = setCurrentPage;\n\n/**\n * Updates the name of the index that will be targeted by the query.\n *\n * This method resets the current page to 0.\n * @param {string} name the index name\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.setIndex = function (name) {\n  this._change({\n    state: this.state.resetPage().setIndex(name),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Update a parameter of the search. This method reset the page\n *\n * The complete list of parameters is available on the\n * [Algolia website](https://www.algolia.com/doc/rest#query-an-index).\n * The most commonly used parameters have their own [shortcuts](#query-parameters-shortcuts)\n * or benefit from higher-level APIs (all the kind of filters and facets have their own API)\n *\n * This method resets the current page to 0.\n * @param {string} parameter name of the parameter to update\n * @param {any} value new value of the parameter\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n * @example\n * helper.setQueryParameter('hitsPerPage', 20).search();\n */\nAlgoliaSearchHelper.prototype.setQueryParameter = function (parameter, value) {\n  this._change({\n    state: this.state.resetPage().setQueryParameter(parameter, value),\n    isPageReset: true,\n  });\n\n  return this;\n};\n\n/**\n * Set the whole state (warning: will erase previous state)\n * @param {SearchParameters} newState the whole new state\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @fires change\n * @chainable\n */\nAlgoliaSearchHelper.prototype.setState = function (newState) {\n  this._change({\n    state: SearchParameters.make(newState),\n    isPageReset: false,\n  });\n\n  return this;\n};\n\n/**\n * Override the current state without triggering a change event.\n * Do not use this method unless you know what you are doing. (see the example\n * for a legit use case)\n * @param {SearchParameters} newState the whole new state\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n * @example\n *  helper.on('change', function(state){\n *    // In this function you might want to find a way to store the state in the url/history\n *    updateYourURL(state)\n *  })\n *  window.onpopstate = function(event){\n *    // This is naive though as you should check if the state is really defined etc.\n *    helper.overrideStateWithoutTriggeringChangeEvent(event.state).search()\n *  }\n * @chainable\n */\nAlgoliaSearchHelper.prototype.overrideStateWithoutTriggeringChangeEvent =\n  function (newState) {\n    this.state = new SearchParameters(newState);\n    return this;\n  };\n\n/**\n * Check if an attribute has any numeric, conjunctive, disjunctive or hierarchical filters.\n * @param {string} attribute the name of the attribute\n * @return {boolean} true if the attribute is filtered by at least one value\n * @example\n * // hasRefinements works with numeric, conjunctive, disjunctive and hierarchical filters\n * helper.hasRefinements('price'); // false\n * helper.addNumericRefinement('price', '>', 100);\n * helper.hasRefinements('price'); // true\n *\n * helper.hasRefinements('color'); // false\n * helper.addFacetRefinement('color', 'blue');\n * helper.hasRefinements('color'); // true\n *\n * helper.hasRefinements('material'); // false\n * helper.addDisjunctiveFacetRefinement('material', 'plastic');\n * helper.hasRefinements('material'); // true\n *\n * helper.hasRefinements('categories'); // false\n * helper.toggleFacetRefinement('categories', 'kitchen > knife');\n * helper.hasRefinements('categories'); // true\n *\n */\nAlgoliaSearchHelper.prototype.hasRefinements = function (attribute) {\n  if (objectHasKeys(this.state.getNumericRefinements(attribute))) {\n    return true;\n  } else if (this.state.isConjunctiveFacet(attribute)) {\n    return this.state.isFacetRefined(attribute);\n  } else if (this.state.isDisjunctiveFacet(attribute)) {\n    return this.state.isDisjunctiveFacetRefined(attribute);\n  } else if (this.state.isHierarchicalFacet(attribute)) {\n    return this.state.isHierarchicalFacetRefined(attribute);\n  }\n\n  // there's currently no way to know that the user did call `addNumericRefinement` at some point\n  // thus we cannot distinguish if there once was a numeric refinement that was cleared\n  // so we will return false in every other situations to be consistent\n  // while what we should do here is throw because we did not find the attribute in any type\n  // of refinement\n  return false;\n};\n\n/**\n * Check if a value is excluded for a specific faceted attribute. If the value\n * is omitted then the function checks if there is any excluding refinements.\n *\n * @param  {string}  facet name of the attribute for used for faceting\n * @param  {string}  [value] optional value. If passed will test that this value\n * is filtering the given facet.\n * @return {boolean} true if refined\n * @example\n * helper.isExcludeRefined('color'); // false\n * helper.isExcludeRefined('color', 'blue') // false\n * helper.isExcludeRefined('color', 'red') // false\n *\n * helper.addFacetExclusion('color', 'red');\n *\n * helper.isExcludeRefined('color'); // true\n * helper.isExcludeRefined('color', 'blue') // false\n * helper.isExcludeRefined('color', 'red') // true\n */\nAlgoliaSearchHelper.prototype.isExcluded = function (facet, value) {\n  return this.state.isExcludeRefined(facet, value);\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasRefinements}\n */\nAlgoliaSearchHelper.prototype.isDisjunctiveRefined = function (facet, value) {\n  return this.state.isDisjunctiveFacetRefined(facet, value);\n};\n\n/**\n * Check if the string is a currently filtering tag.\n * @param {string} tag tag to check\n * @return {boolean} true if the tag is currently refined\n */\nAlgoliaSearchHelper.prototype.hasTag = function (tag) {\n  return this.state.isTagRefined(tag);\n};\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasTag}\n */\nAlgoliaSearchHelper.prototype.isTagRefined = function () {\n  return this.hasTagRefinements.apply(this, arguments);\n};\n\n/**\n * Get the name of the currently used index.\n * @return {string} name of the index\n * @example\n * helper.setIndex('highestPrice_products').getIndex();\n * // returns 'highestPrice_products'\n */\nAlgoliaSearchHelper.prototype.getIndex = function () {\n  return this.state.index;\n};\n\nfunction getCurrentPage() {\n  return this.state.page;\n}\n\n/**\n * Get the currently selected page\n * @deprecated\n * @return {number} the current page\n */\nAlgoliaSearchHelper.prototype.getCurrentPage = getCurrentPage;\n/**\n * Get the currently selected page\n * @function\n * @return {number} the current page\n */\nAlgoliaSearchHelper.prototype.getPage = getCurrentPage;\n\n/**\n * Get all the tags currently set to filters the results.\n *\n * @return {string[]} The list of tags currently set.\n */\nAlgoliaSearchHelper.prototype.getTags = function () {\n  return this.state.tagRefinements;\n};\n\n/**\n * Get the list of refinements for a given attribute. This method works with\n * conjunctive, disjunctive, excluding and numerical filters.\n *\n * See also SearchResults#getRefinements\n *\n * @param {string} facetName attribute name used for faceting\n * @return {Array.<FacetRefinement|NumericRefinement>} All Refinement are objects that contain a value, and\n * a type. Numeric also contains an operator.\n * @example\n * helper.addNumericRefinement('price', '>', 100);\n * helper.getRefinements('price');\n * // [\n * //   {\n * //     \"value\": [\n * //       100\n * //     ],\n * //     \"operator\": \">\",\n * //     \"type\": \"numeric\"\n * //   }\n * // ]\n * @example\n * helper.addFacetRefinement('color', 'blue');\n * helper.addFacetExclusion('color', 'red');\n * helper.getRefinements('color');\n * // [\n * //   {\n * //     \"value\": \"blue\",\n * //     \"type\": \"conjunctive\"\n * //   },\n * //   {\n * //     \"value\": \"red\",\n * //     \"type\": \"exclude\"\n * //   }\n * // ]\n * @example\n * helper.addDisjunctiveFacetRefinement('material', 'plastic');\n * // [\n * //   {\n * //     \"value\": \"plastic\",\n * //     \"type\": \"disjunctive\"\n * //   }\n * // ]\n */\nAlgoliaSearchHelper.prototype.getRefinements = function (facetName) {\n  var refinements = [];\n\n  if (this.state.isConjunctiveFacet(facetName)) {\n    var conjRefinements = this.state.getConjunctiveRefinements(facetName);\n\n    conjRefinements.forEach(function (r) {\n      refinements.push({\n        value: r,\n        type: 'conjunctive',\n      });\n    });\n\n    var excludeRefinements = this.state.getExcludeRefinements(facetName);\n\n    excludeRefinements.forEach(function (r) {\n      refinements.push({\n        value: r,\n        type: 'exclude',\n      });\n    });\n  } else if (this.state.isDisjunctiveFacet(facetName)) {\n    var disjunctiveRefinements =\n      this.state.getDisjunctiveRefinements(facetName);\n\n    disjunctiveRefinements.forEach(function (r) {\n      refinements.push({\n        value: r,\n        type: 'disjunctive',\n      });\n    });\n  }\n\n  var numericRefinements = this.state.getNumericRefinements(facetName);\n\n  Object.keys(numericRefinements).forEach(function (operator) {\n    var value = numericRefinements[operator];\n\n    refinements.push({\n      value: value,\n      operator: operator,\n      type: 'numeric',\n    });\n  });\n\n  return refinements;\n};\n\n/**\n * Return the current refinement for the (attribute, operator)\n * @param {string} attribute attribute in the record\n * @param {string} operator operator applied on the refined values\n * @return {Array.<number|number[]>} refined values\n */\nAlgoliaSearchHelper.prototype.getNumericRefinement = function (\n  attribute,\n  operator\n) {\n  return this.state.getNumericRefinement(attribute, operator);\n};\n\n/**\n * Get the current breadcrumb for a hierarchical facet, as an array\n * @param  {string} facetName Hierarchical facet name\n * @return {array.<string>} the path as an array of string\n */\nAlgoliaSearchHelper.prototype.getHierarchicalFacetBreadcrumb = function (\n  facetName\n) {\n  return this.state.getHierarchicalFacetBreadcrumb(facetName);\n};\n\n// /////////// PRIVATE\n\n/**\n * Perform the underlying queries\n * @private\n * @param {object} options options for the query\n * @param {boolean} [options.onlyWithDerivedHelpers=false] if true, only the derived helpers will be queried\n * @return {undefined} does not return anything\n * @fires search\n * @fires result\n * @fires error\n */\nAlgoliaSearchHelper.prototype._search = function (options) {\n  var state = this.state;\n  var states = [];\n  var mainQueries = [];\n\n  if (!options.onlyWithDerivedHelpers) {\n    mainQueries = requestBuilder._getQueries(state.index, state);\n\n    states.push({\n      state: state,\n      queriesCount: mainQueries.length,\n      helper: this,\n    });\n\n    this.emit('search', {\n      state: state,\n      results: this.lastResults,\n    });\n  }\n\n  var derivedQueries = this.derivedHelpers.map(function (derivedHelper) {\n    var derivedState = derivedHelper.getModifiedState(state);\n    var derivedStateQueries = derivedState.index\n      ? requestBuilder._getQueries(derivedState.index, derivedState)\n      : [];\n\n    states.push({\n      state: derivedState,\n      queriesCount: derivedStateQueries.length,\n      helper: derivedHelper,\n    });\n\n    derivedHelper.emit('search', {\n      state: derivedState,\n      results: derivedHelper.lastResults,\n    });\n\n    return derivedStateQueries;\n  });\n\n  var queries = Array.prototype.concat.apply(mainQueries, derivedQueries);\n\n  var queryId = this._queryId++;\n  this._currentNbQueries++;\n\n  if (!queries.length) {\n    return Promise.resolve({ results: [] }).then(\n      this._dispatchAlgoliaResponse.bind(this, states, queryId)\n    );\n  }\n\n  try {\n    this.client\n      .search(queries)\n      .then(this._dispatchAlgoliaResponse.bind(this, states, queryId))\n      .catch(this._dispatchAlgoliaError.bind(this, queryId));\n  } catch (error) {\n    // If we reach this part, we're in an internal error state\n    this.emit('error', {\n      error: error,\n    });\n  }\n\n  return undefined;\n};\n\n/**\n * Transform the responses as sent by the server and transform them into a user\n * usable object that merge the results of all the batch requests. It will dispatch\n * over the different helper + derived helpers (when there are some).\n * @private\n * @param {array.<{SearchParameters, AlgoliaQueries, AlgoliaSearchHelper}>} states state used to generate the request\n * @param {number} queryId id of the current request\n * @param {object} content content of the response\n * @return {undefined}\n */\nAlgoliaSearchHelper.prototype._dispatchAlgoliaResponse = function (\n  states,\n  queryId,\n  content\n) {\n  // @TODO remove the number of outdated queries discarded instead of just one\n\n  if (queryId < this._lastQueryIdReceived) {\n    // Outdated answer\n    return;\n  }\n\n  this._currentNbQueries -= queryId - this._lastQueryIdReceived;\n  this._lastQueryIdReceived = queryId;\n\n  if (this._currentNbQueries === 0) this.emit('searchQueueEmpty');\n\n  var results = content.results.slice();\n\n  states.forEach(function (s) {\n    var state = s.state;\n    var queriesCount = s.queriesCount;\n    var helper = s.helper;\n    var specificResults = results.splice(0, queriesCount);\n\n    if (!state.index) {\n      helper.emit('result', {\n        results: null,\n        state: state,\n      });\n      return;\n    }\n\n    helper.lastResults = new SearchResults(state, specificResults);\n\n    helper.emit('result', {\n      results: helper.lastResults,\n      state: state,\n    });\n  });\n};\n\nAlgoliaSearchHelper.prototype._dispatchAlgoliaError = function (\n  queryId,\n  error\n) {\n  if (queryId < this._lastQueryIdReceived) {\n    // Outdated answer\n    return;\n  }\n\n  this._currentNbQueries -= queryId - this._lastQueryIdReceived;\n  this._lastQueryIdReceived = queryId;\n\n  this.emit('error', {\n    error: error,\n  });\n\n  if (this._currentNbQueries === 0) this.emit('searchQueueEmpty');\n};\n\nAlgoliaSearchHelper.prototype.containsRefinement = function (\n  query,\n  facetFilters,\n  numericFilters,\n  tagFilters\n) {\n  return (\n    query ||\n    facetFilters.length !== 0 ||\n    numericFilters.length !== 0 ||\n    tagFilters.length !== 0\n  );\n};\n\n/**\n * Test if there are some disjunctive refinements on the facet\n * @private\n * @param {string} facet the attribute to test\n * @return {boolean} true if there are refinements on this attribute\n */\nAlgoliaSearchHelper.prototype._hasDisjunctiveRefinements = function (facet) {\n  return (\n    this.state.disjunctiveRefinements[facet] &&\n    this.state.disjunctiveRefinements[facet].length > 0\n  );\n};\n\nAlgoliaSearchHelper.prototype._change = function (event) {\n  var state = event.state;\n  var isPageReset = event.isPageReset;\n\n  if (state !== this.state) {\n    this.state = state;\n\n    this.emit('change', {\n      state: this.state,\n      results: this.lastResults,\n      isPageReset: isPageReset,\n    });\n  }\n};\n\n/**\n * Clears the cache of the underlying Algolia client.\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n */\nAlgoliaSearchHelper.prototype.clearCache = function () {\n  if (this.client.clearCache) this.client.clearCache();\n  return this;\n};\n\n/**\n * Updates the internal client instance. If the reference of the clients\n * are equal then no update is actually done.\n * @param  {AlgoliaSearch} newClient an AlgoliaSearch client\n * @return {AlgoliaSearchHelper} Method is chainable, it returns itself\n */\nAlgoliaSearchHelper.prototype.setClient = function (newClient) {\n  if (this.client === newClient) return this;\n\n  if (typeof newClient.addAlgoliaAgent === 'function') {\n    newClient.addAlgoliaAgent('JS Helper (' + version + ')');\n  }\n  this.client = newClient;\n\n  return this;\n};\n\n/**\n * Gets the instance of the currently used client.\n * @return {AlgoliaSearch} the currently used client\n */\nAlgoliaSearchHelper.prototype.getClient = function () {\n  return this.client;\n};\n\n/**\n * Creates an derived instance of the Helper. A derived helper\n * is a way to request other indices synchronised with the lifecycle\n * of the main Helper. This mechanism uses the multiqueries feature\n * of Algolia to aggregate all the requests in a single network call.\n *\n * This method takes a function that is used to create a new SearchParameter\n * that will be used to create requests to Algolia. Those new requests\n * are created just before the `search` event. The signature of the function\n * is `SearchParameters -> SearchParameters`.\n *\n * This method returns a new DerivedHelper which is an EventEmitter\n * that fires the same `search`, `result` and `error` events. Those\n * events, however, will receive data specific to this DerivedHelper\n * and the SearchParameters that is returned by the call of the\n * parameter function.\n * @param {function} fn SearchParameters -> SearchParameters\n * @return {DerivedHelper} a new DerivedHelper\n */\nAlgoliaSearchHelper.prototype.derive = function (fn) {\n  var derivedHelper = new DerivedHelper(this, fn);\n  this.derivedHelpers.push(derivedHelper);\n  return derivedHelper;\n};\n\n/**\n * This method detaches a derived Helper from the main one. Prefer using the one from the\n * derived helper itself, to remove the event listeners too.\n * @private\n * @param  {DerivedHelper} derivedHelper the derived helper to detach\n * @return {undefined} nothing is returned\n * @throws Error\n */\nAlgoliaSearchHelper.prototype.detachDerivedHelper = function (derivedHelper) {\n  var pos = this.derivedHelpers.indexOf(derivedHelper);\n  if (pos === -1) throw new Error('Derived helper already detached');\n  this.derivedHelpers.splice(pos, 1);\n};\n\n/**\n * This method returns true if there is currently at least one on-going search.\n * @return {boolean} true if there is a search pending\n */\nAlgoliaSearchHelper.prototype.hasPendingRequests = function () {\n  return this._currentNbQueries > 0;\n};\n\n/**\n * @typedef AlgoliaSearchHelper.NumericRefinement\n * @type {object}\n * @property {number[]} value the numbers that are used for filtering this attribute with\n * the operator specified.\n * @property {string} operator the faceting data: value, number of entries\n * @property {string} type will be 'numeric'\n */\n\n/**\n * @typedef AlgoliaSearchHelper.FacetRefinement\n * @type {object}\n * @property {string} value the string use to filter the attribute\n * @property {string} type the type of filter: 'conjunctive', 'disjunctive', 'exclude'\n */\n\nmodule.exports = AlgoliaSearchHelper;\n","'use strict';\n\nvar AlgoliaSearchHelper = require('./src/algoliasearch.helper');\nvar SearchParameters = require('./src/SearchParameters');\nvar SearchResults = require('./src/SearchResults');\n\n/**\n * The algoliasearchHelper module is the function that will let its\n * contains everything needed to use the Algoliasearch\n * Helper. It is a also a function that instanciate the helper.\n * To use the helper, you also need the Algolia JS client v3.\n * @example\n * //using the UMD build\n * var client = algoliasearch('latency', '6be0576ff61c053d5f9a3225e2a90f76');\n * var helper = algoliasearchHelper(client, 'bestbuy', {\n *   facets: ['shipping'],\n *   disjunctiveFacets: ['category']\n * });\n * helper.on('result', function(event) {\n *   console.log(event.results);\n * });\n * helper\n *   .toggleFacetRefinement('category', 'Movies & TV Shows')\n *   .toggleFacetRefinement('shipping', 'Free shipping')\n *   .search();\n * @example\n * // The helper is an event emitter using the node API\n * helper.on('result', updateTheResults);\n * helper.once('result', updateTheResults);\n * helper.removeListener('result', updateTheResults);\n * helper.removeAllListeners('result');\n * @module algoliasearchHelper\n * @param  {AlgoliaSearch} client an AlgoliaSearch client\n * @param  {string} index the name of the index to query\n * @param  {SearchParameters|object} opts an object defining the initial config of the search. It doesn't have to be a {SearchParameters}, just an object containing the properties you need from it.\n * @return {AlgoliaSearchHelper} The helper instance\n */\nfunction algoliasearchHelper(client, index, opts) {\n  return new AlgoliaSearchHelper(client, index, opts);\n}\n\n/**\n * The version currently used\n * @member module:algoliasearchHelper.version\n * @type {number}\n */\nalgoliasearchHelper.version = require('./src/version');\n\n/**\n * Constructor for the Helper.\n * @member module:algoliasearchHelper.AlgoliaSearchHelper\n * @type {AlgoliaSearchHelper}\n */\nalgoliasearchHelper.AlgoliaSearchHelper = AlgoliaSearchHelper;\n\n/**\n * Constructor for the object containing all the parameters of the search.\n * @member module:algoliasearchHelper.SearchParameters\n * @type {SearchParameters}\n */\nalgoliasearchHelper.SearchParameters = SearchParameters;\n\n/**\n * Constructor for the object containing the results of the search.\n * @member module:algoliasearchHelper.SearchResults\n * @type {SearchResults}\n */\nalgoliasearchHelper.SearchResults = SearchResults;\n\nmodule.exports = algoliasearchHelper;\n","import algoliasearchHelper from 'algoliasearch-helper';\n\nimport createConnector from '../core/createConnector';\nimport {\n  refineValue,\n  getIndexId,\n  hasMultipleIndices,\n  // @ts-ignore\n} from '../core/indexUtils';\nimport {\n  omit,\n  getObjectType,\n  getPropertyByPath,\n  removeEmptyKey,\n  removeEmptyArraysFromObject,\n} from '../core/utils';\n\nimport type { ConnectedProps } from '../core/createConnector';\nimport type {\n  PlainSearchParameters,\n  SearchParameters,\n} from 'algoliasearch-helper';\n\ntype Hit = any;\n\nexport type MatchingPatterns = {\n  [attribute: string]: {\n    /**\n     * The score of the optional filter.\n     *\n     * @see https://www.algolia.com/doc/guides/managing-results/rules/merchandising-and-promoting/in-depth/optional-filters/\n     */\n    score: number;\n  };\n};\n\ninterface ConfigureRelatedItemsProps {\n  /**\n   * The reference hit to extract the filters from.\n   */\n  hit: Hit;\n  /**\n   * The schema to create the optional filters.\n   * Each key represents an attribute from the hit.\n   */\n  matchingPatterns: MatchingPatterns;\n  /**\n   * Function to transform the generated search parameters.\n   */\n  transformSearchParameters?: (\n    searchParameters: SearchParameters\n  ) => PlainSearchParameters;\n}\n\nfunction createOptionalFilter({\n  attributeName,\n  attributeValue,\n  attributeScore,\n}: {\n  attributeName: string;\n  attributeValue: string;\n  attributeScore: number;\n}) {\n  return `${attributeName}:${attributeValue}<score=${attributeScore || 1}>`;\n}\n\nconst defaultProps: Partial<ConfigureRelatedItemsProps> = {\n  transformSearchParameters: (x) => ({ ...x }),\n};\n\nfunction getId(): string {\n  // We store the search state of this widget in `configure`.\n  return 'configure';\n}\n\ntype InternalConfigureRelatedItemsProps = ConfigureRelatedItemsProps &\n  Required<typeof defaultProps>;\n\nfunction getSearchParametersFromProps(\n  props: ConnectedProps<InternalConfigureRelatedItemsProps>\n): PlainSearchParameters {\n  const optionalFilters = Object.keys(props.matchingPatterns).reduce<\n    Array<string | string[]>\n  >((acc, attributeName) => {\n    const attributePattern = props.matchingPatterns[attributeName];\n    const attributeValue = getPropertyByPath(props.hit, attributeName);\n    const attributeScore = attributePattern.score;\n\n    if (Array.isArray(attributeValue)) {\n      return [\n        ...acc,\n        attributeValue.map((attributeSubValue) => {\n          return createOptionalFilter({\n            attributeName,\n            attributeValue: attributeSubValue,\n            attributeScore,\n          });\n        }),\n      ];\n    }\n\n    if (typeof attributeValue === 'string') {\n      return [\n        ...acc,\n        createOptionalFilter({\n          attributeName,\n          attributeValue,\n          attributeScore,\n        }),\n      ];\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The \\`matchingPatterns\\` option returned a value of type ${getObjectType(\n          attributeValue\n        )} for the \"${attributeName}\" key. This value was not sent to Algolia because \\`optionalFilters\\` only supports strings and array of strings.\n\nYou can remove the \"${attributeName}\" key from the \\`matchingPatterns\\` option.\n\nSee https://www.algolia.com/doc/api-reference/api-parameters/optionalFilters/`\n      );\n    }\n\n    return acc;\n  }, []);\n\n  return props.transformSearchParameters(\n    new algoliasearchHelper.SearchParameters({\n      // @ts-ignore @TODO algoliasearch-helper@3.0.1 will contain the type\n      // `sumOrFiltersScores`.\n      // See https://github.com/algolia/algoliasearch-helper-js/pull/753\n      sumOrFiltersScores: true,\n      facetFilters: [`objectID:-${props.hit.objectID}`],\n      optionalFilters,\n    })\n  );\n}\n\ninterface ConnectorState {\n  _searchParameters: PlainSearchParameters;\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaConfigureRelatedItems',\n  $$type: 'ais.configureRelatedItems',\n\n  defaultProps,\n\n  getProvidedProps() {\n    return {};\n  },\n\n  getSearchParameters(\n    searchParameters: SearchParameters,\n    props: ConnectedProps<InternalConfigureRelatedItemsProps>\n  ) {\n    return searchParameters.setQueryParameters(\n      getSearchParametersFromProps(props)\n    );\n  },\n\n  transitionState(\n    this: ConnectorState,\n    props,\n    _prevSearchState,\n    nextSearchState\n  ) {\n    const id = getId();\n    // We need to transform the exhaustive search parameters back to clean\n    // search parameters without the empty default keys so we don't pollute the\n    // `configure` search state.\n    const searchParameters = removeEmptyArraysFromObject(\n      removeEmptyKey(getSearchParametersFromProps(props))\n    );\n\n    const searchParametersKeys = Object.keys(searchParameters);\n    const nonPresentKeys = this._searchParameters\n      ? Object.keys(this._searchParameters).filter(\n          (prop) => searchParametersKeys.indexOf(prop) === -1\n        )\n      : [];\n    this._searchParameters = searchParameters;\n    const nextValue: any = {\n      [id]: {\n        ...omit(nextSearchState[id], nonPresentKeys),\n        ...searchParameters,\n      },\n    };\n\n    return refineValue(nextSearchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(this: ConnectorState, props, searchState) {\n    const id = getId();\n    const indexId = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const subState =\n      hasMultipleIndices({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }) && searchState.indices\n        ? searchState.indices[indexId]\n        : searchState;\n\n    const configureKeys =\n      subState && subState[id] ? Object.keys(subState[id]) : [];\n\n    const configureState = (\n      configureKeys as Array<keyof PlainSearchParameters>\n    ).reduce((acc, item) => {\n      if (!this._searchParameters[item]) {\n        (acc as any)[item] = subState[id][item];\n      }\n\n      return acc;\n    }, {} as PlainSearchParameters);\n\n    const nextValue = { [id]: configureState };\n\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport connectConfigureRelatedItems from '../connectors/connectConfigureRelatedItems';\n\nfunction ConfigureRelatedItems() {\n  return null;\n}\n\nConfigureRelatedItems.propTypes = {\n  hit: PropTypes.object.isRequired,\n  matchingPatterns: PropTypes.object.isRequired,\n  transformSearchParameters: PropTypes.func,\n};\n\nexport default connectConfigureRelatedItems(ConfigureRelatedItems, {\n  $$widgetType: 'ais.configureRelatedItems',\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\n// @ts-ignore\nimport { getResults } from '../core/indexUtils';\n\nimport type { SearchParameters } from 'algoliasearch-helper';\n\nconst MAX_WILDCARD_FACETS = 20;\n\nexport default createConnector({\n  displayName: 'AlgoliaDynamicWidgets',\n  $$type: 'ais.dynamicWidgets',\n\n  defaultProps: {\n    transformItems: (items: any[]) => items,\n    maxValuesPerFacet: 20,\n  },\n\n  propTypes: {\n    transformItems: PropTypes.func,\n    facets: PropTypes.arrayOf(PropTypes.string),\n    maxValuesPerFacet: PropTypes.number,\n  },\n\n  getProvidedProps(props, _searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (\n      props.facets &&\n      !(\n        Array.isArray(props.facets) &&\n        props.facets.length <= 1 &&\n        (props.facets[0] === '*' || props.facets[0] === undefined)\n      )\n    ) {\n      throw new Error(\n        `The \\`facets\\` prop only accepts [] or [\"*\"], you passed ${JSON.stringify(\n          props.facets\n        )}`\n      );\n    }\n\n    if (!results) {\n      return { attributesToRender: [] };\n    }\n\n    const facetOrder =\n      (results.renderingContent &&\n        results.renderingContent.facetOrdering &&\n        results.renderingContent.facetOrdering.facets &&\n        results.renderingContent.facetOrdering.facets.order) ||\n      [];\n\n    const attributesToRender = props.transformItems(facetOrder, { results });\n\n    if (attributesToRender.length > MAX_WILDCARD_FACETS && !props.facets) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `More than ${MAX_WILDCARD_FACETS} facets are requested to be displayed without explicitly setting which facets to retrieve. This could have a performance impact. Set \"facets\" to [] to do two smaller network requests, or explicitly to ['*'] to avoid this warning.`\n      );\n    }\n\n    if (props.maxValuesPerFacet < results._state.maxValuesPerFacet) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The maxValuesPerFacet set by dynamic widgets (${props.maxValuesPerFacet}) is smaller than one of the limits set by a widget (${results._state.maxValuesPerFacet}). This causes a mismatch in query parameters and thus an extra network request when that widget is mounted.`\n      );\n    }\n\n    return {\n      attributesToRender,\n    };\n  },\n\n  getSearchParameters(searchParameters, props) {\n    return (props.facets || ['*']).reduce(\n      (acc: SearchParameters, curr: string) => acc.addFacet(curr),\n      searchParameters.setQueryParameters({\n        maxValuesPerFacet: Math.max(\n          props.maxValuesPerFacet || 0,\n          searchParameters.maxValuesPerFacet || 0\n        ),\n      })\n    );\n  },\n});\n","import React, { Fragment } from 'react';\n\nimport connectDynamicWidgets from '../connectors/connectDynamicWidgets';\nimport { getDisplayName } from '../core/utils';\n\nimport type { ComponentType, ReactElement, ReactNode } from 'react';\n\nfunction isReactElement(element: any): element is ReactElement {\n  return typeof element === 'object' && element.props;\n}\n\nfunction getAttribute(element: ReactNode): string | undefined {\n  if (!isReactElement(element)) {\n    return undefined;\n  }\n\n  if (element.props.attribute) {\n    return element.props.attribute;\n  }\n  if (Array.isArray(element.props.attributes)) {\n    return element.props.attributes[0];\n  }\n  if (element.props.children) {\n    return getAttribute(React.Children.only(element.props.children));\n  }\n\n  return undefined;\n}\n\ntype DynamicWidgetsProps = {\n  children: ReactNode;\n  attributesToRender: string[];\n  fallbackComponent?: ComponentType<{ attribute: string }>;\n};\n\nfunction DynamicWidgets({\n  children,\n  attributesToRender,\n  fallbackComponent: Fallback = () => null,\n}: DynamicWidgetsProps) {\n  const widgets: Map<string, ReactNode> = new Map();\n\n  React.Children.forEach(children, (child) => {\n    const attribute = getAttribute(child);\n    if (!attribute) {\n      throw new Error(\n        `Could not find \"attribute\" prop for ${getDisplayName(child)}.`\n      );\n    }\n    widgets.set(attribute, child);\n  });\n\n  // on initial render this will be empty, but React InstantSearch keeps\n  // search state for unmounted components in place, so routing works.\n  return (\n    <>\n      {attributesToRender.map((attribute) => (\n        <Fragment key={attribute}>\n          {widgets.get(attribute) || <Fallback attribute={attribute} />}\n        </Fragment>\n      ))}\n    </>\n  );\n}\n\nexport default connectDynamicWidgets(DynamicWidgets, {\n  $$widgetType: 'ais.dynamicWidgets',\n});\n","import createConnector from '../core/createConnector';\n// @ts-ignore\nimport { getResults, getIndexId, hasMultipleIndices } from '../core/indexUtils';\n\nimport type { ConnectedProps } from '../core/createConnector';\n\ntype SearchState = any;\n\ntype SearchParameters = any;\n\nexport type CustomUserData = {\n  [key: string]: any;\n};\n\ntype TrackedFilterRefinement = string | number | boolean;\n\nexport type QueryRulesProps<TItem = CustomUserData> = {\n  trackedFilters: {\n    [facetName: string]: (\n      facetValues: TrackedFilterRefinement[]\n    ) => TrackedFilterRefinement[];\n  };\n  transformRuleContexts: (ruleContexts: string[]) => string[];\n  transformItems: (items: TItem[]) => TItem[];\n};\n\n// A context rule must consist only of alphanumeric characters, hyphens, and underscores.\n// See https://www.algolia.com/doc/guides/managing-results/refine-results/merchandising-and-promoting/in-depth/implementing-query-rules/#context\nfunction escapeRuleContext(ruleName: string): string {\n  return ruleName.replace(/[^a-z0-9-_]+/gi, '_');\n}\n\nfunction getWidgetRefinements(\n  attribute: string,\n  widgetKey: string,\n  searchState: SearchState\n): TrackedFilterRefinement[] {\n  const widgetState = searchState[widgetKey];\n\n  switch (widgetKey) {\n    case 'range':\n      return Object.keys(widgetState[attribute]).map(\n        (rangeKey) => widgetState[attribute][rangeKey]\n      );\n\n    case 'refinementList':\n      return widgetState[attribute];\n\n    case 'hierarchicalMenu':\n      return [widgetState[attribute]];\n\n    case 'menu':\n      return [widgetState[attribute]];\n\n    case 'multiRange':\n      return widgetState[attribute].split(':');\n\n    case 'toggle':\n      return [widgetState[attribute]];\n\n    default:\n      return [];\n  }\n}\n\nfunction getRefinements(\n  attribute: string,\n  searchState: SearchState = {}\n): TrackedFilterRefinement[] {\n  const refinements = Object.keys(searchState)\n    .filter(\n      (widgetKey) =>\n        searchState[widgetKey] !== undefined &&\n        searchState[widgetKey][attribute] !== undefined\n    )\n    .map((widgetKey) => getWidgetRefinements(attribute, widgetKey, searchState))\n    .reduce((acc, current) => acc.concat(current), []); // flatten the refinements\n\n  return refinements;\n}\n\nfunction getRuleContextsFromTrackedFilters({\n  searchState,\n  trackedFilters,\n}: {\n  searchState: SearchState;\n  trackedFilters: QueryRulesProps['trackedFilters'];\n}) {\n  const ruleContexts = Object.keys(trackedFilters).reduce<string[]>(\n    (facets, facetName) => {\n      const facetRefinements: TrackedFilterRefinement[] = getRefinements(\n        facetName,\n        searchState\n      );\n\n      const getTrackedFacetValues = trackedFilters[facetName];\n      const trackedFacetValues = getTrackedFacetValues(facetRefinements);\n\n      return [\n        ...facets,\n        ...facetRefinements\n          .filter((facetRefinement) =>\n            trackedFacetValues.includes(facetRefinement)\n          )\n          .map((facetValue) =>\n            escapeRuleContext(`ais-${facetName}-${facetValue}`)\n          ),\n      ];\n    },\n    []\n  );\n\n  return ruleContexts;\n}\n\nconst defaultProps: QueryRulesProps = {\n  transformItems: (items) => items,\n  transformRuleContexts: (ruleContexts) => ruleContexts,\n  trackedFilters: {},\n};\n\nexport default createConnector({\n  displayName: 'AlgoliaQueryRules',\n  $$type: 'ais.queryRules',\n\n  defaultProps,\n\n  getProvidedProps(\n    props: ConnectedProps<QueryRulesProps>,\n    _1: any,\n    searchResults: any\n  ) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (results === null) {\n      return {\n        items: [],\n        canRefine: false,\n      };\n    }\n\n    const { userData = [] } = results;\n    const { transformItems } = props;\n    const transformedItems = transformItems(userData);\n\n    return {\n      items: transformedItems,\n      canRefine: transformedItems.length > 0,\n    };\n  },\n\n  getSearchParameters(\n    searchParameters: SearchParameters,\n    props: ConnectedProps<QueryRulesProps>,\n    searchState: SearchState\n  ) {\n    if (Object.keys(props.trackedFilters).length === 0) {\n      return searchParameters;\n    }\n\n    const indexSearchState =\n      hasMultipleIndices({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }) && searchState.indices\n        ? searchState.indices[\n            getIndexId({\n              ais: props.contextValue,\n              multiIndexContext: props.indexContextValue,\n            })\n          ]\n        : searchState;\n\n    const newRuleContexts = getRuleContextsFromTrackedFilters({\n      searchState: indexSearchState,\n      trackedFilters: props.trackedFilters,\n    });\n\n    const initialRuleContexts = searchParameters.ruleContexts || [];\n    const nextRuleContexts = [...initialRuleContexts, ...newRuleContexts];\n\n    if (process.env.NODE_ENV === 'development') {\n      if (nextRuleContexts.length > 10) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `The maximum number of \\`ruleContexts\\` is 10. They have been sliced to that limit.\nConsider using \\`transformRuleContexts\\` to minimize the number of rules sent to Algolia.`\n        );\n      }\n    }\n\n    const ruleContexts = props\n      .transformRuleContexts(nextRuleContexts)\n      .slice(0, 10);\n\n    return searchParameters.setQueryParameter('ruleContexts', ruleContexts);\n  },\n});\n","import connectQueryRules from '../connectors/connectQueryRules';\n\nexport default connectQueryRules(\n  function QueryRuleContext() {\n    return null;\n  },\n  { $$widgetType: 'ais.queryRuleContext' }\n);\n","import PropTypes from 'prop-types';\nimport React, { Component, Children } from 'react';\n\nimport { InstantSearchConsumer, IndexProvider } from '../core/context';\n\nimport type { InstantSearchContext, IndexContext } from '../core/context';\nimport type { SearchParameters } from 'algoliasearch-helper';\n\nfunction getIndexContext(props: Props): IndexContext {\n  return {\n    targetedIndex: props.indexId,\n  };\n}\n\ntype Props = {\n  indexName: string;\n  indexId: string;\n  children?: React.ReactNode;\n};\n\ntype InnerProps = Props & { contextValue: InstantSearchContext };\n\ntype State = {\n  indexContext: IndexContext;\n};\n\n/**\n * The component that allows you to apply widgets to a dedicated index. It's\n * useful if you want to build an interface that targets multiple indices.\n *\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, Index, SearchBox, Hits, Configure } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n *\n * const App = () => (\n *   <InstantSearch\n *     searchClient={searchClient}\n *     indexName=\"instant_search\"\n *   >\n *     <Configure hitsPerPage={5} />\n *     <SearchBox />\n *     <Index indexName=\"instant_search\">\n *       <Hits />\n *     </Index>\n *     <Index indexName=\"bestbuy\">\n *       <Hits />\n *     </Index>\n *   </InstantSearch>\n * );\n */\nclass Index extends Component<InnerProps, State> {\n  static propTypes = {\n    indexName: PropTypes.string.isRequired,\n    indexId: PropTypes.string.isRequired,\n    children: PropTypes.node,\n  };\n\n  static displayName = 'AlgoliaIndex';\n  static $$type = 'ais.index';\n  static $$widgetType = 'ais.index';\n\n  static getDerivedStateFromProps(props: InnerProps) {\n    return {\n      indexContext: getIndexContext(props),\n    };\n  }\n\n  state = {\n    indexContext: getIndexContext(this.props),\n  };\n\n  unregisterWidget?: () => void;\n\n  constructor(props: InnerProps) {\n    super(props);\n\n    this.props.contextValue.onSearchParameters(\n      this.getSearchParameters.bind(this),\n      {\n        ais: this.props.contextValue,\n        multiIndexContext: this.state.indexContext,\n      },\n      this.props,\n      undefined,\n      Index.displayName\n    );\n  }\n\n  componentDidMount() {\n    this.unregisterWidget =\n      this.props.contextValue.widgetsManager.registerWidget(this);\n  }\n\n  componentDidUpdate(prevProps: InnerProps) {\n    if (this.props.indexName !== prevProps.indexName) {\n      this.props.contextValue.widgetsManager.update();\n    }\n  }\n\n  componentWillUnmount() {\n    if (typeof this.unregisterWidget === 'function') {\n      this.unregisterWidget();\n    }\n  }\n\n  getSearchParameters(searchParameters: SearchParameters, props: InnerProps) {\n    return searchParameters.setIndex(\n      this.props ? this.props.indexName : props.indexName\n    );\n  }\n\n  render() {\n    const childrenCount = Children.count(this.props.children);\n    if (childrenCount === 0) {\n      return null;\n    }\n    return (\n      <IndexProvider value={this.state.indexContext}>\n        {this.props.children}\n      </IndexProvider>\n    );\n  }\n}\n\ntype IndexWrapperProps = {\n  indexName: string;\n  indexId?: string;\n};\n\nconst IndexWrapper: React.FC<IndexWrapperProps> = (props) => {\n  const inferredIndexId = props.indexName;\n  return (\n    <InstantSearchConsumer>\n      {(contextValue) => (\n        <Index\n          contextValue={contextValue}\n          indexId={inferredIndexId}\n          {...props}\n        />\n      )}\n    </InstantSearchConsumer>\n  );\n};\n\nIndexWrapper.propTypes = {\n  indexName: PropTypes.string.isRequired,\n  indexId: PropTypes.string,\n};\n\nexport const IndexComponentWithoutContext = Index;\nexport default IndexWrapper;\n","import algoliasearchHelper from 'algoliasearch-helper';\nimport { version as ReactVersion } from 'react';\n\nimport createStore from './createStore';\nimport createWidgetsManager from './createWidgetsManager';\nimport { HIGHLIGHT_TAGS } from './highlight';\nimport { hasMultipleIndices } from './indexUtils';\nimport version from './version';\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(`react (${ReactVersion})`);\n    searchClient.addAlgoliaAgent(`react-instantsearch (${version})`);\n  }\n}\n\nconst isMultiIndexContext = (widget) =>\n  hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue,\n  });\nconst isTargetedIndexEqualIndex = (widget, indexId) =>\n  widget.props.indexContextValue.targetedIndex === indexId;\n\n// Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\nconst isIndexWidget = (widget) => Boolean(widget.props.indexId);\nconst isIndexWidgetEqualIndex = (widget, indexId) =>\n  widget.props.indexId === indexId;\n\nconst sortIndexWidgetsFirst = (firstWidget, secondWidget) => {\n  const isFirstWidgetIndex = isIndexWidget(firstWidget);\n  const isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n  return 0;\n};\n\n// This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\nfunction serializeQueryParameters(parameters) {\n  const isObjectOrArray = (value) =>\n    Object.prototype.toString.call(value) === '[object Object]' ||\n    Object.prototype.toString.call(value) === '[object Array]';\n\n  const encode = (format, ...args) => {\n    let i = 0;\n    return format.replace(/%s/g, () => encodeURIComponent(args[i++]));\n  };\n\n  return Object.keys(parameters)\n    .map((key) =>\n      encode(\n        '%s=%s',\n        key,\n        isObjectOrArray(parameters[key])\n          ? JSON.stringify(parameters[key])\n          : parameters[key]\n      )\n    )\n    .join('&');\n}\n\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\nexport default function createInstantSearchManager({\n  indexName,\n  initialState = {},\n  searchClient,\n  resultsState,\n  stalledSearchDelay,\n}) {\n  const helper = algoliasearchHelper(searchClient, indexName, {\n    ...HIGHLIGHT_TAGS,\n  });\n\n  addAlgoliaAgents(searchClient);\n\n  helper\n    .on('search', handleNewSearch)\n    .on('result', handleSearchSuccess({ indexId: indexName }))\n    .on('error', handleSearchError);\n\n  let skip = false;\n  let stalledSearchTimer = null;\n  let initialSearchParameters = helper.state;\n  let searchCounter;\n\n  const widgetsManager = createWidgetsManager(onWidgetsUpdate);\n\n  hydrateSearchClient(searchClient, resultsState);\n\n  const store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false,\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager\n      .getWidgets()\n      .filter((widget) => Boolean(widget.getMetadata))\n      .map((widget) => widget.getMetadata(state));\n  }\n\n  function getSearchParameters() {\n    const sharedParameters = widgetsManager\n      .getWidgets()\n      .filter((widget) => Boolean(widget.getSearchParameters))\n      .filter(\n        (widget) => !isMultiIndexContext(widget) && !isIndexWidget(widget)\n      )\n      .reduce(\n        (res, widget) => widget.getSearchParameters(res),\n        initialSearchParameters\n      );\n\n    const mainParameters = widgetsManager\n      .getWidgets()\n      .filter((widget) => Boolean(widget.getSearchParameters))\n      .filter((widget) => {\n        const targetedIndexEqualMainIndex =\n          isMultiIndexContext(widget) &&\n          isTargetedIndexEqualIndex(widget, indexName);\n\n        const subIndexEqualMainIndex =\n          isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n\n        return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n      })\n      // We have to sort the `Index` widgets first so the `index` parameter\n      // is correctly set in the `reduce` function for the following widgets\n      .sort(sortIndexWidgetsFirst)\n      .reduce(\n        (res, widget) => widget.getSearchParameters(res),\n        sharedParameters\n      );\n\n    const derivedIndices = widgetsManager\n      .getWidgets()\n      .filter((widget) => Boolean(widget.getSearchParameters))\n      .filter((widget) => {\n        const targetedIndexNotEqualMainIndex =\n          isMultiIndexContext(widget) &&\n          !isTargetedIndexEqualIndex(widget, indexName);\n\n        const subIndexNotEqualMainIndex =\n          isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n\n        return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n      })\n      // We have to sort the `Index` widgets first so the `index` parameter\n      // is correctly set in the `reduce` function for the following widgets\n      .sort(sortIndexWidgetsFirst)\n      .reduce((indices, widget) => {\n        const indexId = isMultiIndexContext(widget)\n          ? widget.props.indexContextValue.targetedIndex\n          : widget.props.indexId;\n\n        const widgets = indices[indexId] || [];\n\n        return {\n          ...indices,\n          [indexId]: widgets.concat(widget),\n        };\n      }, {});\n\n    const derivedParameters = Object.keys(derivedIndices).map((indexId) => ({\n      parameters: derivedIndices[indexId].reduce(\n        (res, widget) => widget.getSearchParameters(res),\n        sharedParameters\n      ),\n      indexId,\n    }));\n\n    return {\n      mainParameters,\n      derivedParameters,\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      const { mainParameters, derivedParameters } = getSearchParameters(\n        helper.state\n      );\n\n      searchCounter = derivedParameters.length + 1;\n\n      // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n      helper.derivedHelpers.slice().forEach((derivedHelper) => {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n\n      derivedParameters.forEach(({ indexId, parameters }) => {\n        const derivedHelper = helper.derive(() => parameters);\n\n        derivedHelper\n          .on('result', handleSearchSuccess({ indexId }))\n          .on('error', handleSearchError);\n      });\n\n      helper.setState(mainParameters);\n\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess({ indexId }) {\n    return (event) => {\n      searchCounter--;\n\n      const state = store.getState();\n      const isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n\n      let results = state.results ? state.results : {};\n\n      // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = { ...results, [indexId]: event.results };\n      } else {\n        results = event.results;\n      }\n\n      const currentState = store.getState();\n      let nextIsSearchStalled = currentState.isSearchStalled;\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      const { resultsFacetValues, ...partialState } = currentState;\n\n      store.setState({\n        ...partialState,\n        results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: searchCounter > 0,\n        error: null,\n      });\n    };\n  }\n\n  function handleSearchError({ error }) {\n    const currentState = store.getState();\n\n    let nextIsSearchStalled = currentState.isSearchStalled;\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    const { resultsFacetValues, ...partialState } = currentState;\n\n    store.setState({\n      ...partialState,\n      isSearchStalled: nextIsSearchStalled,\n      error,\n      searching: false,\n    });\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(() => {\n        const { resultsFacetValues, ...partialState } = store.getState();\n\n        store.setState({\n          ...partialState,\n          isSearchStalled: true,\n        });\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    }\n\n    // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n    if (\n      (!client.transporter || client._cacheHydrated) &&\n      (!client._useCache || typeof client.addAlgoliaAgent !== 'function')\n    ) {\n      return;\n    }\n\n    // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n\n      const baseMethod = client.search;\n      client.search = (requests, ...methodArgs) => {\n        const requestsWithSerializedParams = requests.map((request) => ({\n          ...request,\n          params: serializeQueryParameters(request.params),\n        }));\n\n        return client.transporter.responsesCache.get(\n          {\n            method: 'search',\n            args: [requestsWithSerializedParams, ...methodArgs],\n          },\n          () => {\n            return baseMethod(requests, ...methodArgs);\n          }\n        );\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set(\n        {\n          method: 'search',\n          args: [\n            results.reduce(\n              (acc, result) =>\n                acc.concat(\n                  result.rawResults.map((request) => ({\n                    indexName: request.index,\n                    params: request.params,\n                  }))\n                ),\n              []\n            ),\n          ],\n        },\n        {\n          results: results.reduce(\n            (acc, result) => acc.concat(result.rawResults),\n            []\n          ),\n        }\n      );\n      return;\n    }\n\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    const key = `/1/indexes/*/queries_body_${JSON.stringify({\n      requests: results.reduce(\n        (acc, result) =>\n          acc.concat(\n            result.rawResults.map((request) => ({\n              indexName: request.index,\n              params: request.params,\n            }))\n          ),\n        []\n      ),\n    })}`;\n\n    client.cache = {\n      ...client.cache,\n      [key]: JSON.stringify({\n        results: results.reduce(\n          (acc, result) => acc.concat(result.rawResults),\n          []\n        ),\n      }),\n    };\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set(\n        {\n          method: 'search',\n          args: [\n            results.rawResults.map((request) => ({\n              indexName: request.index,\n              params: request.params,\n            })),\n          ],\n        },\n        {\n          results: results.rawResults,\n        }\n      );\n      return;\n    }\n    // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n    const key = `/1/indexes/*/queries_body_${JSON.stringify({\n      requests: results.rawResults.map((request) => ({\n        indexName: request.index,\n        params: request.params,\n      })),\n    })}`;\n\n    client.cache = {\n      ...client.cache,\n      [key]: JSON.stringify({\n        results: results.rawResults,\n      }),\n    };\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(\n        (acc, result) => ({\n          ...acc,\n          [result._internalIndexId]: new algoliasearchHelper.SearchResults(\n            new algoliasearchHelper.SearchParameters(result.state),\n            result.rawResults\n          ),\n        }),\n        {}\n      );\n    }\n\n    return new algoliasearchHelper.SearchResults(\n      new algoliasearchHelper.SearchParameters(results.state),\n      results.rawResults\n    );\n  }\n\n  // Called whenever a widget has been rendered with new props.\n  function onWidgetsUpdate() {\n    const metadata = getMetadata(store.getState().widgets);\n\n    store.setState({\n      ...store.getState(),\n      metadata,\n      searching: true,\n    });\n\n    // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    const searchState = store.getState().widgets;\n\n    return widgetsManager\n      .getWidgets()\n      .filter((widget) => Boolean(widget.transitionState))\n      .reduce(\n        (res, widget) => widget.transitionState(searchState, res),\n        nextSearchState\n      );\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    const metadata = getMetadata(nextSearchState);\n\n    store.setState({\n      ...store.getState(),\n      widgets: nextSearchState,\n      metadata,\n      searching: true,\n    });\n\n    search();\n  }\n\n  function onSearchForFacetValues({ facetName, query, maxFacetHits = 10 }) {\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    const maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n\n    store.setState({\n      ...store.getState(),\n      searchingForFacetValues: true,\n    });\n\n    helper\n      .searchForFacetValues(facetName, query, maxFacetHitsWithinRange)\n      .then(\n        (content) => {\n          store.setState({\n            ...store.getState(),\n            error: null,\n            searchingForFacetValues: false,\n            resultsFacetValues: {\n              ...store.getState().resultsFacetValues,\n              [facetName]: content.facetHits,\n              query,\n            },\n          });\n        },\n        (error) => {\n          store.setState({\n            ...store.getState(),\n            searchingForFacetValues: false,\n            error,\n          });\n        }\n      )\n      .catch((error) => {\n        // Since setState is synchronous, any error that occurs in the render of a\n        // component will be swallowed by this promise.\n        // This is a trick to make the error show up correctly in the console.\n        // See http://stackoverflow.com/a/30741722/969302\n        setTimeout(() => {\n          throw error;\n        });\n      });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex);\n    // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store\n      .getState()\n      .metadata.reduce(\n        (res, meta) =>\n          typeof meta.id !== 'undefined' ? res.concat(meta.id) : res,\n        []\n      );\n  }\n\n  return {\n    store,\n    widgetsManager,\n    getWidgetsIds,\n    getSearchParameters,\n    onSearchForFacetValues,\n    onExternalStateUpdate,\n    transitionState,\n    updateClient,\n    updateIndex,\n    clearCache,\n    skipSearch,\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  }\n\n  // add a value noop, which gets replaced once the widgets are mounted\n  return resultsState.metadata.map((datum) => ({\n    value: () => ({}),\n    ...datum,\n    items:\n      datum.items &&\n      datum.items.map((item) => ({\n        value: () => ({}),\n        ...item,\n        items:\n          item.items &&\n          item.items.map((nestedItem) => ({\n            value: () => ({}),\n            ...nestedItem,\n          })),\n      })),\n  }));\n}\n","import { defer } from './utils';\n\nimport type { ConnectorDescription } from './createConnector';\nimport type { Component } from 'react';\n\nexport type Widget = Component & {\n  constructor: {\n    displayName?: string;\n    $$type?: string;\n    $$widgetType?: string;\n    _connectorDesc?: ConnectorDescription;\n  };\n};\n\nexport type WidgetsManager = ReturnType<typeof createWidgetsManager>;\n\nexport default function createWidgetsManager(onWidgetsUpdate: () => void) {\n  const widgets: Widget[] = [];\n  // Is an update scheduled?\n  let scheduled = false;\n\n  // The state manager's updates need to be batched since more than one\n  // component can register or unregister widgets during the same tick.\n  function scheduleUpdate() {\n    if (scheduled) {\n      return;\n    }\n    scheduled = true;\n    defer(() => {\n      scheduled = false;\n      onWidgetsUpdate();\n    });\n  }\n\n  return {\n    registerWidget(widget: Widget) {\n      widgets.push(widget);\n      scheduleUpdate();\n      return function unregisterWidget() {\n        widgets.splice(widgets.indexOf(widget), 1);\n        scheduleUpdate();\n      };\n    },\n    update: scheduleUpdate,\n    getWidgets() {\n      return widgets;\n    },\n  };\n}\n","type SearchState = any;\ntype ResultsState = any;\ntype ResultsFacetsValues = any;\ntype Listener = () => void;\ntype State = {\n  widgets: SearchState;\n  metadata: any[];\n  results: ResultsState | null;\n  resultsFacetValues: ResultsFacetsValues | null;\n  error: Error | null;\n  searching: boolean;\n  isSearchStalled: boolean;\n  searchingForFacetValues: boolean;\n};\nexport default function createStore(initialState: State) {\n  let state = initialState;\n  const listeners: Listener[] = [];\n  return {\n    getState() {\n      return state;\n    },\n    setState(nextState: State) {\n      state = nextState;\n      listeners.forEach((listener) => listener());\n    },\n    subscribe(listener: Listener) {\n      listeners.push(listener);\n      return function unsubscribe() {\n        listeners.splice(listeners.indexOf(listener), 1);\n      };\n    },\n  };\n}\n\nexport type Store = ReturnType<typeof createStore>;\n","import type { SearchClient } from '../widgets/InstantSearch';\nimport type { Widget } from './createWidgetsManager';\n\nexport function isMetadataEnabled() {\n  return (\n    typeof window === 'object' &&\n    typeof window.navigator === 'object' &&\n    typeof window.navigator.userAgent === 'string' &&\n    window.navigator.userAgent.includes('Algolia Crawler') &&\n    typeof window.document === 'object'\n  );\n}\n\nexport function getMetadataPayload(\n  widgets: Widget[],\n  searchClient: SearchClient\n) {\n  const internalProps = ['contextValue', 'indexContextValue'];\n\n  const widgetsPayload = widgets.map(({ props, constructor }) => {\n    const { defaultProps = {}, displayName = constructor.displayName } =\n      constructor._connectorDesc || {};\n\n    return {\n      displayName,\n      $$type: constructor.$$type,\n      $$widgetType: constructor.$$widgetType,\n      params: Object.keys(props).filter(\n        (prop) =>\n          !internalProps.includes(prop) &&\n          defaultProps[prop] !== (props as any)[prop] &&\n          (props as any)[prop] !== undefined\n      ),\n    };\n  });\n\n  const client = searchClient as Record<string, any>;\n  const ua =\n    client.transporter && client.transporter.userAgent\n      ? client.transporter.userAgent.value\n      : client._ua;\n\n  return {\n    ua,\n    widgets: widgetsPayload,\n  };\n}\n\nexport function injectMetadata(widgets: Widget[], searchClient: SearchClient) {\n  const payloadContainer = document.createElement('meta');\n  const refNode = document.querySelector('head')!;\n  payloadContainer.name = 'algolia:metadata';\n\n  const payload = getMetadataPayload(widgets, searchClient);\n\n  payloadContainer.content = JSON.stringify(payload);\n  refNode.appendChild(payloadContainer);\n}\n","import PropTypes from 'prop-types';\nimport React, { Component, Children } from 'react';\nimport isEqual from 'react-fast-compare';\n\nimport { InstantSearchProvider } from '../core/context';\nimport createInstantSearchManager from '../core/createInstantSearchManager';\nimport { isMetadataEnabled, injectMetadata } from '../core/metadata';\n\nimport type { InstantSearchContext, IndexContext } from '../core/context';\nimport type { ConnectorDescription } from '../core/createConnector';\nimport type { Store } from '../core/createStore';\nimport type { WidgetsManager } from '../core/createWidgetsManager';\nimport type { MultiResponse } from '../types/algoliasearch';\nimport type {\n  PlainSearchParameters,\n  SearchParameters,\n} from 'algoliasearch-helper';\n\ntype ResultsState = {\n  metadata: never[];\n  state: PlainSearchParameters;\n  rawResults: MultiResponse;\n};\n\n// @TODO: move to createInstantSearchManager when it's TS\ntype InstantSearchManager = {\n  store: Store;\n  widgetsManager: WidgetsManager;\n  getWidgetsIds: () => any;\n  getSearchParameters: (...args: any[]) => {\n    mainParameters: SearchParameters;\n    derivedParameters: SearchParameters;\n  };\n  onSearchForFacetValues: (...args: any[]) => any;\n  onExternalStateUpdate: (...args: any[]) => any;\n  transitionState: any;\n  updateClient: any;\n  updateIndex: any;\n  clearCache: () => void;\n  skipSearch: (...args: any[]) => any;\n};\n\nexport type SearchClient = {\n  search: (requests: Array<{}>) => Promise<{}>;\n  searchForFacetValues: (requests: Array<{}>) => Promise<{}>;\n};\n\ntype SearchState = any;\n\ntype Props = {\n  refresh: boolean;\n  indexName: string;\n  searchClient: SearchClient;\n  createURL?: (searchState: SearchState, knownKeys: any) => string;\n  onSearchStateChange?: (searchState: SearchState) => void;\n  searchState?: SearchState;\n  onSearchParameters?: (\n    getSearchParameters: ConnectorDescription['getSearchParameters'],\n    context: { ais: InstantSearchContext; multiIndexContext: IndexContext },\n    props: object,\n    searchState: SearchState\n  ) => void;\n  widgetsCollector?: (args: {\n    getSearchParameters: ConnectorDescription['getSearchParameters'];\n    getMetadata: ConnectorDescription['getMetadata'];\n    searchState: SearchState;\n    context: { ais: InstantSearchContext; multiIndexContext: IndexContext };\n    props: object;\n    displayName: string;\n  }) => void;\n  stalledSearchDelay?: number;\n  resultsState?: ResultsState | { [indexId: string]: ResultsState };\n  children?: React.ReactNode;\n};\n\ntype State = {\n  isControlled: boolean;\n  instantSearchManager: InstantSearchManager;\n  contextValue: InstantSearchContext;\n};\n\nfunction isControlled(props: Props) {\n  return Boolean(props.searchState);\n}\n\n/**\n * @description\n * `<InstantSearch>` is the root component of all React InstantSearch implementations.\n * It provides all the connected components (aka widgets) a means to interact\n * with the searchState.\n * @kind widget\n * @name <InstantSearch>\n * @requirements You will need to have an Algolia account to be able to use this widget.\n * [Create one now](https://www.algolia.com/users/sign_up).\n * @propType {string} indexName - Main index in which to search.\n * @propType {boolean} [refresh=false] - Flag to activate when the cache needs to be cleared so that the front-end is updated when a change occurs in the index.\n * @propType {object} [searchClient] - Provide a custom search client.\n * @propType {func} [onSearchStateChange] - Function to be called everytime a new search is done. Useful for [URL Routing](guide/Routing.html).\n * @propType {object} [searchState] - Object to inject some search state. Switches the InstantSearch component in controlled mode. Useful for [URL Routing](guide/Routing.html).\n * @propType {func} [createURL] - Function to call when creating links, useful for [URL Routing](guide/Routing.html).\n * @propType {SearchResults|SearchResults[]} [resultsState] - Use this to inject the results that will be used at first rendering. Those results are found by using the `findResultsState` function. Useful for [Server Side Rendering](guide/Server-side_rendering.html).\n * @propType {number} [stalledSearchDelay=200] - The amount of time before considering that the search takes too much time. The time is expressed in milliseconds.\n * @propType {{ Root: string|function, props: object }} [root] - Use this to customize the root element. Default value: `{ Root: 'div' }`\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, SearchBox, Hits } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n *\n * const App = () => (\n *   <InstantSearch\n *     searchClient={searchClient}\n *     indexName=\"instant_search\"\n *   >\n *     <SearchBox />\n *     <Hits />\n *   </InstantSearch>\n * );\n */\nclass InstantSearch extends Component<Props, State> {\n  static defaultProps = {\n    stalledSearchDelay: 200,\n    refresh: false,\n  };\n\n  static propTypes = {\n    // @TODO: These props are currently constant.\n    indexName: PropTypes.string.isRequired,\n\n    searchClient: PropTypes.shape({\n      search: PropTypes.func.isRequired,\n      searchForFacetValues: PropTypes.func,\n      addAlgoliaAgent: PropTypes.func,\n      clearCache: PropTypes.func,\n    }).isRequired,\n\n    createURL: PropTypes.func,\n\n    refresh: PropTypes.bool,\n\n    searchState: PropTypes.object,\n    onSearchStateChange: PropTypes.func,\n\n    onSearchParameters: PropTypes.func,\n    widgetsCollector: PropTypes.func,\n    resultsState: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n\n    children: PropTypes.node,\n    stalledSearchDelay: PropTypes.number,\n  };\n\n  static getDerivedStateFromProps(\n    nextProps: Props,\n    prevState: State\n  ): Partial<State> {\n    const nextIsControlled = isControlled(nextProps);\n    const previousSearchState =\n      prevState.instantSearchManager.store.getState().widgets;\n    const nextSearchState = nextProps.searchState;\n\n    if (nextIsControlled && !isEqual(previousSearchState, nextSearchState)) {\n      prevState.instantSearchManager.onExternalStateUpdate(\n        nextProps.searchState\n      );\n    }\n\n    return {\n      isControlled: nextIsControlled,\n      contextValue: {\n        ...prevState.contextValue,\n        mainTargetedIndex: nextProps.indexName,\n      },\n    };\n  }\n\n  cleanupTimerRef: ReturnType<typeof setTimeout> | null = null;\n  isUnmounting: boolean = false;\n\n  constructor(props: Props) {\n    super(props);\n\n    const instantSearchManager = createInstantSearchManager({\n      indexName: this.props.indexName,\n      searchClient: this.props.searchClient,\n      initialState: this.props.searchState || {},\n      resultsState: this.props.resultsState,\n      stalledSearchDelay: this.props.stalledSearchDelay,\n    });\n\n    const contextValue = {\n      store: instantSearchManager.store,\n      widgetsManager: instantSearchManager.widgetsManager,\n      mainTargetedIndex: this.props.indexName,\n      onInternalStateUpdate: this.onWidgetsInternalStateUpdate.bind(this),\n      createHrefForState: this.createHrefForState.bind(this),\n      onSearchForFacetValues: this.onSearchForFacetValues.bind(this),\n      onSearchStateChange: this.onSearchStateChange.bind(this),\n      onSearchParameters: this.onSearchParameters.bind(this),\n    };\n\n    this.state = {\n      isControlled: isControlled(this.props),\n      instantSearchManager,\n      contextValue,\n    };\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const prevIsControlled = isControlled(prevProps);\n\n    if (prevIsControlled && !this.state.isControlled) {\n      throw new Error(\n        \"You can't switch <InstantSearch> from being controlled to uncontrolled\"\n      );\n    }\n\n    if (!prevIsControlled && this.state.isControlled) {\n      throw new Error(\n        \"You can't switch <InstantSearch> from being uncontrolled to controlled\"\n      );\n    }\n\n    if (this.props.refresh !== prevProps.refresh && this.props.refresh) {\n      this.state.instantSearchManager.clearCache();\n    }\n\n    if (prevProps.indexName !== this.props.indexName) {\n      this.state.instantSearchManager.updateIndex(this.props.indexName);\n    }\n\n    if (prevProps.searchClient !== this.props.searchClient) {\n      this.state.instantSearchManager.updateClient(this.props.searchClient);\n    }\n  }\n\n  componentDidMount() {\n    if (this.cleanupTimerRef) {\n      clearTimeout(this.cleanupTimerRef);\n      this.cleanupTimerRef = null;\n    }\n\n    if (isMetadataEnabled()) {\n      injectMetadata(\n        this.state.instantSearchManager.widgetsManager.getWidgets(),\n        this.props.searchClient\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    this.cleanupTimerRef = setTimeout(() => {\n      this.isUnmounting = true;\n      this.state.instantSearchManager.skipSearch();\n    });\n  }\n\n  createHrefForState(searchState: SearchState) {\n    searchState = this.state.instantSearchManager.transitionState(searchState);\n    return this.state.isControlled && this.props.createURL\n      ? this.props.createURL(searchState, this.getKnownKeys())\n      : '#';\n  }\n\n  onWidgetsInternalStateUpdate(searchState: SearchState) {\n    searchState = this.state.instantSearchManager.transitionState(searchState);\n\n    this.onSearchStateChange(searchState);\n\n    if (!this.state.isControlled) {\n      this.state.instantSearchManager.onExternalStateUpdate(searchState);\n    }\n  }\n\n  onSearchStateChange(searchState: any) {\n    if (this.props.onSearchStateChange && !this.isUnmounting) {\n      this.props.onSearchStateChange(searchState);\n    }\n  }\n\n  onSearchParameters(\n    getSearchParameters: ConnectorDescription['getMetadata'],\n    context: {\n      ais: InstantSearchContext;\n      multiIndexContext: IndexContext;\n    },\n    props: object,\n    getMetadata: ConnectorDescription['getMetadata'],\n    displayName: string\n  ) {\n    if (this.props.onSearchParameters) {\n      const searchState = this.props.searchState ? this.props.searchState : {};\n      this.props.onSearchParameters(\n        getSearchParameters,\n        context,\n        props,\n        searchState\n      );\n    }\n    if (this.props.widgetsCollector) {\n      const searchState = this.props.searchState ? this.props.searchState : {};\n      this.props.widgetsCollector({\n        getSearchParameters,\n        getMetadata,\n        context,\n        props,\n        searchState,\n        displayName,\n      });\n    }\n  }\n\n  onSearchForFacetValues(searchState: any) {\n    this.state.instantSearchManager.onSearchForFacetValues(searchState);\n  }\n\n  getKnownKeys() {\n    return this.state.instantSearchManager.getWidgetsIds();\n  }\n\n  render() {\n    if (Children.count(this.props.children) === 0) {\n      return null;\n    }\n\n    return (\n      <InstantSearchProvider value={this.state.contextValue}>\n        {this.props.children}\n      </InstantSearchProvider>\n    );\n  }\n}\n\nexport default InstantSearch;\n","import createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n} from '../core/indexUtils';\nimport { addQueryID, addAbsolutePositions } from '../core/utils';\n\nconst getId = () => 'query';\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId();\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    ''\n  );\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n  return '';\n}\n\nfunction getHits(searchResults) {\n  if (searchResults.results) {\n    if (\n      searchResults.results.hits &&\n      Array.isArray(searchResults.results.hits)\n    ) {\n      return addAbsolutePositions(\n        addQueryID(searchResults.results.hits, searchResults.results.queryID),\n        searchResults.results.hitsPerPage,\n        searchResults.results.page\n      );\n    } else {\n      return Object.keys(searchResults.results).reduce(\n        (hits, index) => [\n          ...hits,\n          {\n            index,\n            hits: addAbsolutePositions(\n              addQueryID(\n                searchResults.results[index].hits,\n                searchResults.results[index].queryID\n              ),\n              searchResults.results[index].hitsPerPage,\n              searchResults.results[index].page\n            ),\n          },\n        ],\n        []\n      );\n    }\n  } else {\n    return [];\n  }\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId();\n  const nextValue = { [id]: nextRefinement };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, getId());\n}\n\n/**\n * connectAutoComplete connector provides the logic to create connected\n * components that will render the results retrieved from\n * Algolia.\n *\n * To configure the number of hits retrieved, use [HitsPerPage widget](widgets/HitsPerPage.html),\n * [connectHitsPerPage connector](connectors/connectHitsPerPage.html) or pass the hitsPerPage\n * prop to a [Configure](guide/Search_parameters.html) widget.\n * @name connectAutoComplete\n * @kind connector\n * @propType {string} [defaultRefinement] - Provide a default value for the query\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {function} refine - a function to change the query\n * @providedPropType {string} currentRefinement - the query to search for\n */\nexport default createConnector({\n  displayName: 'AlgoliaAutoComplete',\n  $$type: 'ais.autoComplete',\n\n  getProvidedProps(props, searchState, searchResults) {\n    return {\n      hits: getHits(searchResults),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQuery(\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    );\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport { refineValue, getResults } from '../core/indexUtils';\n\nexport const getId = (props) => props.attributes[0];\n\nconst namespace = 'hierarchicalMenu';\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId(props);\n  const nextValue = { [id]: nextRefinement || '' };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction transformValue(values) {\n  return values.reduce((acc, item) => {\n    if (item.isRefined) {\n      acc.push({\n        label: item.name,\n        // If dealing with a nested \"items\", \"value\" is equal to the previous value concatenated with the current value\n        // If dealing with the first level, \"value\" is equal to the current value\n        value: item.escapedValue,\n      });\n      // Create a variable in order to keep the same acc for the recursion, otherwise \"reduce\" returns a new one\n      if (item.data) {\n        acc = acc.concat(transformValue(item.data, acc));\n      }\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * The breadcrumb component is s a type of secondary navigation scheme that\n * reveals the user’s location in a website or web application.\n *\n * @name connectBreadcrumb\n * @requirements To use this widget, your attributes must be formatted in a specific way.\n * If you want for example to have a Breadcrumb of categories, objects in your index\n * should be formatted this way:\n *\n * ```json\n * {\n *   \"categories.lvl0\": \"products\",\n *   \"categories.lvl1\": \"products > fruits\",\n *   \"categories.lvl2\": \"products > fruits > citrus\"\n * }\n * ```\n *\n * It's also possible to provide more than one path for each level:\n *\n * ```json\n * {\n *   \"categories.lvl0\": [\"products\", \"goods\"],\n *   \"categories.lvl1\": [\"products > fruits\", \"goods > to eat\"]\n * }\n * ```\n *\n * All attributes passed to the `attributes` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n *\n * @kind connector\n * @propType {array.<string>} attributes - List of attributes to use to generate the hierarchy of the menu. See the example for the convention to follow.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<{items: object, count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the Breadcrumb can display.\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaBreadcrumb',\n  $$type: 'ais.breadcrumb',\n\n  propTypes: {\n    attributes: (props, propName, componentName) => {\n      const isNotString = (val) => typeof val !== 'string';\n      if (\n        !Array.isArray(props[propName]) ||\n        props[propName].some(isNotString) ||\n        props[propName].length < 1\n      ) {\n        return new Error(\n          `Invalid prop ${propName} supplied to ${componentName}. Expected an Array of Strings`\n        );\n      }\n      return undefined;\n    },\n    transformItems: PropTypes.func,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    const id = getId(props);\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const isFacetPresent =\n      Boolean(results) && Boolean(results.getFacetByName(id));\n\n    if (!isFacetPresent) {\n      return {\n        items: [],\n        canRefine: false,\n      };\n    }\n\n    const values = results.getFacetValues(id);\n\n    const items = values.data ? transformValue(values.data) : [];\n\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n\n    return {\n      canRefine: transformedItems.length > 0,\n      items: transformedItems,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n});\n","import createConnector from '../core/createConnector';\nimport {\n  getResults,\n  getCurrentRefinementValue,\n  getIndexId,\n  refineValue,\n  cleanUpValue,\n} from '../core/indexUtils';\nimport { objectHasKeys } from '../core/utils';\n\n/**\n * The GeoSearch connector provides the logic to build a widget that will display the results on a map.\n * It also provides a way to search for results based on their position. The connector provides function to manage the search experience (search on map interaction).\n * @name connectGeoSearch\n * @kind connector\n * @requirements Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia.\n * Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function. Currently, the feature is not compatible with multiple values in the `_geoloc` attribute\n * (e.g. a restaurant with multiple locations). In that case you can duplicate your records and use the [distinct](https://www.algolia.com/doc/guides/ranking/distinct) feature of Algolia to only retrieve unique results.\n * @propType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [defaultRefinement] - Default search state of the widget containing the bounds for the map\n * @providedPropType {function({ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } })} refine - a function to toggle the refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {array.<object>} hits - the records that matched the search\n * @providedPropType {boolean} isRefinedWithMap - true if the current refinement is set with the map bounds\n * @providedPropType {{ northEast: { lat: number, lng: number }, southWest: { lat: number, lng: number } }} [currentRefinement] - the refinement currently applied\n * @providedPropType {{ lat: number, lng: number }} [position] - the position of the search\n */\n\n// To control the map with an external widget the other widget\n// **must** write the value in the attribute `aroundLatLng`\nconst getBoundingBoxId = () => 'boundingBox';\nconst getAroundLatLngId = () => 'aroundLatLng';\nconst getConfigureAroundLatLngId = () => 'configure.aroundLatLng';\n\nconst currentRefinementToString = (currentRefinement) =>\n  [\n    currentRefinement.northEast.lat,\n    currentRefinement.northEast.lng,\n    currentRefinement.southWest.lat,\n    currentRefinement.southWest.lng,\n  ].join();\n\nconst stringToCurrentRefinement = (value) => {\n  const values = value.split(',');\n\n  return {\n    northEast: {\n      lat: parseFloat(values[0]),\n      lng: parseFloat(values[1]),\n    },\n    southWest: {\n      lat: parseFloat(values[2]),\n      lng: parseFloat(values[3]),\n    },\n  };\n};\n\nconst latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nconst stringToPosition = (value) => {\n  const pattern = value.match(latLngRegExp);\n\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2]),\n  };\n};\n\nconst getCurrentRefinement = (props, searchState, context) => {\n  const refinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    getBoundingBoxId(),\n    {}\n  );\n\n  if (!objectHasKeys(refinement)) {\n    return;\n  }\n\n  // eslint-disable-next-line consistent-return\n  return {\n    northEast: {\n      lat: parseFloat(refinement.northEast.lat),\n      lng: parseFloat(refinement.northEast.lng),\n    },\n    southWest: {\n      lat: parseFloat(refinement.southWest.lat),\n      lng: parseFloat(refinement.southWest.lng),\n    },\n  };\n};\n\nconst getCurrentPosition = (props, searchState, context) => {\n  const { defaultRefinement, ...propsWithoutDefaultRefinement } = props;\n\n  const aroundLatLng = getCurrentRefinementValue(\n    propsWithoutDefaultRefinement,\n    searchState,\n    context,\n    getAroundLatLngId()\n  );\n\n  if (!aroundLatLng) {\n    // Fallback on `configure.aroundLatLng`\n    const configureAroundLatLng = getCurrentRefinementValue(\n      propsWithoutDefaultRefinement,\n      searchState,\n      context,\n      getConfigureAroundLatLngId()\n    );\n\n    return configureAroundLatLng && stringToPosition(configureAroundLatLng);\n  }\n\n  return aroundLatLng;\n};\n\nconst refine = (searchState, nextValue, context) => {\n  const resetPage = true;\n  const nextRefinement = {\n    [getBoundingBoxId()]: nextValue,\n  };\n\n  return refineValue(searchState, nextRefinement, context, resetPage);\n};\n\nexport default createConnector({\n  displayName: 'AlgoliaGeoSearch',\n  $$type: 'ais.geoSearch',\n\n  getProvidedProps(props, searchState, searchResults) {\n    const context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    };\n\n    const results = getResults(searchResults, context);\n\n    // We read it from both because the SearchParameters & the searchState are not always\n    // in sync. When we set the refinement the searchState is used but when we clear the refinement\n    // the SearchParameters is used. In the first case when we render, the results are not there\n    // so we can't find the value from the results. The most up to date value is the searchState.\n    // But when we clear the refinement the searchState is immediately cleared even when the items\n    // retrieved are still the one from the previous query with the bounding box. It leads to some\n    // issue with the position of the map. We should rely on 1 source of truth or at least always\n    // be sync.\n\n    const currentRefinementFromSearchState = getCurrentRefinement(\n      props,\n      searchState,\n      context\n    );\n\n    const currentRefinementFromSearchParameters =\n      (results &&\n        results._state.insideBoundingBox &&\n        stringToCurrentRefinement(results._state.insideBoundingBox)) ||\n      undefined;\n\n    const currentPositionFromSearchState = getCurrentPosition(\n      props,\n      searchState,\n      context\n    );\n\n    const currentPositionFromSearchParameters =\n      (results &&\n        results._state.aroundLatLng &&\n        stringToPosition(results._state.aroundLatLng)) ||\n      undefined;\n\n    const currentRefinement =\n      currentRefinementFromSearchState || currentRefinementFromSearchParameters;\n\n    const position =\n      currentPositionFromSearchState || currentPositionFromSearchParameters;\n\n    return {\n      hits: !results ? [] : results.hits.filter((_) => Boolean(_._geoloc)),\n      isRefinedWithMap: Boolean(currentRefinement),\n      currentRefinement,\n      position,\n    };\n  },\n\n  refine(props, searchState, nextValue) {\n    return refine(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (!currentRefinement) {\n      return searchParameters;\n    }\n\n    return searchParameters.setQueryParameter(\n      'insideBoundingBox',\n      currentRefinementToString(currentRefinement)\n    );\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUpValue(\n      searchState,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      getBoundingBoxId()\n    );\n  },\n\n  getMetadata(props, searchState) {\n    const items = [];\n    const id = getBoundingBoxId();\n    const context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    };\n    const index = getIndexId(context);\n    const nextRefinement = {};\n    const currentRefinement = getCurrentRefinement(props, searchState, context);\n\n    if (currentRefinement) {\n      items.push({\n        label: `${id}: ${currentRefinementToString(currentRefinement)}`,\n        value: (nextState) => refine(nextState, nextRefinement, context),\n        currentRefinement,\n      });\n    }\n\n    return {\n      id,\n      index,\n      items,\n    };\n  },\n\n  shouldComponentUpdate() {\n    return true;\n  },\n});\n","import algoliasearchHelper from 'algoliasearch-helper';\nimport PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  getIndexId,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n} from '../core/indexUtils';\nimport { unescapeFacetValue } from '../core/utils';\n\nexport const getId = (props) => props.attributes[0];\n\nconst namespace = 'hierarchicalMenu';\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    null\n  );\n\n  if (currentRefinement === '') {\n    return null;\n  }\n  return currentRefinement;\n}\n\nfunction getValue(value, props, searchState, context) {\n  const { id, attributes, separator, rootPath, showParentLevel } = props;\n\n  const currentRefinement = getCurrentRefinement(props, searchState, context);\n  let nextRefinement;\n\n  if (currentRefinement === null) {\n    nextRefinement = value;\n  } else {\n    const tmpSearchParameters = new algoliasearchHelper.SearchParameters({\n      hierarchicalFacets: [\n        {\n          name: id,\n          attributes,\n          separator,\n          rootPath,\n          showParentLevel,\n        },\n      ],\n    });\n\n    nextRefinement = tmpSearchParameters\n      .toggleHierarchicalFacetRefinement(id, currentRefinement)\n      .toggleHierarchicalFacetRefinement(id, value)\n      .getHierarchicalRefinement(id)[0];\n  }\n\n  return nextRefinement;\n}\n\nfunction transformValue(value, props, searchState, context) {\n  return value.map((v) => ({\n    label: v.name,\n    value: getValue(v.escapedValue, props, searchState, context),\n    count: v.count,\n    isRefined: v.isRefined,\n    items: v.data && transformValue(v.data, props, searchState, context),\n  }));\n}\n\nconst truncate = (items = [], limit = 10) =>\n  items.slice(0, limit).map((item = {}) =>\n    Array.isArray(item.items)\n      ? {\n          ...item,\n          items: truncate(item.items, limit),\n        }\n      : item\n  );\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId(props);\n  const nextValue = { [id]: nextRefinement || '' };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n\nconst sortBy = ['name:asc'];\n\n/**\n * connectHierarchicalMenu connector provides the logic to build a widget that will\n * give the user the ability to explore a tree-like structure.\n * This is commonly used for multi-level categorization of products on e-commerce\n * websites. From a UX point of view, we suggest not displaying more than two levels deep.\n * @name connectHierarchicalMenu\n * @requirements To use this widget, your attributes must be formatted in a specific way.\n * If you want for example to have a hierarchical menu of categories, objects in your index\n * should be formatted this way:\n *\n * ```json\n * {\n *   \"categories.lvl0\": \"products\",\n *   \"categories.lvl1\": \"products > fruits\",\n *   \"categories.lvl2\": \"products > fruits > citrus\"\n * }\n * ```\n *\n * It's also possible to provide more than one path for each level:\n *\n * ```json\n * {\n *   \"categories.lvl0\": [\"products\", \"goods\"],\n *   \"categories.lvl1\": [\"products > fruits\", \"goods > to eat\"]\n * }\n * ```\n *\n * All attributes passed to the `attributes` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n *\n * @kind connector\n * @propType {array.<string>} attributes - List of attributes to use to generate the hierarchy of the menu. See the example for the convention to follow.\n * @propType {string} [defaultRefinement] - the item value selected by default\n * @propType {boolean} [showMore=false] - Flag to activate the show more button, for toggling the number of items between limit and showMoreLimit.\n * @propType {number} [limit=10] -  The maximum number of items displayed.\n * @propType {number} [showMoreLimit=20] -  The maximum number of items displayed when the user triggers the show more. Not considered if `showMore` is false.\n * @propType {string} [separator='>'] -  Specifies the level separator used in the data.\n * @propType {string} [rootPath=null] - The path to use if the first level is not the root level.\n * @propType {boolean} [showParentLevel=true] - Flag to set if the parent level should be displayed.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{items: object, count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the HierarchicalMenu can display. items has the same shape as parent items.\n */\nexport default createConnector({\n  displayName: 'AlgoliaHierarchicalMenu',\n  $$type: 'ais.hierarchicalMenu',\n\n  propTypes: {\n    attributes: (props, propName, componentName) => {\n      const isNotString = (val) => typeof val !== 'string';\n      if (\n        !Array.isArray(props[propName]) ||\n        props[propName].some(isNotString) ||\n        props[propName].length < 1\n      ) {\n        return new Error(\n          `Invalid prop ${propName} supplied to ${componentName}. Expected an Array of Strings`\n        );\n      }\n      return undefined;\n    },\n    separator: PropTypes.string,\n    rootPath: PropTypes.string,\n    showParentLevel: PropTypes.bool,\n    defaultRefinement: PropTypes.string,\n    showMore: PropTypes.bool,\n    limit: PropTypes.number,\n    showMoreLimit: PropTypes.number,\n    transformItems: PropTypes.func,\n    facetOrdering: PropTypes.bool,\n  },\n\n  defaultProps: {\n    showMore: false,\n    limit: 10,\n    showMoreLimit: 20,\n    separator: ' > ',\n    rootPath: null,\n    showParentLevel: true,\n    facetOrdering: true,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    const { showMore, limit, showMoreLimit, facetOrdering } = props;\n    const id = getId(props);\n\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const isFacetPresent =\n      Boolean(results) && Boolean(results.getFacetByName(id));\n\n    if (!isFacetPresent) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        }),\n        canRefine: false,\n      };\n    }\n    const itemsLimit = showMore ? showMoreLimit : limit;\n    const value = results.getFacetValues(id, { sortBy, facetOrdering });\n    const items = value.data\n      ? transformValue(value.data, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        })\n      : [];\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n    return {\n      items: truncate(transformedItems, itemsLimit),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      canRefine: transformedItems.length > 0,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const {\n      attributes,\n      separator,\n      rootPath,\n      showParentLevel,\n      showMore,\n      limit,\n      showMoreLimit,\n      contextValue,\n    } = props;\n\n    const id = getId(props);\n    const itemsLimit = showMore ? showMoreLimit : limit;\n\n    searchParameters = searchParameters\n      .addHierarchicalFacet({\n        name: id,\n        attributes,\n        separator,\n        rootPath,\n        showParentLevel,\n      })\n      .setQueryParameters({\n        maxValuesPerFacet: Math.max(\n          searchParameters.maxValuesPerFacet || 0,\n          itemsLimit\n        ),\n      });\n\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    if (currentRefinement !== null) {\n      searchParameters = searchParameters.toggleHierarchicalFacetRefinement(\n        id,\n        currentRefinement\n      );\n    }\n\n    return searchParameters;\n  },\n\n  getMetadata(props, searchState) {\n    const rootAttribute = props.attributes[0];\n    const id = getId(props);\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const items = !currentRefinement\n      ? []\n      : [\n          {\n            label: `${rootAttribute}: ${unescapeFacetValue(currentRefinement)}`,\n            attribute: rootAttribute,\n            value: (nextState) =>\n              refine(props, nextState, '', {\n                ais: props.contextValue,\n                multiIndexContext: props.indexContextValue,\n              }),\n            currentRefinement,\n          },\n        ];\n\n    return {\n      id,\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      items,\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\n\n/**\n * connectCurrentRefinements connector provides the logic to build a widget that will\n * give the user the ability to remove all or some of the filters that were\n * set.\n * @name connectCurrentRefinements\n * @kind connector\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @propType {function} [clearsQuery=false] - Pass true to also clear the search query\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {array.<{label: string, attribute: string, currentRefinement: string || object, items: array, value: function}>} items - all the filters, the `value` is to pass to the `refine` function for removing all currentrefinements, `label` is for the display. When existing several refinements for the same atribute name, then you get a nested `items` object that contains a `label` and a `value` function to use to remove a single filter. `attribute` and `currentRefinement` are metadata containing row values.\n * @providedPropType {string} query - the search query\n */\nexport default createConnector({\n  displayName: 'AlgoliaCurrentRefinements',\n  $$type: 'ais.currentRefinements',\n\n  propTypes: {\n    transformItems: PropTypes.func,\n  },\n\n  getProvidedProps(props, searchState, searchResults, metadata) {\n    const items = metadata.reduce((res, meta) => {\n      if (typeof meta.items !== 'undefined') {\n        if (!props.clearsQuery && meta.id === 'query') {\n          return res;\n        } else {\n          if (\n            props.clearsQuery &&\n            meta.id === 'query' &&\n            meta.items[0].currentRefinement === ''\n          ) {\n            return res;\n          }\n          return res.concat(\n            meta.items.map((item) => ({\n              ...item,\n              id: meta.id,\n              index: meta.index,\n            }))\n          );\n        }\n      }\n      return res;\n    }, []);\n\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n\n    return {\n      items: transformedItems,\n      canRefine: transformedItems.length > 0,\n    };\n  },\n\n  refine(props, searchState, items) {\n    // `value` corresponds to our internal clear function computed in each connector metadata.\n    const refinementsToClear =\n      items instanceof Array ? items.map((item) => item.value) : [items];\n    return refinementsToClear.reduce((res, clear) => clear(res), searchState);\n  },\n});\n","import createConnector from '../core/createConnector';\nimport { HIGHLIGHT_TAGS, parseAlgoliaHit } from '../core/highlight';\n\nconst highlight = ({\n  attribute,\n  hit,\n  highlightProperty,\n  preTag = HIGHLIGHT_TAGS.highlightPreTag,\n  postTag = HIGHLIGHT_TAGS.highlightPostTag,\n}) =>\n  parseAlgoliaHit({\n    attribute,\n    highlightProperty,\n    hit,\n    preTag,\n    postTag,\n  });\n\n/**\n * connectHighlight connector provides the logic to create an highlighter\n * component that will retrieve, parse and render an highlighted attribute\n * from an Algolia hit.\n * @name connectHighlight\n * @kind connector\n * @category connector\n * @providedPropType {function} highlight - function to retrieve and parse an attribute from a hit. It takes a configuration object with 3 attributes: `highlightProperty` which is the property that contains the highlight structure from the records, `attribute` which is the name of the attribute (it can be either a string or an array of strings) to look for and `hit` which is the hit from Algolia. It returns an array of objects `{value: string, isHighlighted: boolean}`. If the element that corresponds to the attribute is an array of strings, it will return a nested array of objects.\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, SearchBox, Hits, connectHighlight } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n *\n * const CustomHighlight = connectHighlight(\n *   ({ highlight, attribute, hit, highlightProperty }) => {\n *     const highlights = highlight({\n *       highlightProperty: '_highlightResult',\n *       attribute,\n *       hit\n *     });\n *\n *     return highlights.map(part => part.isHighlighted ? (\n *       <mark>{part.value}</mark>\n *     ) : (\n *       <span>{part.value}</span>\n *     ));\n *   }\n * );\n *\n * const Hit = ({ hit }) => (\n *   <p>\n *     <CustomHighlight attribute=\"name\" hit={hit} />\n *   </p>\n * );\n *\n * const App = () => (\n *   <InstantSearch\n *     searchClient={searchClient}\n *     indexName=\"instant_search\"\n *   >\n *     <SearchBox defaultRefinement=\"pho\" />\n *     <Hits hitComponent={Hit} />\n *   </InstantSearch>\n * );\n */\nexport default createConnector({\n  displayName: 'AlgoliaHighlighter',\n  $$type: 'ais.highlighter',\n\n  propTypes: {},\n\n  getProvidedProps() {\n    return { highlight };\n  },\n});\n","import createConnector from '../core/createConnector';\nimport { getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\n/**\n * connectHits connector provides the logic to create connected\n * components that will render the results retrieved from\n * Algolia.\n *\n * To configure the number of hits retrieved, use [HitsPerPage widget](widgets/HitsPerPage.html),\n * [connectHitsPerPage connector](connectors/connectHitsPerPage.html) or pass the hitsPerPage\n * prop to a [Configure](guide/Search_parameters.html) widget.\n *\n * **Warning:** you will need to use the **objectID** property available on every hit as a key\n * when iterating over them. This will ensure you have the best possible UI experience\n * especially on slow networks.\n * @name connectHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, Highlight, connectHits } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n * const CustomHits = connectHits(({ hits }) => (\n *   <div>\n *     {hits.map(hit =>\n *       <p key={hit.objectID}>\n *         <Highlight attribute=\"name\" hit={hit} />\n *       </p>\n *     )}\n *   </div>\n * ));\n *\n * const App = () => (\n *   <InstantSearch\n *     searchClient={searchClient}\n *     indexName=\"instant_search\"\n *   >\n *     <CustomHits />\n *   </InstantSearch>\n * );\n */\nexport default createConnector({\n  displayName: 'AlgoliaHits',\n  $$type: 'ais.hits',\n\n  getProvidedProps(props, searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    if (!results) {\n      return { hits: [] };\n    }\n    const hitsWithPositions = addAbsolutePositions(\n      results.hits,\n      results.hitsPerPage,\n      results.page\n    );\n    const hitsWithPositionsAndQueryID = addQueryID(\n      hitsWithPositions,\n      results.queryID\n    );\n    return { hits: hitsWithPositionsAndQueryID };\n  },\n\n  /*\n   * Hits needs to be considered as a widget to trigger a search,\n   * even if no other widgets are used.\n   *\n   * To be considered as a widget you need either:\n   * - getSearchParameters\n   * - getMetadata\n   * - transitionState\n   *\n   * See: createConnector.tsx\n   */\n  getSearchParameters(searchParameters) {\n    return searchParameters;\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n} from '../core/indexUtils';\n\nfunction getId() {\n  return 'hitsPerPage';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId();\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    null\n  );\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n  return currentRefinement;\n}\n\n/**\n * connectHitsPerPage connector provides the logic to create connected\n * components that will allow a user to choose to display more or less results from Algolia.\n * @name connectHitsPerPage\n * @kind connector\n * @propType {number} defaultRefinement - The number of items selected by default\n * @propType {{value: number, label: string}[]} items - List of hits per page options.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{isRefined: boolean, label?: string, value: number}>} items - the list of items the HitsPerPage can display. If no label provided, the value will be displayed.\n */\nexport default createConnector({\n  displayName: 'AlgoliaHitsPerPage',\n  $$type: 'ais.hitsPerPage',\n\n  propTypes: {\n    defaultRefinement: PropTypes.number.isRequired,\n    items: PropTypes.arrayOf(\n      PropTypes.shape({\n        label: PropTypes.string,\n        value: PropTypes.number.isRequired,\n      })\n    ).isRequired,\n    transformItems: PropTypes.func,\n  },\n\n  getProvidedProps(props, searchState) {\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const items = props.items.map((item) =>\n      item.value === currentRefinement\n        ? { ...item, isRefined: true }\n        : { ...item, isRefined: false }\n    );\n    return {\n      items: props.transformItems ? props.transformItems(items) : items,\n      currentRefinement,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    const id = getId();\n    const nextValue = { [id]: nextRefinement };\n    const resetPage = true;\n    return refineValue(\n      searchState,\n      nextValue,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      resetPage\n    );\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUpValue(\n      searchState,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      getId()\n    );\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setHitsPerPage(\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    );\n  },\n\n  getMetadata() {\n    return { id: getId() };\n  },\n});\n","import isEqual from 'react-fast-compare';\n\nimport createConnector from '../core/createConnector';\nimport {\n  getCurrentRefinementValue,\n  refineValue,\n  getResults,\n} from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId();\n  const page = 1;\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    page\n  );\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n  return currentRefinement;\n}\n\nfunction getStateWithoutPage(state) {\n  const { page, ...rest } = state || {};\n  return rest;\n}\n\nfunction getInMemoryCache() {\n  let cachedHits = undefined;\n  let cachedState = undefined;\n  return {\n    read({ state }) {\n      return isEqual(cachedState, getStateWithoutPage(state))\n        ? cachedHits\n        : null;\n    },\n    write({ state, hits }) {\n      cachedState = getStateWithoutPage(state);\n      cachedHits = hits;\n    },\n  };\n}\n\nfunction extractHitsFromCachedHits(cachedHits) {\n  return Object.keys(cachedHits)\n    .map(Number)\n    .sort((a, b) => a - b)\n    .reduce((acc, page) => {\n      return acc.concat(cachedHits[page]);\n    }, []);\n}\n\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  $$type: 'ais.infiniteHits',\n\n  getProvidedProps(props, searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (!results) {\n      return {\n        hits: [],\n        hasPrevious: false,\n        hasMore: false,\n        refine: () => {},\n        refinePrevious: () => {},\n        refineNext: () => {},\n      };\n    }\n\n    const { page, hits, hitsPerPage, nbPages, _state: state } = results;\n\n    this._cache = props.cache ? props.cache : this._cache || getInMemoryCache();\n    const cachedHits = this._cache.read({ state }) || {};\n\n    const hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    const hitsWithPositionsAndQueryID = addQueryID(\n      hitsWithPositions,\n      results.queryID\n    );\n\n    cachedHits[page] = hitsWithPositionsAndQueryID;\n    this._cache.write({ state, hits: cachedHits });\n\n    /*\n      Math.min() and Math.max() returns Infinity or -Infinity when no argument is given.\n      But there is always something in this point because of `cachedHits[page]`.\n    */\n    const firstReceivedPage = Math.min(...Object.keys(cachedHits).map(Number));\n    const lastReceivedPage = Math.max(...Object.keys(cachedHits).map(Number));\n\n    const hasPrevious = firstReceivedPage > 0;\n    const lastPageIndex = nbPages - 1;\n    const hasMore = lastReceivedPage < lastPageIndex;\n    const refinePrevious = (event) => this.refine(event, firstReceivedPage - 1);\n    const refineNext = (event) => this.refine(event, lastReceivedPage + 1);\n\n    return {\n      hits: extractHitsFromCachedHits(cachedHits),\n      hasPrevious,\n      hasMore,\n      refinePrevious,\n      refineNext,\n    };\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page:\n        getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        }) - 1,\n    });\n  },\n\n  refine(props, searchState, event, index) {\n    const id = getId();\n    const nextValue = { [id]: index + 1 };\n    const resetPage = false;\n    return refineValue(\n      searchState,\n      nextValue,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      resetPage\n    );\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  getIndexId,\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n} from '../core/indexUtils';\nimport { unescapeFacetValue } from '../core/utils';\n\nconst namespace = 'menu';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    null\n  );\n\n  if (currentRefinement === '') {\n    return null;\n  }\n  return currentRefinement;\n}\n\nfunction getValue(value, props, searchState, context) {\n  const currentRefinement = getCurrentRefinement(props, searchState, context);\n  return value === currentRefinement ? '' : value;\n}\n\nfunction getLimit({ showMore, limit, showMoreLimit }) {\n  return showMore ? showMoreLimit : limit;\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId(props);\n  const nextValue = { [id]: nextRefinement ? nextRefinement : '' };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n\nconst defaultSortBy = ['count:desc', 'name:asc'];\n\n/**\n * connectMenu connector provides the logic to build a widget that will\n * give the user the ability to choose a single value for a specific facet.\n * @name connectMenu\n * @requirements The attribute passed to the `attribute` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @kind connector\n * @propType {string} attribute - the name of the attribute in the record\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limit=10] - the minimum number of diplayed items\n * @propType {number} [showMoreLimit=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string} [defaultRefinement] - the value of the item selected by default\n * @propType {boolean} [searchable=false] - allow search inside values\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the Menu can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n */\nexport default createConnector({\n  displayName: 'AlgoliaMenu',\n  $$type: 'ais.menu',\n\n  propTypes: {\n    attribute: PropTypes.string.isRequired,\n    showMore: PropTypes.bool,\n    limit: PropTypes.number,\n    showMoreLimit: PropTypes.number,\n    defaultRefinement: PropTypes.string,\n    transformItems: PropTypes.func,\n    searchable: PropTypes.bool,\n    facetOrdering: PropTypes.bool,\n  },\n\n  defaultProps: {\n    showMore: false,\n    limit: 10,\n    showMoreLimit: 20,\n    facetOrdering: true,\n  },\n\n  getProvidedProps(\n    props,\n    searchState,\n    searchResults,\n    meta,\n    searchForFacetValuesResults\n  ) {\n    const { attribute, searchable, indexContextValue, facetOrdering } = props;\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const canRefine =\n      Boolean(results) && Boolean(results.getFacetByName(attribute));\n\n    const isFromSearch = Boolean(\n      searchForFacetValuesResults &&\n        searchForFacetValuesResults[attribute] &&\n        searchForFacetValuesResults.query !== ''\n    );\n\n    // Search For Facet Values is not available with derived helper (used for multi index search)\n    if (searchable && indexContextValue) {\n      throw new Error(\n        'react-instantsearch: searching in *List is not available when used inside a' +\n          ' multi index context'\n      );\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        }),\n        isFromSearch,\n        searchable,\n        canRefine,\n      };\n    }\n\n    let items;\n    if (isFromSearch) {\n      items = searchForFacetValuesResults[attribute].map((v) => ({\n        label: v.value,\n        value: getValue(v.escapedValue, props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        }),\n        _highlightResult: { label: { value: v.highlighted } },\n        count: v.count,\n        isRefined: v.isRefined,\n      }));\n    } else {\n      items = results\n        .getFacetValues(attribute, {\n          sortBy: searchable ? undefined : defaultSortBy,\n          facetOrdering,\n        })\n        .map((v) => ({\n          label: v.name,\n          value: getValue(v.escapedValue, props, searchState, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue,\n          }),\n          count: v.count,\n          isRefined: v.isRefined,\n        }));\n    }\n\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      isFromSearch,\n      searchable,\n      canRefine: transformedItems.length > 0,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attribute,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props),\n    };\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const { attribute } = props;\n\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(\n        searchParameters.maxValuesPerFacet || 0,\n        getLimit(props)\n      ),\n    });\n\n    searchParameters = searchParameters.addDisjunctiveFacet(attribute);\n\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    if (currentRefinement !== null) {\n      searchParameters = searchParameters.addDisjunctiveFacetRefinement(\n        attribute,\n        currentRefinement\n      );\n    }\n\n    return searchParameters;\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId(props);\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    return {\n      id,\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      items:\n        currentRefinement === null\n          ? []\n          : [\n              {\n                label: `${props.attribute}: ${unescapeFacetValue(\n                  currentRefinement\n                )}`,\n                attribute: props.attribute,\n                value: (nextState) =>\n                  refine(props, nextState, '', {\n                    ais: props.contextValue,\n                    multiIndexContext: props.indexContextValue,\n                  }),\n                currentRefinement,\n              },\n            ],\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n  getIndexId,\n} from '../core/indexUtils';\nimport { find } from '../core/utils';\n\nfunction stringifyItem(item) {\n  if (typeof item.start === 'undefined' && typeof item.end === 'undefined') {\n    return '';\n  }\n  const start = typeof item.start !== 'undefined' ? item.start : '';\n  const end = typeof item.end !== 'undefined' ? item.end : '';\n  return `${start}:${end}`;\n}\n\nfunction parseItem(value) {\n  if (value.length === 0) {\n    return { start: null, end: null };\n  }\n  const [startStr, endStr] = value.split(':');\n  return {\n    start: startStr.length > 0 ? parseFloat(startStr) : null,\n    end: endStr.length > 0 ? parseFloat(endStr) : null,\n  };\n}\n\nconst namespace = 'multiRange';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  return getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    '',\n    (currentRefinement) => {\n      if (currentRefinement === '') {\n        return '';\n      }\n      return currentRefinement;\n    }\n  );\n}\n\nfunction isRefinementsRangeIncludesInsideItemRange(stats, start, end) {\n  return (\n    (stats.min >= start && stats.min <= end) ||\n    (stats.max >= start && stats.max <= end)\n  );\n}\n\nfunction isItemRangeIncludedInsideRefinementsRange(stats, start, end) {\n  return (\n    (start >= stats.min && start <= stats.max) ||\n    (end >= stats.min && end <= stats.max)\n  );\n}\n\nfunction itemHasRefinement(attribute, results, value) {\n  const stats = results.getFacetByName(attribute)\n    ? results.getFacetStats(attribute)\n    : null;\n  const range = value.split(':');\n  const start =\n    Number(range[0]) === 0 || value === ''\n      ? Number.NEGATIVE_INFINITY\n      : Number(range[0]);\n  const end =\n    Number(range[1]) === 0 || value === ''\n      ? Number.POSITIVE_INFINITY\n      : Number(range[1]);\n  return !(\n    Boolean(stats) &&\n    (isRefinementsRangeIncludesInsideItemRange(stats, start, end) ||\n      isItemRangeIncludedInsideRefinementsRange(stats, start, end))\n  );\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const nextValue = { [getId(props, searchState)]: nextRefinement };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n\n/**\n * connectNumericMenu connector provides the logic to build a widget that will\n * give the user the ability to select a range value for a numeric attribute.\n * Ranges are defined statically.\n * @name connectNumericMenu\n * @requirements The attribute passed to the `attribute` prop must be holding numerical values.\n * @kind connector\n * @propType {string} attribute - the name of the attribute in the records\n * @propType {{label: string, start: number, end: number}[]} items - List of options. With a text label, and upper and lower bounds.\n * @propType {string} [defaultRefinement] - the value of the item selected by default, follow the shape of a `string` with a pattern of `'{start}:{end}'`.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied.  follow the shape of a `string` with a pattern of `'{start}:{end}'` which corresponds to the current selected item. For instance, when the selected item is `{start: 10, end: 20}`, the searchState of the widget is `'10:20'`. When `start` isn't defined, the searchState of the widget is `':{end}'`, and the same way around when `end` isn't defined. However, when neither `start` nor `end` are defined, the searchState is an empty string.\n * @providedPropType {array.<{isRefined: boolean, label: string, value: string, isRefined: boolean, noRefinement: boolean}>} items - the list of ranges the NumericMenu can display.\n */\nexport default createConnector({\n  displayName: 'AlgoliaNumericMenu',\n  $$type: 'ais.numericMenu',\n\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    items: PropTypes.arrayOf(\n      PropTypes.shape({\n        label: PropTypes.node,\n        start: PropTypes.number,\n        end: PropTypes.number,\n      })\n    ).isRequired,\n    transformItems: PropTypes.func,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    const attribute = props.attribute;\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const items = props.items.map((item) => {\n      const value = stringifyItem(item);\n      return {\n        label: item.label,\n        value,\n        isRefined: value === currentRefinement,\n        noRefinement: results\n          ? itemHasRefinement(getId(props), results, value)\n          : false,\n      };\n    });\n\n    const stats =\n      results && results.getFacetByName(attribute)\n        ? results.getFacetStats(attribute)\n        : null;\n    const refinedItem = find(items, (item) => item.isRefined === true);\n    if (!items.some((item) => item.value === '')) {\n      items.push({\n        value: '',\n        isRefined: refinedItem === undefined,\n        noRefinement: !stats,\n        label: 'All',\n      });\n    }\n\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n\n    return {\n      items: transformedItems,\n      currentRefinement,\n      canRefine:\n        transformedItems.length > 0 &&\n        transformedItems.some((item) => item.noRefinement === false),\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const { attribute } = props;\n    const { start, end } = parseItem(\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    );\n    searchParameters = searchParameters.addDisjunctiveFacet(attribute);\n\n    if (typeof start === 'number') {\n      searchParameters = searchParameters.addNumericRefinement(\n        attribute,\n        '>=',\n        start\n      );\n    }\n    if (typeof end === 'number') {\n      searchParameters = searchParameters.addNumericRefinement(\n        attribute,\n        '<=',\n        end\n      );\n    }\n    return searchParameters;\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId(props);\n    const value = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const items = [];\n    const index = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    if (value !== '') {\n      const { label } = find(\n        props.items,\n        (item) => stringifyItem(item) === value\n      );\n      items.push({\n        label: `${props.attribute}: ${label}`,\n        attribute: props.attribute,\n        currentRefinement: label,\n        value: (nextState) =>\n          refine(props, nextState, '', {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue,\n          }),\n      });\n    }\n    return { id, index, items };\n  },\n});\n","import createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n} from '../core/indexUtils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId();\n  const page = 1;\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    page\n  );\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n  return currentRefinement;\n}\n\nfunction refine(props, searchState, nextPage, context) {\n  const id = getId();\n  const nextValue = { [id]: nextPage };\n  const resetPage = false;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\n/**\n * connectPagination connector provides the logic to build a widget that will\n * let the user displays hits corresponding to a certain page.\n * @name connectPagination\n * @kind connector\n * @propType {boolean} [showFirst=true] - Display the first page link.\n * @propType {boolean} [showLast=false] - Display the last page link.\n * @propType {boolean} [showPrevious=true] - Display the previous page link.\n * @propType {boolean} [showNext=true] - Display the next page link.\n * @propType {number} [padding=3] - How many page links to display around the current page.\n * @propType {number} [totalPages=Infinity] - Maximum number of pages to display.\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {number} nbPages - the total of existing pages\n * @providedPropType {number} currentRefinement - the page refinement currently applied\n */\nexport default createConnector({\n  displayName: 'AlgoliaPagination',\n  $$type: 'ais.pagination',\n\n  getProvidedProps(props, searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (!results) {\n      return null;\n    }\n\n    const nbPages = results.nbPages;\n    return {\n      nbPages,\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      canRefine: nbPages > 1,\n    };\n  },\n\n  refine(props, searchState, nextPage) {\n    return refine(props, searchState, nextPage, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUpValue(\n      searchState,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      getId()\n    );\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setPage(\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }) - 1\n    );\n  },\n\n  getMetadata() {\n    return { id: getId() };\n  },\n});\n","import createConnector from '../core/createConnector';\n\n/**\n * connectPoweredBy connector provides the logic to build a widget that\n * will display a link to algolia.\n * @name connectPoweredBy\n * @kind connector\n * @providedPropType {string} url - the url to redirect to algolia\n */\nexport default createConnector({\n  displayName: 'AlgoliaPoweredBy',\n  $$type: 'ais.poweredBy',\n\n  getProvidedProps() {\n    const hostname =\n      typeof window === 'undefined' || typeof window.location === 'undefined'\n        ? ''\n        : window.location.hostname;\n\n    const url =\n      'https://www.algolia.com/?' +\n      'utm_source=react-instantsearch&' +\n      'utm_medium=website&' +\n      `utm_content=${hostname}&` +\n      'utm_campaign=poweredby';\n\n    return {\n      url,\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  getIndexId,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n} from '../core/indexUtils';\n\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in “attributes for faceting”\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * The values inside the attribute must be JavaScript numbers (not strings).\n * @propType {string} attribute - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=0] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nconst namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  const pow = Math.pow(10, precision);\n\n  let min;\n  if (typeof boundaries.min === 'number' && isFinite(boundaries.min)) {\n    min = boundaries.min;\n  } else if (typeof stats.min === 'number' && isFinite(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  let max;\n  if (typeof boundaries.max === 'number' && isFinite(boundaries.max)) {\n    max = boundaries.max;\n  } else if (typeof stats.max === 'number' && isFinite(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max,\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  const { min, max } = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    {}\n  );\n\n  const isFloatPrecision = Boolean(props.precision);\n\n  let nextMin = min;\n  if (typeof nextMin === 'string') {\n    nextMin = isFloatPrecision ? parseFloat(nextMin) : parseInt(nextMin, 10);\n  }\n\n  let nextMax = max;\n  if (typeof nextMax === 'string') {\n    nextMax = isFloatPrecision ? parseFloat(nextMax) : parseInt(nextMax, 10);\n  }\n\n  const refinement = {\n    min: nextMin,\n    max: nextMax,\n  };\n\n  const hasMinBound = props.min !== undefined;\n  const hasMaxBound = props.max !== undefined;\n\n  const hasMinRefinment = refinement.min !== undefined;\n  const hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max,\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  let next;\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction refine(props, searchState, nextRefinement, currentRange, context) {\n  const { min: nextMin, max: nextMax } = nextRefinement;\n  const { min: currentMinRange, max: currentMaxRange } = currentRange;\n\n  const isMinReset = nextMin === undefined || nextMin === '';\n  const isMaxReset = nextMax === undefined || nextMax === '';\n\n  const nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  const nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n\n  const isNextMinValid = isMinReset || isFinite(nextMinAsNumber);\n  const isNextMaxValid = isMaxReset || isFinite(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  const id = getId(props);\n  const resetPage = true;\n  const nextValue = {\n    [id]: {\n      min: nextValueForRefinement(\n        props.min !== undefined,\n        isMinReset,\n        currentMinRange,\n        nextMinAsNumber\n      ),\n      max: nextValueForRefinement(\n        props.max !== undefined,\n        isMaxReset,\n        currentMaxRange,\n        nextMaxAsNumber\n      ),\n    },\n  };\n\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRange',\n  $$type: 'ais.range',\n\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    defaultRefinement: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number,\n    }),\n    min: PropTypes.number,\n    max: PropTypes.number,\n    precision: PropTypes.number,\n    header: PropTypes.node,\n    footer: PropTypes.node,\n  },\n\n  defaultProps: {\n    precision: 0,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    const { attribute, precision, min: minBound, max: maxBound } = props;\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const hasFacet = results && results.getFacetByName(attribute);\n    const stats = hasFacet ? results.getFacetStats(attribute) || {} : {};\n    const facetValues = hasFacet ? results.getFacetValues(attribute) : [];\n\n    const count = facetValues.map((v) => ({\n      value: v.name,\n      count: v.count,\n    }));\n\n    const { min: rangeMin, max: rangeMax } = getCurrentRange(\n      { min: minBound, max: maxBound },\n      stats,\n      precision\n    );\n\n    // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behavior change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax,\n    };\n\n    const currentRefinement = getCurrentRefinement(\n      props,\n      searchState,\n      this._currentRange,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue }\n    );\n\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(\n        currentRefinement,\n        this._currentRange\n      ),\n      count,\n      precision,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(params, props, searchState) {\n    const { attribute } = props;\n    const { min, max } = getCurrentRefinement(\n      props,\n      searchState,\n      this._currentRange,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue }\n    );\n\n    params = params.addDisjunctiveFacet(attribute);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attribute, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attribute, '<=', max);\n    }\n\n    return params;\n  },\n\n  getMetadata(props, searchState) {\n    const { min: minRange, max: maxRange } = this._currentRange;\n    const { min: minValue, max: maxValue } = getCurrentRefinement(\n      props,\n      searchState,\n      this._currentRange,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue }\n    );\n\n    const items = [];\n    const hasMin = minValue !== undefined;\n    const hasMax = maxValue !== undefined;\n    const shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    const shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      const fragments = [\n        hasMin ? `${minValue} <= ` : '',\n        props.attribute,\n        hasMax ? ` <= ${maxValue}` : '',\n      ];\n\n      items.push({\n        label: fragments.join(''),\n        attribute: props.attribute,\n        value: (nextState) =>\n          refine(props, nextState, {}, this._currentRange, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue,\n          }),\n        currentRefinement: getCurrentRefinementWithRange(\n          { min: minValue, max: maxValue },\n          { min: minRange, max: maxRange }\n        ),\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      items,\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  getIndexId,\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n} from '../core/indexUtils';\nimport { unescapeFacetValue } from '../core/utils';\n\nconst namespace = 'refinementList';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    []\n  );\n\n  if (typeof currentRefinement !== 'string') {\n    return currentRefinement;\n  }\n\n  if (currentRefinement) {\n    return [currentRefinement];\n  }\n\n  return [];\n}\n\nfunction getValue(value, props, searchState, context) {\n  const currentRefinement = getCurrentRefinement(props, searchState, context);\n  const isAnewValue = currentRefinement.indexOf(value) === -1;\n  const nextRefinement = isAnewValue\n    ? currentRefinement.concat([value]) // cannot use .push(), it mutates\n    : currentRefinement.filter((selectedValue) => selectedValue !== value); // cannot use .splice(), it mutates\n  return nextRefinement;\n}\n\nfunction getLimit({ showMore, limit, showMoreLimit }) {\n  return showMore ? showMoreLimit : limit;\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId(props);\n  // Setting the value to an empty string ensures that it is persisted in\n  // the URL as an empty value.\n  // This is necessary in the case where `defaultRefinement` contains one\n  // item and we try to deselect it. `nextSelected` would be an empty array,\n  // which would not be persisted to the URL.\n  // {foo: ['bar']} => \"foo[0]=bar\"\n  // {foo: []} => \"\"\n  const nextValue = { [id]: nextRefinement.length > 0 ? nextRefinement : '' };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n/**\n * connectRefinementList connector provides the logic to build a widget that will\n * give the user the ability to choose multiple values for a specific facet.\n * @name connectRefinementList\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in \"attributes for faceting\"\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * @propType {string} attribute - the name of the attribute in the record\n * @propType {boolean} [searchable=false] - allow search inside values\n * @propType {string} [operator=or] - How to apply the refinements. Possible values: 'or' or 'and'.\n * @propType {boolean} [showMore=false] - true if the component should display a button that will expand the number of items\n * @propType {number} [limit=10] - the minimum number of displayed items\n * @propType {number} [showMoreLimit=20] - the maximun number of displayed items. Only used when showMore is set to `true`\n * @propType {string[]} defaultRefinement - the values of the items selected by default. The searchState of this widget takes the form of a list of `string`s, which correspond to the values of all selected refinements. However, when there are no refinements selected, the value of the searchState is an empty string.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{count: number, isRefined: boolean, label: string, value: string}>} items - the list of items the RefinementList can display.\n * @providedPropType {function} searchForItems - a function to toggle a search inside items values\n * @providedPropType {boolean} isFromSearch - a boolean that says if the `items` props contains facet values from the global search or from the search inside items.\n * @providedPropType {boolean} canRefine - a boolean that says whether you can refine\n */\n\nconst sortBy = ['isRefined', 'count:desc', 'name:asc'];\nexport default createConnector({\n  displayName: 'AlgoliaRefinementList',\n  $$type: 'ais.refinementList',\n\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    operator: PropTypes.oneOf(['and', 'or']),\n    showMore: PropTypes.bool,\n    limit: PropTypes.number,\n    showMoreLimit: PropTypes.number,\n    defaultRefinement: PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n    ),\n    searchable: PropTypes.bool,\n    transformItems: PropTypes.func,\n    facetOrdering: PropTypes.bool,\n  },\n\n  defaultProps: {\n    operator: 'or',\n    showMore: false,\n    limit: 10,\n    showMoreLimit: 20,\n    facetOrdering: true,\n  },\n\n  getProvidedProps(\n    props,\n    searchState,\n    searchResults,\n    metadata,\n    searchForFacetValuesResults\n  ) {\n    const { attribute, searchable, indexContextValue, facetOrdering } = props;\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const canRefine =\n      Boolean(results) && Boolean(results.getFacetByName(attribute));\n\n    const isFromSearch = Boolean(\n      searchForFacetValuesResults &&\n        searchForFacetValuesResults[attribute] &&\n        searchForFacetValuesResults.query !== ''\n    );\n\n    // Search For Facet Values is not available with derived helper (used for multi index search)\n    if (searchable && indexContextValue) {\n      throw new Error(\n        'react-instantsearch: searching in *List is not available when used inside a' +\n          ' multi index context'\n      );\n    }\n\n    if (!canRefine) {\n      return {\n        items: [],\n        currentRefinement: getCurrentRefinement(props, searchState, {\n          ais: props.contextValue,\n          multiIndexContext: props.indexContextValue,\n        }),\n        canRefine,\n        isFromSearch,\n        searchable,\n      };\n    }\n\n    const items = isFromSearch\n      ? searchForFacetValuesResults[attribute].map((v) => ({\n          label: v.value,\n          value: getValue(v.escapedValue, props, searchState, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue,\n          }),\n          _highlightResult: { label: { value: v.highlighted } },\n          count: v.count,\n          isRefined: v.isRefined,\n        }))\n      : results\n          .getFacetValues(attribute, { sortBy, facetOrdering })\n          .map((v) => ({\n            label: v.name,\n            value: getValue(v.escapedValue, props, searchState, {\n              ais: props.contextValue,\n              multiIndexContext: props.indexContextValue,\n            }),\n            count: v.count,\n            isRefined: v.isRefined,\n          }));\n\n    const transformedItems = props.transformItems\n      ? props.transformItems(items)\n      : items;\n\n    return {\n      items: transformedItems.slice(0, getLimit(props)),\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      isFromSearch,\n      searchable,\n      canRefine: transformedItems.length > 0,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  searchForFacetValues(props, searchState, nextRefinement) {\n    return {\n      facetName: props.attribute,\n      query: nextRefinement,\n      maxFacetHits: getLimit(props),\n    };\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const { attribute, operator } = props;\n\n    const addKey = operator === 'and' ? 'addFacet' : 'addDisjunctiveFacet';\n    const addRefinementKey = `${addKey}Refinement`;\n\n    searchParameters = searchParameters.setQueryParameters({\n      maxValuesPerFacet: Math.max(\n        searchParameters.maxValuesPerFacet || 0,\n        getLimit(props)\n      ),\n    });\n\n    searchParameters = searchParameters[addKey](attribute);\n\n    return getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    }).reduce(\n      (res, val) => res[addRefinementKey](attribute, val),\n      searchParameters\n    );\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId(props);\n    const context = {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    };\n    return {\n      id,\n      index: getIndexId(context),\n      items:\n        getCurrentRefinement(props, searchState, context).length > 0\n          ? [\n              {\n                attribute: props.attribute,\n                label: `${props.attribute}: `,\n                currentRefinement: getCurrentRefinement(\n                  props,\n                  searchState,\n                  context\n                ),\n                value: (nextState) => refine(props, nextState, [], context),\n                items: getCurrentRefinement(props, searchState, context).map(\n                  (item) => ({\n                    label: unescapeFacetValue(`${item}`),\n                    value: (nextState) => {\n                      const nextSelectedItems = getCurrentRefinement(\n                        props,\n                        nextState,\n                        context\n                      ).filter((other) => other !== item);\n                      return refine(\n                        props,\n                        searchState,\n                        nextSelectedItems,\n                        context\n                      );\n                    },\n                  })\n                ),\n              },\n            ]\n          : [],\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  getCurrentRefinementValue,\n  hasMultipleIndices,\n  getIndexId,\n} from '../core/indexUtils';\nimport { shallowEqual, omit } from '../core/utils';\n\n/**\n * connectScrollTo connector provides the logic to build a widget that will\n * let the page scroll to a certain point.\n * @name connectScrollTo\n * @kind connector\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\n */\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  $$type: 'ais.scrollTo',\n\n  propTypes: {\n    scrollOn: PropTypes.string,\n  },\n\n  defaultProps: {\n    scrollOn: 'page',\n  },\n\n  getProvidedProps(props, searchState) {\n    const id = props.scrollOn;\n    const value = getCurrentRefinementValue(\n      props,\n      searchState,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      id,\n      null\n    );\n\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    }\n\n    // Get the subpart of the state that interest us\n    if (\n      hasMultipleIndices({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    ) {\n      searchState = searchState.indices\n        ? searchState.indices[\n            getIndexId({\n              ais: props.contextValue,\n              multiIndexContext: props.indexContextValue,\n            })\n          ]\n        : {};\n    }\n\n    // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n    const cleanedSearchState = omit(searchState, ['configure', id]);\n\n    const hasNotChanged = shallowEqual(\n      this._prevSearchState,\n      cleanedSearchState\n    );\n\n    this._prevSearchState = cleanedSearchState;\n\n    return { value, hasNotChanged };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n  getIndexId,\n} from '../core/indexUtils';\n\nfunction getId() {\n  return 'query';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId(props);\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    ''\n  );\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n  return '';\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId();\n  const nextValue = { [id]: nextRefinement };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, getId());\n}\n\n/**\n * connectSearchBox connector provides the logic to build a widget that will\n * let the user search for a query\n * @name connectSearchBox\n * @kind connector\n * @propType {string} [defaultRefinement] - Provide a default value for the query\n * @providedPropType {function} refine - a function to change the current query\n * @providedPropType {string} currentRefinement - the current query used\n * @providedPropType {boolean} isSearchStalled - a flag that indicates if InstantSearch has detected that searches are stalled\n */\nexport default createConnector({\n  displayName: 'AlgoliaSearchBox',\n  $$type: 'ais.searchBox',\n\n  propTypes: {\n    defaultRefinement: PropTypes.string,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    return {\n      currentRefinement: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      isSearchStalled: searchResults.isSearchStalled,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQuery(\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    );\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId(props);\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    return {\n      id,\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      items:\n        currentRefinement === null\n          ? []\n          : [\n              {\n                label: `${id}: ${currentRefinement}`,\n                value: (nextState) =>\n                  refine(props, nextState, '', {\n                    ais: props.contextValue,\n                    multiIndexContext: props.indexContextValue,\n                  }),\n                currentRefinement,\n              },\n            ],\n    };\n  },\n});\n","import createConnector from '../core/createConnector';\nimport {\n  refineValue,\n  getCurrentRefinementValue,\n  getResults,\n  // @ts-ignore\n} from '../core/indexUtils';\n\nimport type { ConnectedProps } from '../core/createConnector';\n\nfunction getId() {\n  return 'relevancyStrictness';\n}\n\nfunction getCurrentRefinement(\n  props: ConnectedProps<any>,\n  searchState: any,\n  context: any\n) {\n  const id = getId();\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id\n  );\n\n  return currentRefinement;\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRelevantSort',\n  $$type: 'ais.relevantSort',\n\n  getProvidedProps(props, _searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (!results) {\n      return {\n        isVirtualReplica: false,\n        isRelevantSorted: false,\n      };\n    }\n\n    return {\n      isVirtualReplica: results.appliedRelevancyStrictness !== undefined,\n      isRelevantSorted:\n        results.appliedRelevancyStrictness !== undefined &&\n        results.appliedRelevancyStrictness > 0,\n    };\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameter(\n      'relevancyStrictness',\n      getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      })\n    );\n  },\n\n  refine(props, searchState, nextRefinement) {\n    const nextValue = {\n      [getId()]: nextRefinement,\n    };\n    const resetPage = true;\n\n    return refineValue(\n      searchState,\n      nextValue,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      resetPage\n    );\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n} from '../core/indexUtils';\n\nfunction getId() {\n  return 'sortBy';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const id = getId(props);\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    null\n  );\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n  return null;\n}\n\n/**\n * The connectSortBy connector provides the logic to build a widget that will\n *  display a list of indices. This allows a user to change how the hits are being sorted.\n * @name connectSortBy\n * @requirements Algolia handles sorting by creating replica indices. [Read more about sorting](https://www.algolia.com/doc/guides/relevance/sorting/) on\n * the Algolia website.\n * @kind connector\n * @propType {string} defaultRefinement - The default selected index.\n * @propType {{value: string, label: string}[]} items - The list of indexes to search in.\n * @propType {function} [transformItems] - Function to modify the items being displayed, e.g. for filtering or sorting them. Takes an items as parameter and expects it back in return.\n * @providedPropType {function} refine - a function to remove a single filter\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string[]} currentRefinement - the refinement currently applied\n * @providedPropType {array.<{isRefined: boolean, label?: string, value: string}>} items - the list of items the HitsPerPage can display.  If no label provided, the value will be displayed.\n */\nexport default createConnector({\n  displayName: 'AlgoliaSortBy',\n  $$type: 'ais.sortBy',\n\n  propTypes: {\n    defaultRefinement: PropTypes.string,\n    items: PropTypes.arrayOf(\n      PropTypes.shape({\n        label: PropTypes.string,\n        value: PropTypes.string.isRequired,\n      })\n    ).isRequired,\n    transformItems: PropTypes.func,\n  },\n\n  getProvidedProps(props, searchState) {\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const items = props.items.map((item) =>\n      item.value === currentRefinement\n        ? { ...item, isRefined: true }\n        : { ...item, isRefined: false }\n    );\n    return {\n      items: props.transformItems ? props.transformItems(items) : items,\n      currentRefinement,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    const id = getId();\n    const nextValue = { [id]: nextRefinement };\n    const resetPage = true;\n    return refineValue(\n      searchState,\n      nextValue,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      resetPage\n    );\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUpValue(\n      searchState,\n      { ais: props.contextValue, multiIndexContext: props.indexContextValue },\n      getId()\n    );\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const selectedIndex = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    return searchParameters.setIndex(selectedIndex);\n  },\n\n  getMetadata() {\n    return { id: getId() };\n  },\n});\n","import createConnector from '../core/createConnector';\nimport { getResults } from '../core/indexUtils';\n\n/**\n * The `connectStateResults` connector provides a way to access the `searchState` and the `searchResults`\n * of InstantSearch.\n * For instance this connector allows you to create results/noResults or query/noQuery pages.\n * @name connectStateResults\n * @kind connector\n * @providedPropType {object} searchState - The search state of the instant search component. <br/><br/> See: [Search state structure](https://community.algolia.com/react-instantsearch/guide/Search_state.html)\n * @providedPropType {object} searchResults - The search results. <br/><br/> In case of multiple indices: if used under `<Index>`, results will be those of the corresponding index otherwise it'll be those of the root index  See: [Search results structure](https://community.algolia.com/algoliasearch-helper-js/reference.html#searchresults)\n * @providedPropType {object} allSearchResults - In case of multiple indices you can retrieve all the results\n * @providedPropType {string} error - If the search failed, the error will be logged here.\n * @providedPropType {boolean} searching - If there is a search in progress.\n * @providedPropType {boolean} isSearchStalled - Flag that indicates if React InstantSearch has detected that searches are stalled.\n * @providedPropType {boolean} searchingForFacetValues - If there is a search in a list in progress.\n * @providedPropType {object} props - component props.\n * @example\n * import React from 'react';\n * import algoliasearch from 'algoliasearch/lite';\n * import { InstantSearch, SearchBox, Hits, connectStateResults } from 'react-instantsearch-dom';\n *\n * const searchClient = algoliasearch(\n *   'latency',\n *   '6be0576ff61c053d5f9a3225e2a90f76'\n * );\n *\n * const Content = connectStateResults(({ searchState, searchResults }) => {\n *   const hasResults = searchResults && searchResults.nbHits !== 0;\n *\n *    return (\n *      <div>\n *        <div hidden={!hasResults}>\n *          <Hits />\n *        </div>\n *        <div hidden={hasResults}>\n *          <div>No results has been found for {searchState.query}</div>\n *        </div>\n *      </div>\n *    );\n * });\n *\n * const App = () => (\n *   <InstantSearch\n *      searchClient={searchClient}\n *      indexName=\"instant_search\"\n *    >\n *      <SearchBox />\n *      <Content />\n *    </InstantSearch>\n * );\n */\nexport default createConnector({\n  displayName: 'AlgoliaStateResults',\n  $$type: 'ais.stateResults',\n\n  getProvidedProps(props, searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    return {\n      searchState,\n      searchResults: results,\n      allSearchResults: searchResults.results,\n      searching: searchResults.searching,\n      isSearchStalled: searchResults.isSearchStalled,\n      error: searchResults.error,\n      searchingForFacetValues: searchResults.searchingForFacetValues,\n      props,\n    };\n  },\n});\n","import createConnector from '../core/createConnector';\n// @ts-ignore\nimport { getResults } from '../core/indexUtils';\n\n/**\n * connectStats connector provides the logic to build a widget that will\n *  displays algolia search statistics (hits number and processing time).\n * @name connectStats\n * @kind connector\n * @providedPropType {number} nbHits - number of hits returned by Algolia.\n * @providedPropType {number} nbSortedHits - number of sorted hits returned by Algolia.\n * @providedPropType {number} processingTimeMS - the time in ms took by Algolia to search for results.\n */\nexport default createConnector({\n  displayName: 'AlgoliaStats',\n  $$type: 'ais.stats',\n\n  getProvidedProps(props, _searchState, searchResults) {\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (!results) {\n      return null;\n    }\n\n    return {\n      areHitsSorted:\n        results.appliedRelevancyStrictness !== undefined &&\n        results.appliedRelevancyStrictness > 0 &&\n        results.nbHits !== results.nbSortedHits,\n      nbHits: results.nbHits,\n      nbSortedHits: results.nbSortedHits,\n      processingTimeMS: results.processingTimeMS,\n    };\n  },\n});\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  getIndexId,\n  getResults,\n  refineValue,\n  getCurrentRefinementValue,\n} from '../core/indexUtils';\nimport { find } from '../core/utils';\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nconst namespace = 'toggle';\n\nconst falsyStrings = ['0', 'false', 'null', 'undefined'];\n\nfunction getCurrentRefinement(props, searchState, context) {\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    `${namespace}.${getId(props)}`,\n    false\n  );\n\n  if (falsyStrings.indexOf(currentRefinement) !== -1) {\n    return false;\n  }\n\n  return Boolean(currentRefinement);\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId(props);\n  const nextValue = { [id]: nextRefinement ? nextRefinement : false };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, `${namespace}.${getId(props)}`);\n}\n\n/**\n * connectToggleRefinement connector provides the logic to build a widget that will\n * provides an on/off filtering feature based on an attribute value.\n * @name connectToggleRefinement\n * @kind connector\n * @requirements To use this widget, you'll need an attribute to toggle on.\n *\n * You can't toggle on null or not-null values. If you want to address this particular use-case you'll need to compute an\n * extra boolean attribute saying if the value exists or not. See this [thread](https://discourse.algolia.com/t/how-to-create-a-toggle-for-the-absence-of-a-string-attribute/2460) for more details.\n *\n * @propType {string} attribute - Name of the attribute on which to apply the `value` refinement. Required when `value` is present.\n * @propType {string} label - Label for the toggle.\n * @propType {string} value - Value of the refinement to apply on `attribute`.\n * @propType {boolean} [defaultRefinement=false] - Default searchState of the widget. Should the toggle be checked by default?\n * @providedPropType {boolean} currentRefinement - `true` when the refinement is applied, `false` otherwise\n * @providedPropType {object} count - an object that contains the count for `checked` and `unchecked` state\n * @providedPropType {function} refine - a function to toggle a refinement\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n */\nexport default createConnector({\n  displayName: 'AlgoliaToggle',\n  $$type: 'ais.toggle',\n\n  propTypes: {\n    label: PropTypes.string.isRequired,\n    attribute: PropTypes.string.isRequired,\n    value: PropTypes.any.isRequired,\n    filter: PropTypes.func,\n    defaultRefinement: PropTypes.bool,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    const { attribute, value } = props;\n    const results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const currentRefinement = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    const allFacetValues =\n      results && results.getFacetByName(attribute)\n        ? results.getFacetValues(attribute)\n        : null;\n\n    const facetValue =\n      // Use null to always be consistent with type of the value\n      // count: number | null\n      allFacetValues && allFacetValues.length\n        ? find(allFacetValues, (item) => item.name === value.toString())\n        : null;\n\n    const facetValueCount = facetValue && facetValue.count;\n    const allFacetValuesCount =\n      // Use null to always be consistent with type of the value\n      // count: number | null\n      allFacetValues && allFacetValues.length\n        ? allFacetValues.reduce((acc, item) => acc + item.count, 0)\n        : null;\n\n    const canRefine = currentRefinement\n      ? allFacetValuesCount !== null && allFacetValuesCount > 0\n      : facetValueCount !== null && facetValueCount > 0;\n\n    const count = {\n      checked: allFacetValuesCount,\n      unchecked: facetValueCount,\n    };\n\n    return {\n      currentRefinement,\n      canRefine,\n      count,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const { attribute, value, filter } = props;\n    const checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    let nextSearchParameters = searchParameters.addDisjunctiveFacet(attribute);\n\n    if (checked) {\n      nextSearchParameters = nextSearchParameters.addDisjunctiveFacetRefinement(\n        attribute,\n        value\n      );\n\n      if (filter) {\n        nextSearchParameters = filter(nextSearchParameters);\n      }\n    }\n\n    return nextSearchParameters;\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId(props);\n    const checked = getCurrentRefinement(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const items = [];\n    const index = getIndexId({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n\n    if (checked) {\n      items.push({\n        label: props.label,\n        currentRefinement: checked,\n        attribute: props.attribute,\n        value: (nextState) =>\n          refine(props, nextState, false, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue,\n          }),\n      });\n    }\n\n    return { id, index, items };\n  },\n});\n","import createConnector from '../core/createConnector';\n// @ts-ignore\nimport { getResults } from '../core/indexUtils';\n\ntype Results = { index: string };\ntype Hit = { objectID: string; __position: number; __queryID: string };\n\ntype InsightsClient = (\n  method: InsightsClientMethod,\n  payload: InsightsClientPayload\n) => void;\n\ntype InsightsClientMethod =\n  | 'clickedObjectIDsAfterSearch'\n  | 'convertedObjectIDsAfterSearch';\n\ntype InsightsClientPayload = {\n  index: string;\n  queryID: string;\n  eventName: string;\n  objectIDs: string[];\n  positions?: number[];\n};\n\nfunction inferPayload({\n  method,\n  results,\n  currentHit,\n}: {\n  method: InsightsClientMethod;\n  results: Results;\n  currentHit: Hit;\n}): Omit<InsightsClientPayload, 'eventName'> {\n  const { index } = results;\n  const queryID = currentHit.__queryID;\n  const objectIDs = [currentHit.objectID];\n\n  if (!queryID) {\n    throw new Error(`Could not infer \\`queryID\\`. Ensure \\`clickAnalytics: true\\` was added with the Configure widget.\nSee: https://alg.li/VpPpLt`);\n  }\n\n  switch (method) {\n    case 'clickedObjectIDsAfterSearch': {\n      const positions = [currentHit.__position];\n      return { index, queryID, objectIDs, positions };\n    }\n\n    case 'convertedObjectIDsAfterSearch':\n      return { index, queryID, objectIDs };\n\n    default:\n      throw new Error(\n        `Unsupported method \"${method}\" passed to the insights function. The supported methods are: \"clickedObjectIDsAfterSearch\", \"convertedObjectIDsAfterSearch\".`\n      );\n  }\n}\n\nconst wrapInsightsClient =\n  (aa: InsightsClient, results: Results, currentHit: Hit) =>\n  (method: InsightsClientMethod, payload: Partial<InsightsClientPayload>) => {\n    if (typeof aa !== 'function') {\n      throw new TypeError(`Expected insightsClient to be a Function`);\n    }\n    const inferredPayload = inferPayload({ method, results, currentHit });\n    aa(method, { ...inferredPayload, ...payload } as any);\n  };\n\nexport default (insightsClient: InsightsClient) =>\n  createConnector({\n    displayName: 'AlgoliaInsights',\n    $$type: 'ais.insights',\n\n    getProvidedProps(props, _, searchResults) {\n      const results: Results = getResults(searchResults, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      });\n\n      const insights = wrapInsightsClient(insightsClient, results, props.hit);\n      return { insights };\n    },\n  });\n","import PropTypes from 'prop-types';\n\nimport createConnector from '../core/createConnector';\nimport {\n  cleanUpValue,\n  refineValue,\n  getCurrentRefinementValue,\n  getIndexId,\n} from '../core/indexUtils';\n\nfunction getId() {\n  return 'query';\n}\n\nfunction getAdditionalId() {\n  return 'additionalVoiceParameters';\n}\n\nfunction getCurrentRefinementQuery(props, searchState, context) {\n  const id = getId();\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    ''\n  );\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n  return '';\n}\n\nfunction getCurrentRefinementAdditional(props, searchState, context) {\n  const id = getAdditionalId();\n  const currentRefinement = getCurrentRefinementValue(\n    props,\n    searchState,\n    context,\n    id,\n    ''\n  );\n\n  if (currentRefinement) {\n    return currentRefinement;\n  }\n  return {};\n}\n\nfunction refine(props, searchState, nextRefinement, context) {\n  const id = getId();\n  const voiceParams = getAdditionalId();\n  const queryLanguages = props.language\n    ? { queryLanguages: [props.language.split('-')[0]] }\n    : {};\n  const additionalQueryParameters =\n    typeof props.additionalQueryParameters === 'function'\n      ? {\n          ignorePlurals: true,\n          removeStopWords: true,\n          optionalWords: nextRefinement,\n          ...props.additionalQueryParameters({ query: nextRefinement }),\n        }\n      : {};\n  const nextValue = {\n    [id]: nextRefinement,\n    [voiceParams]: {\n      ...queryLanguages,\n      ...additionalQueryParameters,\n    },\n  };\n  const resetPage = true;\n  return refineValue(searchState, nextValue, context, resetPage);\n}\n\nfunction cleanUp(props, searchState, context) {\n  const interimState = cleanUpValue(searchState, context, getId());\n  return cleanUpValue(interimState, context, getAdditionalId());\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaVoiceSearch',\n  $$type: 'ais.voiceSearch',\n\n  propTypes: {\n    defaultRefinement: PropTypes.string,\n  },\n\n  getProvidedProps(props, searchState, searchResults) {\n    return {\n      currentRefinement: getCurrentRefinementQuery(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      isSearchStalled: searchResults.isSearchStalled,\n    };\n  },\n\n  refine(props, searchState, nextRefinement) {\n    return refine(props, searchState, nextRefinement, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  cleanUp(props, searchState) {\n    return cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n  },\n\n  getSearchParameters(searchParameters, props, searchState) {\n    const query = getCurrentRefinementQuery(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    const additionalParams = getCurrentRefinementAdditional(\n      props,\n      searchState,\n      {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }\n    );\n\n    return searchParameters\n      .setQuery(query)\n      .setQueryParameters(additionalParams);\n  },\n\n  getMetadata(props, searchState) {\n    const id = getId();\n    const currentRefinement = getCurrentRefinementQuery(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue,\n    });\n    return {\n      id,\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue,\n      }),\n      items:\n        currentRefinement === null\n          ? []\n          : [\n              {\n                label: `${id}: ${currentRefinement}`,\n                value: (nextState) =>\n                  refine(props, nextState, '', {\n                    ais: props.contextValue,\n                    multiIndexContext: props.indexContextValue,\n                  }),\n                currentRefinement,\n              },\n            ],\n    };\n  },\n});\n","// Core\nexport { default as createConnector } from './core/createConnector';\nexport {\n  instantSearchContext,\n  InstantSearchConsumer,\n  InstantSearchProvider,\n} from './core/context';\n\n// Utils\n// @ts-ignore not yet typed\nexport { HIGHLIGHT_TAGS } from './core/highlight';\n// @ts-ignore not yet typed\nexport { default as version } from './core/version';\n// @ts-ignore not yet typed\nexport { default as translatable } from './core/translatable';\n\n// Widgets\n// @ts-ignore not yet typed\nexport { default as Configure } from './widgets/Configure';\nexport { default as ExperimentalConfigureRelatedItems } from './widgets/ConfigureRelatedItems';\n\nimport { default as connectDynamicWidgets } from './connectors/connectDynamicWidgets';\nimport { default as DynamicWidgets } from './widgets/DynamicWidgets';\n/** @deprecated use DynamicWidgets */\nconst ExperimentalDynamicWidgets = DynamicWidgets;\nexport { ExperimentalDynamicWidgets, DynamicWidgets };\n\nexport { default as QueryRuleContext } from './widgets/QueryRuleContext';\nexport { default as Index } from './widgets/Index';\nexport { default as InstantSearch } from './widgets/InstantSearch';\n\n// Connectors\n// @ts-ignore not yet typed\nexport { default as connectAutoComplete } from './connectors/connectAutoComplete';\n// @ts-ignore not yet typed\nexport { default as connectBreadcrumb } from './connectors/connectBreadcrumb';\n// @ts-ignore not yet typed\nexport { default as connectConfigure } from './connectors/connectConfigure';\nexport { default as EXPERIMENTAL_connectConfigureRelatedItems } from './connectors/connectConfigureRelatedItems';\n// @ts-ignore not yet typed\nexport { default as connectCurrentRefinements } from './connectors/connectCurrentRefinements';\n\n/** @deprecated use connectDynamicWidgets */\nconst EXPERIMENTAL_connectDynamicWidgets = connectDynamicWidgets;\nexport { connectDynamicWidgets, EXPERIMENTAL_connectDynamicWidgets };\n\n// @ts-ignore not yet typed\nexport { default as connectGeoSearch } from './connectors/connectGeoSearch';\n// @ts-ignore not yet typed\nexport { default as connectHierarchicalMenu } from './connectors/connectHierarchicalMenu';\n// @ts-ignore not yet typed\nexport { default as connectHighlight } from './connectors/connectHighlight';\n// @ts-ignore not yet typed\nexport { default as connectHits } from './connectors/connectHits';\n// @ts-ignore not yet typed\nexport { default as connectHitsPerPage } from './connectors/connectHitsPerPage';\n// @ts-ignore not yet typed\nexport { default as connectInfiniteHits } from './connectors/connectInfiniteHits';\n// @ts-ignore not yet typed\nexport { default as connectMenu } from './connectors/connectMenu';\n// @ts-ignore not yet typed\nexport { default as connectNumericMenu } from './connectors/connectNumericMenu';\n// @ts-ignore not yet typed\nexport { default as connectPagination } from './connectors/connectPagination';\n// @ts-ignore not yet typed\nexport { default as connectPoweredBy } from './connectors/connectPoweredBy';\n// @ts-ignore not yet typed\nexport { default as connectQueryRules } from './connectors/connectQueryRules';\n// @ts-ignore not yet typed\nexport { default as connectRange } from './connectors/connectRange';\n// @ts-ignore not yet typed\nexport { default as connectRefinementList } from './connectors/connectRefinementList';\n// @ts-ignore not yet typed\nexport { default as connectScrollTo } from './connectors/connectScrollTo';\n// @ts-ignore not yet typed\nexport { default as connectSearchBox } from './connectors/connectSearchBox';\n// @ts-ignore not yet typed\nexport { default as connectRelevantSort } from './connectors/connectRelevantSort';\n// @ts-ignore not yet typed\nexport { default as connectSortBy } from './connectors/connectSortBy';\n// @ts-ignore not yet typed\nexport { default as connectStateResults } from './connectors/connectStateResults';\n// @ts-ignore not yet typed\nexport { default as connectStats } from './connectors/connectStats';\n// @ts-ignore not yet typed\nexport { default as connectToggleRefinement } from './connectors/connectToggleRefinement';\n// @ts-ignore not yet typed\nexport { default as connectHitInsights } from './connectors/connectHitInsights';\n// @ts-ignore not yet typed\nexport { default as connectVoiceSearch } from './connectors/connectVoiceSearch';\n\n// Types\nexport * from './types';\n","import React, { Component } from 'react';\n\nconst withKeysPropType = (keys) => (props, propName, componentName) => {\n  const prop = props[propName];\n  if (prop) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of Object.keys(prop)) {\n      if (keys.indexOf(key) === -1) {\n        return new Error(\n          `Unknown \\`${propName}\\` key \\`${key}\\`. Check the render method ` +\n            `of \\`${componentName}\\`.`\n        );\n      }\n    }\n  }\n  return undefined;\n};\n\nexport default function translatable(defaultTranslations) {\n  return (Composed) => {\n    class Translatable extends Component {\n      translate = (key, ...params) => {\n        const { translations } = this.props;\n\n        const translation =\n          translations && translations.hasOwnProperty(key)\n            ? translations[key]\n            : defaultTranslations[key];\n\n        if (typeof translation === 'function') {\n          return translation(...params);\n        }\n\n        return translation;\n      };\n\n      render() {\n        return <Composed translate={this.translate} {...this.props} />;\n      }\n    }\n\n    const name = Composed.displayName || Composed.name || 'UnknownComponent';\n\n    Translatable.displayName = `Translatable(${name})`;\n\n    Translatable.propTypes = {\n      translations: withKeysPropType(Object.keys(defaultTranslations)),\n    };\n\n    return Translatable;\n  };\n}\n"],"names":["hasElementType","Element","hasMap","Map","hasSet","Set","hasArrayBuffer","ArrayBuffer","defer","f","resolved","then","a","b","equal","constructor","length","i","keys","it","Array","isArray","size","entries","next","done","has","value","get","isView","RegExp","source","flags","valueOf","Object","prototype","toString","hasOwnProperty","call","$$typeof","error","message","match","console","warn","instantSearchContext","createContext","onInternalStateUpdate","createHrefForState","onSearchForFacetValues","onSearchStateChange","onSearchParameters","store","widgetsManager","mainTargetedIndex","InstantSearchConsumer","Consumer","InstantSearchProvider","Provider","undefined","IndexConsumer","IndexProvider","hasOwn","shallowEqual","objA","objB","keysA","keysB","getDisplayName","Component","displayName","name","Promise","resolve","removeEmptyKey","obj","forEach","key","_typeof","objectHasKeys","addAbsolutePositions","hits","hitsPerPage","page","map","hit","index","__position","addQueryID","queryID","__queryID","find","array","comparator","object","omit","excluded","target","sourceKeys","indexOf","getPropertyByPath","path","replace","split","reduce","current","unescapeFacetValue","createConnectorWithContext","connectorDesc","Composed","additionalWidgetProperties","Connector","isWidget","getSearchParameters","getMetadata","transitionState","_inherits","props","_classCallCheck","_defineProperty","_this","providedProps","getProvidedProps","args","contextValue","refine","getState","widgets","searchForFacetValues","bind","ais","multiIndexContext","indexContextValue","_createClass","this","cleanupTimerRef","clearTimeout","unsubscribe","subscribe","_this2","isUnmounting","setState","unregisterWidget","registerWidget","nextProps","nextState","shouldComponentUpdate","state","propsEqual","prevProps","isEqual","update","setTimeout","_this3","cleanUp","results","resultsFacetValues","searching","searchingForFacetValues","isSearchStalled","metadata","searchParameters","nextWidgetsState","prevWidgetsState","refineProps","searchForFacetValuesProps","createURL","searchForItems","React","$$type","$$widgetType","defaultProps","Error","HIGHLIGHT_TAGS","highlightPreTag","highlightPostTag","parseHighlightedAttribute","isHighlighted","preTag","postTag","_ref$highlightedValue","highlightedValue","splitByPreTag","firstValue","shift","elements","push","splitByPostTag","getIndexId","context","hasMultipleIndices","targetedIndex","getResults","searchResults","indexId","refineValue","searchState","nextRefinement","resetPage","namespace","indices","getNamespaceAndAttributeName","id","parts","attributeName","getCurrentRefinementValue","defaultValue","multiIndex","defaultRefinement","cleanUpValue","attribute","Boolean","indexSearchState","getId","createConnector","children","items","setQueryParameters","prevSearchState","nextSearchState","propKeys","nonPresentKeys","_props","filter","prop","subState","configureState","acc","item","connectConfigure","performance","global","self","window","now","mozNow","msNow","oNow","webkitNow","Symbol","for","c","d","e","g","h","k","l","m","n","p","q","r","t","v","w","x","y","z","u","type","A","module","require$$0","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","propName","componentName","location","propFullName","secret","err","getShim","ReactPropTypes","isRequired","bigint","bool","func","number","string","symbol","any","arrayOf","element","elementType","instanceOf","node","objectOf","oneOf","oneOfType","shape","exact","checkPropTypes","PropTypes","EventEmitter","_events","_maxListeners","isFunction","arg","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","TypeError","emit","handler","len","listeners","er","arguments","slice","apply","on","addListener","listener","newListener","warned","trace","once","fired","removeListener","list","position","splice","removeAllListeners","ret","listenerCount","evlistener","emitter","ctor","superCtor","create","enumerable","writable","configurable","DerivedHelper","mainHelper","fn","main","lastResults","detach","detachDerivedHelper","getModifiedState","parameters","String","isObjectOrArrayOrFunction","_merge","sourceVal","targetVal","sortObject","sort","curr","reduceRight","requestBuilder","_getQueries","queries","indexName","params","_getHitsSearchParams","getRefinedDisjunctiveFacets","refinedFacet","_getDisjunctiveFacetSearchParams","getRefinedHierarchicalFacets","filtersMap","hierarchicalFacet","getHierarchicalFacetByName","currentRefinement","getHierarchicalRefinement","separator","_getHierarchicalFacetSeparator","segment","level","concat","attributes","join","hasHierarchicalFacetFilter","some","filteredFacetFilters","facetFilters","facetFilter","filtered","filterValue","parent","facets","disjunctiveFacets","_getHitsHierarchicalFacetsAttributes","_getFacetFilters","numericFilters","_getNumericFilters","tagFilters","_getTagFilters","additionalParams","merge","getQueryParams","facet","hierarchicalRootLevel","analytics","clickAnalytics","_getDisjunctiveHierarchicalFacetAttribute","facetName","numericRefinements","operators","operator","values","vs","tagRefinements","facetsRefinements","facetsExcludes","facetValue","disjunctiveFacetsRefinements","hierarchicalFacetsRefinements","orFilters","facetValues","attributesIndex","rootPath","_getHierarchicalRootPath","lastIndexOf","attributeToRefine","hierarchicalFacets","allAttributes","newAttributes","hierarchicalRefinement","rootLevel","parentLevel","attributeIndex","getSearchForFacetQuery","query","maxFacetHits","stateForSearchForFacetValues","isDisjunctiveFacet","clearRefinements","searchForFacetSearchParameters","facetQuery","arr1","arr2","valToNumber","parseFloat","lib","addRefinement","refinementList","mod","isRefined","valueAsString","facetRefinement","defaultsPure","removeRefinement","clearRefinement","toggleRefinement","refinementType","hasChanged","newRefinementList","memo","facetList","refinementValue","containsRefinements","isEqualNumericRefinement","every","el","SearchParameters","newParameters","_parseNumbers","userToken","test","paramName","isKeyKnown","PARAMETERS","isValueDefined","partialState","numbers","parsedValue","insideBoundingBox","geoRect","parsedValues","vPrime","make","instance","toggleHierarchicalFacetRefinement","validate","currentState","patch","_clearNumericRefinements","RefinementList","clearTags","setIndex","setQuery","newQuery","setPage","newPage","setFacets","setDisjunctiveFacets","setHitsPerPage","setTypoTolerance","typoTolerance","addNumericRefinement","val","isNumericRefined","getConjunctiveRefinements","isConjunctiveFacet","getDisjunctiveRefinements","getExcludeRefinements","removeNumericRefinement","paramValue","op","getNumericRefinements","getNumericRefinement","newNumericRefinements","operatorList","outValues","addFacet","addDisjunctiveFacet","addHierarchicalFacet","isHierarchicalFacet","addFacetRefinement","addExcludeRefinement","addDisjunctiveFacetRefinement","addTagRefinement","tag","isTagRefined","modification","removeFacet","removeDisjunctiveFacet","removeHierarchicalFacet","removeFacetRefinement","removeExcludeRefinement","removeDisjunctiveFacetRefinement","removeTagRefinement","toggleFacetRefinement","toggleConjunctiveFacetRefinement","toggleDisjunctiveFacetRefinement","toggleExcludeFacetRefinement","addHierarchicalFacetRefinement","isHierarchicalFacetRefined","removeHierarchicalFacetRefinement","toggleTagRefinement","isFacetRefined","isExcludeRefined","isDisjunctiveFacetRefined","refinements","isOperatorDefined","searchedValue","isAttributeValueDefined","currentValue","disjunctiveNumericRefinedFacets","intersection","getUnrefinedDisjunctiveFacets","refinedFacets","managedParameters","queryParams","setQueryParameter","parameter","nextWithNumbers","previousPlainObject","nextPlainObject","previous","isPreviousValueDefined","isNextValueDefined","_getHierarchicalFacetSortBy","sortBy","_getHierarchicalShowParentLevel","showParentLevel","hierarchicalFacetName","getHierarchicalFacetBreadcrumb","refinement","part","trim","JSON","stringify","defaults","defaultInstructions","out","sortInstruction","matchingDefault","defaultInstruction","collection","iteratees","orders","result","criteria","iteratee","other","res","valIsDefined","valIsNull","othIsDefined","othIsNull","hierarchicalFacetResult","hierarchicalFacetIndex","generateTreeFn","hierarchicalTree","currentHierarchicalLevel","picked","data","subtree","tuple","parentPath","hierarchicalSeparator","hierarchicalRootPath","hierarchicalShowParentLevel","orderBy","exhaustive","facetCount","escapedValue","escapeFacetValue","count","hierarchicalFacetRefinement","prepareHierarchicalFacetSortBy","rootExhaustive","facetResult","fv","getIndices","idx","assignFacetStats","dest","facetStats","stats","SearchResults","options","mainSubResponse","_rawResults","processingTimeMS","sum","facetsIndices","disjunctiveFacetsIndices","nextDisjunctiveResult","mainFacets","facetKey","hierarchicalAttributeName","isFacetDisjunctive","isFacetConjunctive","facetValueObject","facetIndex","idxAttributeName","findIndex","exhaustiveFacetsCount","facets_stats","compact","disjunctiveFacet","dfacet","dataFromMainRequest","facetResults","defaultData","root","excludes","generateHierarchicalTree","_state","extractNormalizedFacetValues","predicate","hierarchicalFacetValues","currentRefinementSplit","isExcluded","unshift","setIsRefined","depth","child","getFacetStatsIfAvailable","getRefinement","resultsFacets","getFacetByName","DEFAULT_SORT","getFacetValues","opts","facetOrdering","recSort","sortFn","names","sortedChildren","childNode","renderingContent","orderedFacets","remainingFacets","reverseOrder","order","sortRemainingBy","ordering","formatSort","getFacetStats","getRefinements","facetDeclaration","rootFacet","intermediateFacet","newFacet","numericValue","AlgoliaSearchHelper","client","addAlgoliaAgent","setClient","_queryId","_lastQueryIdReceived","derivedHelpers","_currentNbQueries","setCurrentPage","_change","isPageReset","getCurrentPage","search","_search","onlyWithDerivedHelpers","searchOnlyWithDerivedHelpers","getQuery","searchOnce","cb","tempState","content","_originalResponse","catch","findAnswers","derivedHelper","derivedState","attributesForPrediction","nbHits","errorMessage","initIndex","queryLanguages","userState","isDisjunctive","clientHasSFFV","clientHasInitIndex","algoliaQuery","searchForFacetValuesPromise","response","facetHits","addDisjunctiveRefine","addRefine","addFacetExclusion","addExclude","addTag","removeDisjunctiveRefine","removeRefine","removeFacetExclusion","removeExclude","removeTag","toggleFacetExclusion","toggleExclude","toggleRefine","toggleTag","nextPage","previousPage","newState","overrideStateWithoutTriggeringChangeEvent","hasRefinements","isDisjunctiveRefined","hasTag","hasTagRefinements","getIndex","getPage","getTags","states","mainQueries","derivedQueries","queriesCount","helper","derivedStateQueries","queryId","_dispatchAlgoliaResponse","_dispatchAlgoliaError","s","specificResults","containsRefinement","_hasDisjunctiveRefinements","disjunctiveRefinements","event","clearCache","newClient","getClient","derive","pos","hasPendingRequests","algoliasearchHelper","version","createOptionalFilter","attributeValue","attributeScore","getSearchParametersFromProps","optionalFilters","matchingPatterns","attributePattern","score","attributeSubValue","transformSearchParameters","sumOrFiltersScores","objectID","_prevSearchState","searchParametersKeys","_searchParameters","ConfigureRelatedItems","propTypes","connectConfigureRelatedItems","transformItems","maxValuesPerFacet","_searchState","attributesToRender","facetOrder","Math","max","getAttribute","Children","only","connectDynamicWidgets","Fallback","fallbackComponent","set","Fragment","widgetKey","getWidgetRefinements","widgetState","rangeKey","transformRuleContexts","ruleContexts","trackedFilters","_1","canRefine","userData","transformedItems","nextRuleContexts","newRuleContexts","facetRefinements","trackedFacetValues","getTrackedFacetValues","includes","initialRuleContexts","connectQueryRules","getIndexContext","Index","indexContext","addAlgoliaAgents","searchClient","ReactVersion","isMultiIndexContext","widget","isTargetedIndexEqualIndex","isIndexWidget","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","isFirstWidgetIndex","isSecondWidgetIndex","serializeQueryParameters","format","encodeURIComponent","createInstantSearchManager","searchCounter","onWidgetsUpdate","scheduled","baseMethod","_ref$initialState","initialState","resultsState","stalledSearchDelay","skip","stalledSearchTimer","handleSearchSuccess","handleSearchError","initialSearchParameters","scheduleUpdate","getWidgets","transporter","_cacheHydrated","_useCache","requests","methodArgs","requestsWithSerializedParams","request","responsesCache","method","rawResults","cache","datum","nestedItem","_internalIndexId","sharedParameters","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","derivedParameters","isDerivedHelpersEmpty","nextIsSearchStalled","getWidgetsIds","meta","_ref5$maxFacetHits","maxFacetHitsWithinRange","min","onExternalStateUpdate","updateClient","updateIndex","newIndex","skipSearch","injectMetadata","internalProps","payloadContainer","document","createElement","refNode","querySelector","payload","widgetsPayload","_connectorDesc","_ref2$defaultProps","_ref2$displayName","ua","userAgent","_ua","appendChild","isControlled","InstantSearch","instantSearchManager","onWidgetsInternalStateUpdate","prevIsControlled","refresh","navigator","getKnownKeys","widgetsCollector","prevState","nextIsControlled","previousSearchState","getCurrentRefinement","getBoundingBoxId","currentRefinementToString","northEast","lat","lng","southWest","stringToPosition","pattern","latLngRegExp","nextValue","transformValue","label","clearsQuery","clear","currentRefinementFromSearchState","currentRefinementFromSearchParameters","currentPositionFromSearchState","propsWithoutDefaultRefinement","aroundLatLng","configureAroundLatLng","currentPositionFromSearchParameters","_","_geoloc","isRefinedWithMap","truncate","limit","highlight","highlightProperty","_ref$postTag","highlightObject","showMore","showMoreLimit","itemsLimit","rootAttribute","parseInt","getStateWithoutPage","nbPages","cachedHits","cachedState","hitsWithPositionsAndQueryID","firstReceivedPage","lastReceivedPage","hasPrevious","_cache","read","write","Number","hasMore","refinePrevious","refineNext","getValue","getLimit","defaultSortBy","searchable","searchForFacetValuesResults","isFromSearch","_highlightResult","highlighted","stringifyItem","start","end","noRefinement","range","NEGATIVE_INFINITY","POSITIVE_INFINITY","refinedItem","startStr","_value$split2","endStr","hostname","url","currentRange","isFloatPrecision","precision","nextMin","nextMax","hasMinBound","hasMaxBound","hasMinRefinment","hasMaxRefinment","getCurrentRefinementWithRange","nextValueForRefinement","hasBound","isReset","currentMinRange","currentMaxRange","isMinReset","isMaxReset","nextMinAsNumber","nextMaxAsNumber","isNextMinValid","isFinite","isNextMaxValid","header","footer","minBound","maxBound","hasFacet","boundaries","pow","floor","ceil","rangeMin","rangeMax","_currentRange","minRange","maxRange","minValue","maxValue","hasMin","hasMax","fragments","selectedValue","addKey","addRefinementKey","nextSelectedItems","scrollOn","cleanedSearchState","hasNotChanged","isVirtualReplica","appliedRelevancyStrictness","isRelevantSorted","selectedIndex","allSearchResults","areHitsSorted","nbSortedHits","falsyStrings","allFacetValues","facetValueCount","allFacetValuesCount","checked","unchecked","nextSearchParameters","wrapInsightsClient","aa","currentHit","inferredPayload","objectIDs","positions","getAdditionalId","getCurrentRefinementQuery","language","additionalQueryParameters","ignorePlurals","removeStopWords","optionalWords","interimState","ExperimentalDynamicWidgets","DynamicWidgets","EXPERIMENTAL_connectDynamicWidgets","inferredIndexId","insightsClient","insights","defaultTranslations","Translatable","translations","translation","translate"],"mappings":"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"}