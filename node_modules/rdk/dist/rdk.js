(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode("._backdrop_uxwv8_1 {\n  position: fixed;\n  background: var(--color-layer-transparent);\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  opacity: 0;\n  user-select: none;\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
import React, { useEffect, createContext, useState, useRef, useLayoutEffect, forwardRef, useImperativeHandle, useCallback, Fragment, useMemo, cloneElement, useContext } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
import { disableBodyScroll, clearAllBodyScrollLocks } from "body-scroll-lock-upgrade";
import { motion, AnimatePresence } from "framer-motion";
import { createPortal } from "react-dom";
import classNames from "classnames";
import PopperJS from "popper.js";
const useExitListener = ({
  ref,
  open = true,
  onClickOutside,
  onEscape
}) => {
  useEffect(() => {
    if (!open) {
      return;
    }
    const handleClick = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        onClickOutside == null ? void 0 : onClickOutside(event);
      }
    };
    const handleKey = (event) => {
      if (event.code === "Escape") {
        onEscape == null ? void 0 : onEscape(event);
      }
    };
    if (onClickOutside) {
      document.addEventListener("mousedown", handleClick);
      document.addEventListener("touchstart", handleClick);
    }
    if (onEscape) {
      document.addEventListener("keydown", handleKey);
    }
    return () => {
      if (onClickOutside) {
        document.removeEventListener("mousedown", handleClick);
        document.removeEventListener("touchstart", handleClick);
      }
      if (onEscape) {
        document.removeEventListener("keydown", handleKey);
      }
    };
  }, [ref, onClickOutside, onEscape, open]);
};
const OverlayContext = createContext({
  close: () => void 0
});
let id = 0;
const genId = () => `ref-${++id}`;
const useId = (idFromProps) => {
  const [id2] = useState(idFromProps || genId());
  return `${id2}`;
};
const useUnmount = (fn) => {
  const fnRef = useRef(fn);
  fnRef.current = fn;
  useLayoutEffect(() => () => fnRef.current(), []);
};
const Portal = forwardRef(
  ({ children, className, element = "div", onMount, onUnmount }, ref) => {
    const elementRef = useRef(null);
    const mounted = useRef(false);
    useEffect(() => {
      if (className && elementRef.current) {
        elementRef.current.setAttribute("class", `${className} rdk-portal`);
      }
    }, [className, elementRef.current]);
    useLayoutEffect(() => {
      elementRef.current = document.createElement(element);
      onMount == null ? void 0 : onMount();
    }, []);
    useUnmount(() => {
      onUnmount == null ? void 0 : onUnmount();
      const ref2 = elementRef.current;
      if (ref2 && document.body.contains(ref2)) {
        document.body.removeChild(ref2);
      }
    });
    useImperativeHandle(ref, () => elementRef.current);
    if (!elementRef.current) {
      return null;
    }
    if (!mounted.current) {
      mounted.current = true;
      elementRef.current.classList.add("rdk-portal");
      document.body.appendChild(elementRef.current);
    }
    return createPortal(children, elementRef.current);
  }
);
const portals = [];
const START_INDEX = 990;
const OverlayPortal = forwardRef(
  ({ className, children, onMount, onUnmount, appendToBody, id: id2 }, ref) => {
    let portalId = useId(id2);
    const [portalIndex, setPortalIndex] = useState(null);
    const [overlayIndex, setOverlayIndex] = useState(null);
    const portalRef = useRef(null);
    useImperativeHandle(ref, () => portalRef.current);
    return /* @__PURE__ */ jsx(
      Portal,
      {
        className,
        ref: portalRef,
        appendToBody,
        onMount: () => {
          portals.push(portalId);
          let pidx = portals.indexOf(portalId);
          setPortalIndex(pidx);
          const overlayIdx = START_INDEX + pidx * 2 + 1;
          setOverlayIndex(overlayIdx);
          onMount == null ? void 0 : onMount({
            portalId,
            overlayIndex: overlayIdx,
            portalIndex: pidx,
            backdropIndex: overlayIdx
          });
        },
        onUnmount: () => {
          onUnmount == null ? void 0 : onUnmount();
          portals.splice(portals.indexOf(portalId), 1);
          setPortalIndex(null);
          setOverlayIndex(null);
        },
        children: children({
          overlayIndex,
          portalIndex,
          backdropIndex: overlayIndex,
          portalId
        })
      }
    );
  }
);
OverlayPortal.defaultProps = {
  appendToBody: true
};
const backdrop = "_backdrop_uxwv8_1";
const css = {
  backdrop
};
const Backdrop = ({
  portalIndex,
  zIndex,
  className,
  onClick
}) => /* @__PURE__ */ jsx(
  motion.div,
  {
    className: classNames(css.backdrop, className),
    initial: { opacity: 0 },
    animate: { opacity: 0.8 - portalIndex / 10 },
    exit: { opacity: 0 },
    style: { zIndex },
    onClick
  }
);
Backdrop.defaultProps = {
  zIndex: 998,
  portalIndex: 0
};
const GlobalOverlay = ({
  open,
  hasBackdrop = true,
  closeOnEscape = true,
  closeOnBackdropClick = true,
  backdropClassName,
  children,
  onClose
}) => {
  const overlayRef = useRef(null);
  const onBackdropClick = useCallback(() => {
    if (closeOnBackdropClick) {
      onClose == null ? void 0 : onClose();
    }
  }, [closeOnBackdropClick, onClose]);
  useExitListener({
    ref: overlayRef,
    open,
    onEscape: () => closeOnEscape && (onClose == null ? void 0 : onClose())
  });
  useEffect(() => {
    if (open && overlayRef.current !== void 0) {
      disableBodyScroll(overlayRef.current, {
        // allowTouchMove determines which elements to allow touchmove events for iOS https://github.com/rick-liruixin/body-scroll-lock-upgrade?tab=readme-ov-file#allowtouchmove
        //@ts-expect-error: allowTouchMove is typed wrong: https://github.com/rick-liruixin/body-scroll-lock-upgrade/issues/21
        allowTouchMove: (el) => {
          while (el && el !== document.body) {
            if (el.getAttribute("body-scroll-lock-ignore") !== null) {
              return true;
            }
            if (el.parentElement !== null) {
              el = el.parentElement;
            }
          }
          return false;
        }
      });
    } else {
      clearAllBodyScrollLocks();
    }
    return () => {
      clearAllBodyScrollLocks();
    };
  }, [children, open]);
  return /* @__PURE__ */ jsx(OverlayContext.Provider, { value: { close: () => onClose == null ? void 0 : onClose() }, children: /* @__PURE__ */ jsx(AnimatePresence, { children: open && /* @__PURE__ */ jsx(OverlayPortal, { ref: overlayRef, children: ({ overlayIndex, portalIndex }) => /* @__PURE__ */ jsxs(Fragment, { children: [
    hasBackdrop && /* @__PURE__ */ jsx(
      Backdrop,
      {
        zIndex: overlayIndex,
        portalIndex,
        onClick: onBackdropClick,
        className: backdropClassName
      }
    ),
    /* @__PURE__ */ jsx("div", { "body-scroll-lock-ignore": "true", children: children({ overlayIndex, portalIndex }) })
  ] }) }) }) });
};
const OverlayTrigger = forwardRef(
  ({
    children,
    className,
    elementType = "span",
    trigger = ["click"],
    onOpen = () => void 0,
    onClose = () => void 0
  }, ref) => {
    const hasTrigger = useCallback(
      (type) => {
        if (Array.isArray(trigger)) {
          return trigger.includes(type);
        } else {
          return type === trigger;
        }
      },
      [trigger]
    );
    const onFocus = useCallback(
      (event) => {
        if (hasTrigger("focus")) {
          onOpen({ type: "focus", nativeEvent: event });
        }
      },
      [onOpen, hasTrigger]
    );
    const onBlur = useCallback(
      (event) => {
        if (hasTrigger("focus")) {
          onClose({ type: "focus", nativeEvent: event });
        }
      },
      [onClose, hasTrigger]
    );
    const onMouseEnter = useCallback(
      (event) => {
        if (hasTrigger("hover")) {
          onOpen({ type: "hover", nativeEvent: event });
        }
      },
      [onOpen, hasTrigger]
    );
    const onMouseLeave = useCallback(
      (event) => {
        if (hasTrigger("hover")) {
          onClose({ type: "hover", nativeEvent: event });
        }
      },
      [onClose, hasTrigger]
    );
    const onClick = useCallback(
      (event) => {
        if (hasTrigger("click")) {
          onOpen({ type: "click", nativeEvent: event });
        }
        if (!hasTrigger("click")) {
          onClose({ type: "hover", nativeEvent: event });
        }
      },
      [onOpen, onClose, hasTrigger]
    );
    const onContextMenu = useCallback(
      (event) => {
        if (hasTrigger("contextmenu")) {
          event.preventDefault();
          onOpen({ type: "contextmenu", nativeEvent: event });
        }
      },
      [onOpen]
    );
    const tabIndex = hasTrigger("focus") ? -1 : void 0;
    const Component = elementType;
    return /* @__PURE__ */ jsx(
      Component,
      {
        ref,
        tabIndex,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        onClick,
        onContextMenu,
        className,
        children
      }
    );
  }
);
const usePosition = (reference, { followCursor, placement, modifiers } = {}) => {
  const elementRef = useRef(null);
  const popper = useRef(null);
  const mouse = useRef({
    pageX: 0,
    pageY: 0
  });
  const refPointer = reference.current;
  const popperRef = useMemo(() => {
    const refObj = reference;
    if (refObj.current !== void 0) {
      return refObj.current;
    }
    const refElement = reference;
    if (followCursor) {
      return {
        getBoundingClientRect: () => ({
          top: mouse.current.pageY,
          right: mouse.current.pageX,
          bottom: mouse.current.pageY,
          left: mouse.current.pageX,
          width: 0,
          height: 0
        }),
        clientWidth: 0,
        clientHeight: 0
      };
    } else if (refElement && !refElement.getBoundingClientRect) {
      const { top, left, width, height } = reference;
      return {
        getBoundingClientRect: () => ({
          top,
          left,
          width,
          bottom: top - height,
          right: left - width,
          height
        }),
        clientWidth: width,
        clientHeight: height
      };
    }
    return refElement;
  }, [followCursor, reference, refPointer, mouse]);
  useLayoutEffect(() => {
    let rqf;
    const onMouseMove = ({ pageX, pageY }) => {
      var _a;
      mouse.current = { pageX, pageY };
      (_a = popper.current) == null ? void 0 : _a.scheduleUpdate();
    };
    const onWindowScroll = () => {
      rqf = requestAnimationFrame(() => {
        var _a;
        (_a = popper.current) == null ? void 0 : _a.scheduleUpdate();
      });
    };
    if (elementRef.current && popperRef) {
      popper.current = new PopperJS(popperRef, elementRef.current, {
        placement: placement || "top",
        modifiers: modifiers || {},
        onCreate: () => {
          window.addEventListener("scroll", onWindowScroll);
          if (followCursor) {
            window.addEventListener("mousemove", onMouseMove);
          }
        }
      });
    }
    return () => {
      var _a;
      if (!elementRef.current) {
        (_a = popper.current) == null ? void 0 : _a.destroy();
        cancelAnimationFrame(rqf);
        window.removeEventListener("scroll", onWindowScroll);
        if (followCursor) {
          window.removeEventListener("mousemove", onMouseMove);
        }
      }
    };
  }, [elementRef.current]);
  useLayoutEffect(() => {
    if (popper.current) {
      popper.current.reference = popperRef;
      popper.current.scheduleUpdate();
    }
  }, [popperRef]);
  return [elementRef, popper];
};
function CloneElement({
  children,
  element,
  childRef,
  ...rest
}) {
  const getProjectedProps = useMemo(
    () => (props) => {
      const childProps = element.props;
      return Object.keys(props).reduce((acc, key) => {
        const prop = props[key];
        const childProp = childProps[key];
        if (typeof prop === "function" && typeof childProp === "function") {
          acc[key] = (...args) => {
            prop(...args);
            childProp(...args);
          };
        } else if (key === "className") {
          acc[key] = classNames(prop, childProp);
        } else {
          acc[key] = prop;
        }
        return acc;
      }, {});
    },
    [rest]
  );
  if (element === null) {
    return children;
  }
  const ref = childRef ? (node) => {
    if (typeof childRef === "function") {
      childRef(node);
    } else if (ref) {
      childRef.current = node;
    }
  } : void 0;
  const newProps = getProjectedProps(rest);
  return cloneElement(element, {
    ...element.props,
    ...newProps,
    children,
    ref
  });
}
function useUserSelect(active) {
  useEffect(() => {
    if (active) {
      document.body.style.userSelect = "none";
      return () => void (document.body.style.userSelect = "initial");
    }
  }, [active]);
}
function useCursor(hovered, onPointerOver = "pointer", onPointerOut = "auto") {
  React.useEffect(() => {
    if (hovered) {
      document.body.style.cursor = onPointerOver;
      return () => void (document.body.style.cursor = onPointerOut);
    }
  }, [hovered]);
}
const ConnectedOverlayContent = forwardRef(
  ({
    triggerRef,
    children,
    portalClassName,
    closeOnBodyClick,
    closeOnEscape,
    elementType,
    appendToBody,
    followCursor,
    modifiers,
    placement,
    onClose
  }, ref) => {
    const id2 = useId();
    const [overlayIndex, setOverlayIndex] = useState(null);
    const [positionRef, popperRef] = usePosition(triggerRef, {
      followCursor,
      modifiers,
      placement
    });
    useImperativeHandle(ref, () => ({
      updatePosition: () => {
        var _a;
        (_a = popperRef == null ? void 0 : popperRef.current) == null ? void 0 : _a.scheduleUpdate();
      }
    }));
    const onClickOutside = useCallback(
      (event) => {
        if (closeOnBodyClick) {
          let ref2 = null;
          if (triggerRef.current) {
            ref2 = triggerRef.current;
          } else if (triggerRef.contains !== void 0) {
            ref2 = triggerRef;
          }
          const container = event.target.closest(".rdk-portal");
          const isLast = portals.indexOf(id2) === portals.length - 1;
          if (!(ref2 == null ? void 0 : ref2.contains(event.target)) && (isLast || !container)) {
            onClose == null ? void 0 : onClose(event);
          }
        }
      },
      [closeOnBodyClick, onClose]
    );
    const onEscape = useCallback(() => {
      if (closeOnEscape) {
        onClose == null ? void 0 : onClose();
      }
    }, [closeOnEscape, onClose]);
    useExitListener({
      open: true,
      ref: positionRef,
      onClickOutside,
      onEscape
    });
    useEffect(() => {
      if (positionRef && overlayIndex) {
        positionRef.current.style.zIndex = overlayIndex;
      }
    }, [positionRef.current, overlayIndex]);
    return /* @__PURE__ */ jsx(
      OverlayPortal,
      {
        id: id2,
        ref: positionRef,
        className: portalClassName,
        elementType,
        appendToBody,
        onMount: (event) => setOverlayIndex(event.overlayIndex),
        onUnmount: () => setOverlayIndex(null),
        children
      }
    );
  }
);
ConnectedOverlayContent.defaultProps = {
  closeOnBodyClick: true,
  closeOnEscape: true,
  appendToBody: true,
  placement: "bottom"
};
const ConnectedOverlay = forwardRef(
  ({
    reference,
    children,
    open,
    content,
    triggerElement,
    triggerClassName,
    trigger,
    onOpen,
    onClose,
    ...rest
  }, ref) => {
    const mounted = useRef(false);
    const overlayTriggerRef = useRef(null);
    const contentRef = useRef(null);
    const triggerRef = reference || overlayTriggerRef;
    useImperativeHandle(ref, () => ({
      updatePosition: () => {
        var _a;
        (_a = contentRef.current) == null ? void 0 : _a.updatePosition();
      }
    }));
    useEffect(() => {
      if (mounted.current) {
        if (!open) {
          onClose == null ? void 0 : onClose();
        } else {
          onOpen == null ? void 0 : onOpen();
        }
      }
    }, [open]);
    useEffect(() => {
      if (!mounted.current) {
        mounted.current = true;
      }
    });
    const providerValue = useMemo(
      () => ({
        close: () => onClose == null ? void 0 : onClose()
      }),
      [onClose]
    );
    return /* @__PURE__ */ jsxs(OverlayContext.Provider, { value: providerValue, children: [
      children && /* @__PURE__ */ jsx(Fragment, { children: trigger ? /* @__PURE__ */ jsx(
        OverlayTrigger,
        {
          elementType: triggerElement,
          ref: overlayTriggerRef,
          className: triggerClassName,
          trigger,
          onOpen,
          onClose,
          children
        }
      ) : children }),
      /* @__PURE__ */ jsx(AnimatePresence, { children: open && /* @__PURE__ */ jsx(
        ConnectedOverlayContent,
        {
          ...rest,
          ref: contentRef,
          triggerRef,
          onClose,
          children: content
        }
      ) })
    ] });
  }
);
ConnectedOverlay.defaultProps = {
  trigger: "click"
};
const useOverlay = () => {
  const context = useContext(OverlayContext);
  if (context === void 0) {
    throw new Error(
      "`useOverlay` hook can only be used inside a overlay component."
    );
  }
  return context;
};
export {
  Backdrop,
  CloneElement,
  ConnectedOverlay,
  ConnectedOverlayContent,
  GlobalOverlay,
  OverlayContext,
  OverlayPortal,
  OverlayTrigger,
  Portal,
  portals,
  useCursor,
  useExitListener,
  useId,
  useOverlay,
  usePosition,
  useUserSelect
};
//# sourceMappingURL=rdk.js.map
