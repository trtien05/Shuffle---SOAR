'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var index = (function (initialValue) {
  var _useState = react.useState(initialValue),
      _useState2 = slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var toggler = react.useCallback(function () {
    return setValue(function (value) {
      return !value;
    });
  });
  return [value, toggler];
});

var index$1 = (function (_ref) {
  var onChange = _ref.onChange,
      refEl = _ref.refEl;

  var _useState = react.useState(false),
      _useState2 = slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  var handleMouseDown = function handleMouseDown() {
    setValue(true);
    onChange(true);
  };
  var handleMouseUp = function handleMouseUp() {
    setValue(false);
    onChange(false);
  };
  react.useEffect(function () {
    if (refEl && refEl.current) {
      refEl.current.addEventListener("mousedown", handleMouseDown);
      refEl.current.addEventListener("mouseup", handleMouseUp);
    }
    return function () {
      if (refEl && refEl.current) {
        refEl.current.removeEventListener("mousedown", handleMouseDown);
        refEl.current.removeEventListener("mouseup", handleMouseUp);
      }
    };
  }, []);

  return value;
});

var index$2 = (function (_ref) {
  var startImmediate = _ref.startImmediate,
      duration = _ref.duration,
      callback = _ref.callback;

  var _useState = react.useState(0),
      _useState2 = slicedToArray(_useState, 2),
      count = _useState2[0],
      updateCount = _useState2[1];

  var _useState3 = react.useState(startImmediate === undefined ? true : startImmediate),
      _useState4 = slicedToArray(_useState3, 2),
      intervalState = _useState4[0],
      setIntervalState = _useState4[1];

  var _useState5 = react.useState(null),
      _useState6 = slicedToArray(_useState5, 2),
      intervalId = _useState6[0],
      setIntervalId = _useState6[1];

  react.useEffect(function () {
    if (intervalState) {
      var _intervalId = setInterval(function () {
        updateCount(count + 1);
        callback && callback();
      }, duration);
      setIntervalId(_intervalId);
    }

    return function () {
      if (intervalId) {
        clearInterval(intervalId);
        setIntervalId(null);
      }
    };
  }, [intervalState, count]);
  return {
    intervalId: intervalId,
    start: function start() {
      setIntervalState(true);
    },
    stop: function stop() {
      setIntervalState(false);
    }
  };
});

//initial={{ sounds: true, music: true, graphics: 'medium' }}

var index$3 = (function (initial) {
  var _useState = react.useState(function () {
    return initial;
  }),
      _useState2 = slicedToArray(_useState, 2),
      mapValue = _useState2[0],
      setMapValue = _useState2[1];

  return {
    values: mapValue,
    clear: function clear() {
      return setMapValue({});
    },
    reset: function reset() {
      return setMapValue(initial);
    },
    set: function set$$1(key, updater) {
      setMapValue(function (prev) {
        return _extends({}, prev, defineProperty({}, key, typeof updater === "function" ? updater(prev[key]) : updater));
      });
    },
    get: function get$$1(key) {
      return mapValue[key];
    },
    has: function has(key) {
      return mapValue[key] != null;
    },
    delete: function _delete(key) {
      return setMapValue(function (_ref) {
        var deleted = _ref[key],
            prev = objectWithoutProperties(_ref, [key]);
        return prev;
      });
    }
  };
});

exports.useToggle = index;
exports.useActive = index$1;
exports.useInterval = index$2;
exports.useMap = index$3;
//# sourceMappingURL=index.js.map
