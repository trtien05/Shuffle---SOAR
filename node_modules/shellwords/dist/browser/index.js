var shellwords = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toCommonJS = /* @__PURE__ */ ((cache) => {
    return (module, temp) => {
      return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
    };
  })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

  // src/shellwords.ts
  var shellwords_exports = {};
  __export(shellwords_exports, {
    escape: () => escape,
    split: () => split
  });
  var scan = (string, pattern, callback) => {
    let result = "";
    while (string.length > 0) {
      const match = string.match(pattern);
      if (match && match.index != null && match[0] != null) {
        result += string.slice(0, match.index);
        result += callback(match);
        string = string.slice(match.index + match[0].length);
      } else {
        result += string;
        string = "";
      }
    }
    return result;
  };
  var split = (line = "") => {
    const words = [];
    let field = "";
    scan(line, /\s*(?:([^\s\\\'\"]+)|'((?:[^\'\\]|\\.)*)'|"((?:[^\"\\]|\\.)*)"|(\\.?)|(\S))(\s|$)?/, (match) => {
      const [_raw, word, sq, dq, escape2, garbage, separator] = match;
      if (garbage != null) {
        throw new Error(`Unmatched quote: ${line}`);
      }
      if (word) {
        field += word;
      } else {
        let addition;
        if (sq) {
          addition = sq;
        } else if (dq) {
          addition = dq;
        } else if (escape2) {
          addition = escape2;
        }
        if (addition) {
          field += addition.replace(/\\(?=.)/, "");
        }
      }
      if (separator != null) {
        words.push(field);
        field = "";
      }
    });
    if (field) {
      words.push(field);
    }
    return words;
  };
  var escape = (str = "") => {
    return str.replace(/([^A-Za-z0-9_\-.,:\/@\n])/g, "\\$1").replace(/\n/g, "'\n'");
  };
  return __toCommonJS(shellwords_exports);
})();
//# sourceMappingURL=index.js.map
