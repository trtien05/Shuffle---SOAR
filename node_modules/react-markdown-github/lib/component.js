'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactMarkdown = require('react-markdown');

var _reactMarkdown2 = _interopRequireDefault(_reactMarkdown);

var _ghSlugify = require('./gh-slugify');

var _ghSlugify2 = _interopRequireDefault(_ghSlugify);

var _urlParse = require('url-parse');

var _urlParse2 = _interopRequireDefault(_urlParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var isHash = /^#/;

/**
 * A react component that wraps [react-markdown](react-markdown) that:
 * -  links all headers with an anchor link.
 * -  resolves all relative links to absolute Github URLs based on the sourceUri of the document.
 *      e.g. /foo/bar.md becomes https://github.mycorp.com/org/component/blob/master/foo/bar.md
 * -  allows the parent component to override the resolved url
 *
 * @class ReactMarkdownGithub
 * @api public
 */

var ReactMarkdownGithub = function (_Component) {
  _inherits(ReactMarkdownGithub, _Component);

  function ReactMarkdownGithub() {
    _classCallCheck(this, ReactMarkdownGithub);

    var _this = _possibleConstructorReturn(this, (ReactMarkdownGithub.__proto__ || Object.getPrototypeOf(ReactMarkdownGithub)).apply(this, arguments));

    _this.slugify = new _ghSlugify2.default();
    _this.transformLinkUri = _this.transformLinkUri.bind(_this);
    _this.renderHeading = _this.renderHeading.bind(_this);
    _this.transformImageUri = _this.transformImageUri.bind(_this);

    _this.state = {};
    return _this;
  }

  /**
   * Parses url into usable github components.
   * @param {String} uri - a valid Github url.
   * @returns {Object} { github, org, repo, filename, filepath, branch }
   * @api private
   */


  _createClass(ReactMarkdownGithub, [{
    key: 'normalizeLinkUri',


    /**
    * Converts the passed url until an absolute url. If the passed URL is absolute
    * it will be returned unmodified. If the URL is realitive then it will be
    * merged with the current `sourceUri` property.
    *
    * @param {String} uri - absolute or realitive URL.
    * @returns {url} - will return a absolute URL.
    * @api private
    */
    value: function normalizeLinkUri(uri) {
      // Do not attempt to parse "pure" hashes since they
      // are not fully qualified URLs by definition. This will
      // not work for querystring plus hash, but Github does not
      // support querystring so this is by design.
      if (isHash.test(uri)) {
        return uri;
      }

      var withinFile = new RegExp('.?/?' + this.state.filename + '#(.*)$', 'i');
      var parsed = new _urlParse2.default(uri, this.props.sourceUri);
      var isWithinFile = withinFile.test(uri);

      return isWithinFile ? parsed.hash : parsed.href;
    }

    /**
    * The callback handler from `ReactMarkdown` .
    *
    * @param {String} uri - Markdown link URL.
    * @param {Object} children - Child Elements of the link.
    * @param {String} title - link title.
    * @returns {url} - will return a absolute URL.
    * @api private
    */

  }, {
    key: 'transformLinkUri',
    value: function transformLinkUri(uri, children, title) {
      var transformLinkUri = this.props.transformLinkUri;

      var normalized = this.normalizeLinkUri(uri);
      var opts = _extends({}, this.state, { uri: normalized, children: children, title: title });
      return transformLinkUri && transformLinkUri(opts) || normalized;
    }

    /**
    * The callback handler from `ReactMarkdown` .
    *
    * @param {String} uri - Markdown image URL.
    * @returns {url} - will return a absolute URL.
    * @api private
    */

  }, {
    key: 'transformImageUri',
    value: function transformImageUri(uri) {
      var transformImageUri = this.props.transformImageUri;

      var opts = _extends({}, this.state, { uri: uri });
      return transformImageUri && transformImageUri(opts) || uri;
    }

    /**
    * The callback handler from `ReactMarkdown` . Generates an `A` anchor link
    * around the Header text
    *
    * @param {Object} props - properties passed from `ReactMarkdown`
    * @param {Int} props.level - The level of the header to render. used for
    * generating <h{1-n}>
    * @param {Array} props.children - Array of strings from the heading
    * @returns {Component} - A react component for the linked header.
    * @api private
    */

  }, {
    key: 'renderHeading',
    value: function renderHeading(props) {
      var uniqueSlug = this.slugify.slugNode(props.children);

      // eslint-disable-next-line react/no-children-prop
      return _react2.default.createElement('h' + props.level, {
        id: uniqueSlug,
        className: 'headline-primary',
        children: _react2.default.createElement(
          'a',
          { href: '#' + uniqueSlug },
          props.children
        )
      });
    }

    /**
    * @returns {ReactMarkdown} react tree
    * @api private
    */

  }, {
    key: 'render',
    value: function render() {
      var renderers = _extends({
        heading: this.renderHeading
      }, this.props.renderers);
      this.slugify.reset();
      return _react2.default.createElement(_reactMarkdown2.default, _extends({}, this.props, {
        renderers: renderers,
        transformLinkUri: this.transformLinkUri,
        transformImageUri: this.transformImageUri
      }));
    }
  }], [{
    key: 'normalizeGithubUrl',
    value: function normalizeGithubUrl(uri) {
      var _ref = new _urlParse2.default(uri),
          origin = _ref.origin,
          pathname = _ref.pathname;

      var parts = pathname.split('/');

      var _parts = _slicedToArray(parts, 3),
          org = _parts[1],
          repo = _parts[2];

      var filepath = '/' + parts.slice(5).join('/');
      var filename = parts[parts.length - 1];
      var branch = parts[4];

      return {
        github: origin + '/',
        filepath: filepath,
        filename: filename,
        org: org,
        repo: repo,
        branch: branch
      };
    }

    /**
    * React lifecyle method to ensure that the github url prop is parsed each time
    * it is updated.
    * @param {Object} nextProps - new component props
    * @param {Object} prevState - prior component state
    * @returns {Object} returns new state or null if not modified.
    * @api private
    */

  }, {
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(_ref2, prevState) {
      var sourceUri = _ref2.sourceUri;

      if (sourceUri !== prevState.sourceUri) {
        return _extends({
          sourceUri: sourceUri
        }, ReactMarkdownGithub.normalizeGithubUrl(sourceUri));
      }
      return null;
    }
  }]);

  return ReactMarkdownGithub;
}(_react.Component);

exports.default = ReactMarkdownGithub;


ReactMarkdownGithub.propTypes = {
  /** {source} The Markdown content to be rendered by `ReactMarkdown` */
  source: _propTypes2.default.string,
  /** {sourceUri} The absolute url to the Github source document. All
   * relative urls will be assumed to be realitve to this file:
   * e.g. https://github.mycorp.com/org/component/blob/master/README.md'
   */
  sourceUri: _propTypes2.default.string,
  /** {transformLinkUri} The callback function executed for each found URL */
  transformLinkUri: _propTypes2.default.func,
  /** {transformImageUri} The callback function executed for each found image */
  transformImageUri: _propTypes2.default.func,
  /** {renderers} the collection of resolvers to pass to `ReactMarkdown` */
  renderers: _propTypes2.default.object,
  /** {className} the css class to to pass to `ReactMarkdown` */
  className: _propTypes2.default.string
};